<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux学习笔记(一)Centos</title>
    <url>/2024/10/22/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)Centos/</url>
    <content><![CDATA[<blockquote>
<p>本博客使用的是Centos7版本</p>
</blockquote>
<h1>学前提醒</h1>
<ol>
<li>不要死记Linux命令，先敲一遍，以后在学习和工作中练习就足够了，需要的时候就查命令手册</li>
<li>Centos在2024年已停止维护，这篇博客<strong>主要介绍Centos的基础命令(Linux发行版基础指令基本一样)，不涉及其进阶操作</strong>。建议读者可以学一下ubuntu、Debian等其他常用的Linux发行版</li>
</ol>
<h1>初识Linux</h1>
<ol>
<li>
<p>什么是Linux？即<strong>服务器操作系统</strong>的一种。<strong>操作系统就是第一层软件</strong>，作为用户和计算机硬件之间的桥梁，调度和管理计算机硬件进行工作。Linux是前后端开发人员、运维测试人员、大数据分析人员等必学的内容。</p>
</li>
<li>
<p>Linux的组成：由Linux系统<strong>内核</strong>+系统级应用<strong>程序</strong>(简单理解成系统自带的软件，比如文件管理，图片查看等)组成，其他的软件都叫第三方应用程序。这其中<strong>最重要的就是内核</strong>。读者可以点开此链接<a href="https://www.kernel.org">Linux内核官网</a> 下载其内核源码。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/ZyNvmFsY7xHLaoR.png" alt="Linux系统组成示意图.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/h1jPXA5fC9cpUxS.png" alt="Linux调度流程图.png"></p>
<ol start="3">
<li>Linux发行版：任何人都可以获得并修改内核，并且自行集成系统级程序，提供了内核+系统级程序的完整封装，称之为Linux发行版。常见的ubuntu和redhat等就是Linux的发行版。所以也<strong>不要纠结学哪一个，学会了一个，其他的都会触类旁通了</strong>。</li>
</ol>
<h2 id="虚拟机">虚拟机</h2>
<p>虚拟机就是借助虚拟化技术，我们可以在系统中，通过软件模拟计算机硬件，并给虚拟硬件安装真实的操作系统。</p>
<p>学习Linux可以选择使用虚拟软件，比如VMware WorkStation，或者是买一个云服务器。</p>
<p><strong>Windows网络连接(网络适配器)查看方法</strong>：<code>win+R</code> 输入<code>ncpa.cpl</code> 查看是否有VMnet1和VMnet8的网卡，有了虚拟机才能连上网。</p>
<h2 id="扩展：WSL">扩展：WSL</h2>
<p>就是Windows Subsystem for Linux，没错，Windows系统可以得到Linux系统环境，不过目前的主流还是用虚拟软件。</p>
<p>方法：(Windows 11)在开始中搜索-“启用或者关闭Windows功能”-“适用于Linux的Windows子系统 ”打勾，“虚拟机平台”打勾并重启，然后在应用商店里面搜索对应的Linux发行版下载即可。</p>
<h2 id="Linux的安装、配置和远程连接">Linux的安装、配置和远程连接</h2>
<ol>
<li>虚拟机软件安装：由于vmware被收购，<strong>对于个人用户完全免费</strong>，可以去官网上下载，参考教程<a href="https://b23.tv/b5GG1hz">一步步教你掌握VMware Workstation 17 Pro，成为虚拟化专家！-哔哩哔哩</a></li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/y39hfCNBVGPwodW.png" alt="001_Linux安装_01.png"></p>
<ol start="2">
<li>查看主机的网络适配器是否正常配置：按<strong>win + r</strong>  <strong>输入ncpa.cpl回车</strong>  确保里面有VMnet1和VMnet8</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/4OGLCP67h5WRuQs.png" alt="001_Linux安装_02.png"></p>
<ol start="3">
<li>在VMware中安装Centos系统</li>
</ol>
<p>考虑到国内访问Centos安装包源比较困难，这里使用清华的镜像源网站，且本次使用的是Centos7.6版本，读者需要安装其他版本的都可以在<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学镜像源网站</a>下面找。Centos下载链接：<a href="https://mirrors.tuna.tsinghua.edu.cn/centos-vault/7.6.1810/isos/x86_64/">清华大学开源软件镜像站</a></p>
<p><img src="https://s2.loli.net/2024/11/26/6TXloshZaMxe5Gb.png" alt="001_Linux安装_03.png"></p>
<p>下载好之后打开VMWare软件，点击左上角“文件”-“新建虚拟机”</p>
<p><img src="https://s2.loli.net/2024/11/26/TmFgOfBbyhpk5P1.png" alt="001_Linux安装_04.png"></p>
<p>选择“典型(推荐)”</p>
<p><img src="https://s2.loli.net/2024/11/26/iEqDytlGTUA1BoI.png" alt="001_Linux安装_05.png"></p>
<p>选择你下载的ISO文件的路径</p>
<p><img src="https://s2.loli.net/2024/11/26/yCS4VLrOlkcPxa1.png" alt="001_Linux安装_06.png"></p>
<p>设置用户名和密码</p>
<p><img src="https://s2.loli.net/2024/11/26/LrSInCBaeGyHmvR.png" alt="001_Linux安装_07.png"></p>
<p>设置虚拟机的位置</p>
<p><img src="https://s2.loli.net/2024/11/26/OFYfL1lHurxycpz.png" alt="001_Linux安装_08.png"></p>
<p>设置虚拟机的内存</p>
<p><img src="https://s2.loli.net/2024/11/26/dBoiQmA3gYUs2JC.png" alt="001_Linux安装_09.png"></p>
<p>自定义硬件 建议内核和内存不要分配太多</p>
<p><img src="https://s2.loli.net/2024/11/26/VMF36DuoO5PHf7S.png" alt="001_Linux安装_10.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/QFCR4KW9qiuV3Ih.png" alt="001_Linux安装_11.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/c4TzakLQJfmyeBr.png" alt="001_Linux安装_12.png"></p>
<p>后面就是自动安装了，大概需要10-20分钟左右。<strong>注意不要反复点击界面，否则可能会卡死需要重新安装</strong>。</p>
<ol start="4">
<li>登录虚拟机</li>
</ol>
<p>用你之前设置的用户登录虚拟机</p>
<p><img src="https://s2.loli.net/2024/11/26/HfvspbVyZ7Q19Ez.png" alt="001_Linux安装_13.png"></p>
<p>出现“Getting Started”界面，直接退出即可。出现此界面说明你已经安装好Centos了\(^o^)/~ ,不过<strong>这可不是结束的开始，而是开始的结束</strong>。</p>
<p><img src="https://s2.loli.net/2024/11/26/cCdubh7JPglyKnX.png" alt="001_Linux安装_14.png"></p>
<ol start="5">
<li>远程登录虚拟机</li>
</ol>
<p>Linux上面有图形化界面(在界面中右键-“open terminal”，但是<strong>不推荐</strong>。在开发中使用命令行的效率比图形化界面更好.<br>
但是VMware中的Linux命令行页面不方便，建议使用第三方软件远程连接到Linux上(<strong>生产环境中也是远程开发</strong>)，推荐软件有Xshell和finalshell。我这里使用Xshell，finalshell同理</p>
<p><a href="https://www.xshell.com/zh/xshell-download/">Xshell 下载官网</a> 建议使用“家庭和学校用户的免费许可证”下的“免费授权界面”下载Xshell和XFTP(用于传输文件),我这里下载的是7版本</p>
<p>打开Xshell后点击右上角的“文件”-“新建”。</p>
<p><img src="https://s2.loli.net/2024/11/26/OBJCuNZrl1AnjmL.png" alt="001_Linux安装_15.png"></p>
<p>此界面重要的<strong>填写主机IP</strong>。在Centos界面中右键-“open terminal” ，命令行输入<code>ifconfig</code> 回车</p>
<p>图中方框部分就是此虚拟机的IP，</p>
<p><img src="https://s2.loli.net/2024/11/26/SPk6sbQqvRAj3Bg.png" alt="001_Linux安装_16.png"></p>
<p>按照你自己查找的IP将其填写在主机(H)的框中即可。</p>
<p><img src="https://s2.loli.net/2024/11/26/cNIZh7Uq1XtKCMo.png" alt="001_Linux安装_17.png"></p>
<p>会弹出如下的警告界面，点击“接收并保存”</p>
<p><img src="https://s2.loli.net/2024/11/26/7WZFS6UeL9Aofwx.png" alt="001_Linux安装_18.png"></p>
<p>选择你登录的用户名，建议<strong>使用一般用户而不是root用户</strong>。我这里演示用就用root用户了。出现如下图表示登录成功</p>
<p><img src="https://s2.loli.net/2024/11/26/jNres98YMiIEfDO.png" alt="001_Linux安装_19.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/z16c7ZqIaLJBS5t.png" alt="001_Linux安装_20.png"></p>
<p>但是：Linux虚拟机如果重启，有可能发生IP改变，如果IP改变需要在XShell中修改连接的IP地址。以下讲解如何固定IP地址不变。</p>
<h2 id="Linux固定IP">Linux固定IP</h2>
<blockquote>
<p>可以在安装Centos的时候配置网络，参考链接如下<a href="https://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUc">day02-Docker - 飞书云文档</a></p>
</blockquote>
<p>在VMware软件中左上角点击“编辑”-“虚拟网络编辑器”，再点击“更改设置”，点击vmnet8并点击NAT设置</p>
<p><img src="https://s2.loli.net/2024/11/26/el6NtSZiP5ys3pE.png" alt="001_Linux安装_21.png"></p>
<p>按照子网设置网关IP，比如子网IP是192.188.190.0。<a href="http://xn--IP192-fq1h9c273ah50abj4fijah81khkn.188.190.xxx">那么网关IP就设置为192.188.190.xxx</a>。其中xxx在0-255之间，这里建议就用2代替xxx，IP</p>
<p>记住以上红色方框中的内容</p>
<p>然后用Xshell远程登录(使用root用户登录)，在命令行输入<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p>然后按<code>i</code>键后输入以下内容，根据自己的实际情况改。那个``IPADDR=“建议设置成你之前ifconfig查询的IP”`</p>
<p><img src="https://s2.loli.net/2024/11/26/96YVtLEy3BJ7CZS.png" alt="Linux配置IP.png"></p>
<p>再点击esc键，输入<code>:wq</code> 回车就保存并退出了</p>
<p>在命令行中输入并执行<code>systemctl restart network</code> 重启网卡，执行<code>ifconfig</code>即可看到ip地址固定为你设置的IP了。</p>
<h2 id="扩展：用vscode远程登录Linux">扩展：用vscode远程登录Linux</h2>
<blockquote>
<p>如果涉及到Linux编程而又不想只用vim，可以考虑使用vscode</p>
</blockquote>
<ol>
<li>下载vscode和插件 <a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></li>
</ol>
<p>然后按照图<strong>下载对应的插件</strong></p>
<p><img src="https://s2.loli.net/2024/11/26/E2gbTXPevDldcoM.png" alt="001_Linux安装_22.png"></p>
<p>安装好之后点击左下角矩形中的按钮，开启远程登录</p>
<p><img src="https://s2.loli.net/2024/11/26/luqcYS48wKR1Paf.png" alt="001_Linux安装_23.png"></p>
<p>点击“<strong>连接到主机</strong>”</p>
<p><img src="https://s2.loli.net/2024/11/26/Xnh7a4ZG3WwfEdC.png" alt="001_Linux安装_24.png"></p>
<p>这里点击“<strong>配置SSH主机</strong>”</p>
<p><img src="https://s2.loli.net/2024/11/26/hDmQWzekx8bS3oM.png" alt="001_Linux安装_25.png"></p>
<p>点击<strong>路径最后为\config</strong>的</p>
<p><img src="https://s2.loli.net/2024/11/26/jgxftQ4cKeWSVwb.png" alt="001_Linux安装_26.png"></p>
<p>注意如果你是第一次使用vscode 大概率是空的 按照以下格式填写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 你的LinuxIP</span><br><span class="line">	HostName 你的LinuxIP</span><br><span class="line">	User 选择一个登录用户，比如root</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 200.200.200.200</span><br><span class="line">	HostName 200.200.200.200</span><br><span class="line">	User root</span><br></pre></td></tr></table></figure>
<p>配置完后再次远程登录，点击你所设置的IP(见图<code>001_Linux安装_25</code>）</p>
<p>这样就远程登录成功了(＾－＾)V。</p>
<p>如果你想要<strong>打开某一文件夹</strong>进行编程，按照图片先点击”<strong>打开文件夹</strong>“然后选择即可。</p>
<p><img src="https://s2.loli.net/2024/11/26/Pp2tiQrnINgvuTo.png" alt="001_Linux安装_27.png"></p>
<h2 id="扩展：虚拟机快照">扩展：虚拟机快照</h2>
<p>在学习阶段我们无法避免的可能损坏Linux操作系统。如果损坏的话，重新安装一个Linux操作系统就会十分麻烦。，而vmware支持给Linux制作快照，简单来说就是“<strong>存档</strong>”，万一损坏了可以“<strong>回档</strong>”。</p>
<p>留下快照:右键虚拟机-点击“快照”-点击”拍摄快照“</p>
<p><img src="https://s2.loli.net/2024/11/26/ZSQfcM7jOy6BPKh.png" alt="001_Linux安装_28.png"></p>
<p>恢复快照：同样右键-快照-快照管理器，点击对应的快照并点击“转到”即可。</p>
<blockquote>
<p>小提醒：建议在关机之后留下快照，开机情况下会比较卡</p>
</blockquote>
<hr>
<blockquote>
<p>此LloydEduCentos仅作演示安装用，后续Linux学习使用的是hspEdu01的虚拟机，读者无需担心，不影响后续学习Linux</p>
</blockquote>
<h1>Linux基础</h1>
<p>学习Linux需要掌握<strong>命令</strong>来操作系统，图形化页面很少使用。图形化界面易于理解，但是命令行效率更高。</p>
<p>那么在哪里敲命令行呢？VMware里面可以，但是不方便。建议使用Xshell或者是FinalShell软件，这里我用的是Xshell。</p>
<h2 id="Linux目录结构">Linux目录结构</h2>
<p><strong>一切皆文件</strong>：指的是Linux会将一切对象映射成文件。Linux中最重要的就是目录，它不像Windows有CDE盘，只有一个根目录。<strong>在生产环境中是很少使用图形化界面的，基本只用控制台</strong>。对于其他目录要了解其英文单词和实际用途。</p>
<p>图片演示</p>
<p><img src="https://s2.loli.net/2024/11/26/FG2yNA4tCa5vLZb.png" alt="002_Linux目录结构_01.png"></p>
<ul>
<li><code>/</code>，根目录是最顶级的目录了，也就是说<code>~</code>是<code>/</code>的子目录</li>
<li>Linux有且只有一个顶级目录：<code>/</code></li>
<li>路径描述的层次关系同样适用<code>/</code>来表示:比如/usr/bin/hello.py,第一个<code>/</code>是<strong>根目录</strong>，其他的是<strong>层级关系</strong>。</li>
</ul>
<blockquote>
<p>注意，Linux中所有的用户在登录的时候左侧显示的都是<code>~</code> ,也就是自己的“根目录”，但其实是<code>/</code> 的子目录，<strong>其本质是/home/用户名或者是/root</strong></p>
</blockquote>
<h2 id="Linux基础命令">Linux基础命令</h2>
<blockquote>
<p>最重要的部分，学Linux就是学习使用命令与计算机交互</p>
</blockquote>
<p><strong>命令</strong>：就是Linux程序，以字符的方式与计算机交流。💡其<strong>本质</strong>上都是<strong>可执行的二进制文件</strong>。</p>
<p>无论是什么命令，用于什么用途，在Linux中，命令有其<strong>通用的格式</strong><br>
<code>command \[-options] [parameter]</code></p>
<ul>
<li>command:命令本身,比如touch\cat等</li>
<li>-options:[可选，非必填]命令的一些<strong>选项</strong>，可以通过选项控制命令的行为细节,比如rm -rf 其中-r -f为选项</li>
<li>parameter:[可选，非必填]命令的参数，多数用于命令的指向目标等. 语法中的[],表示可选的意思，比如touch file01.txt 后面的<code>file01.txt</code>就是命令的参数</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /home/hello</span><br></pre></td></tr></table></figure>
<p>ls是命令，-l是选项，/home/hello是参数，意思是以列表的形式，展示/home/hello 目录的内容。</p>
<h2 id="目录切换命令">目录切换命令</h2>
<h3 id="概念阐述：路径">概念阐述：路径</h3>
<p><strong>相对路径与绝对路径</strong></p>
<ul>
<li>
<p>相对路径，<strong>非</strong><code>/</code>开头的称之为相对路径：相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p>
</li>
<li>
<p>绝对路径，<strong>以</strong><code>/</code>开头的称之为绝对路径：绝对路径从<code>根</code>开始描述路径，比如<code>/home/jerry/download/test.txt</code> 指的就是jerry用户名下download文件内的test.txt文件。</p>
</li>
</ul>
<p><strong>特殊路径符</strong></p>
<ul>
<li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li>
<li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li>
<li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li>
</ul>
<h3 id="ls命令">ls命令</h3>
<p>功能：列出文件夹信息</p>
<p>语法：<code>ls [-l -h -a] [Linux路径]</code></p>
<ul>
<li>Linux路径：被查看的文件夹的路径，<strong>可以是绝对路径也可以是相对路径</strong>。不提供参数表示查看当前工作目录</li>
<li>-l，以列表(list)形式查看</li>
<li>-h，<strong>必须配合-l使用</strong>(否则不展示文件大小)，以更加人性化的方式显示文件大小</li>
<li>-a，表示all的意思，即显示所有文件，<strong>包括隐藏文件</strong>(在Linux中以<code>.</code>开头的，均是隐藏的)</li>
</ul>
<p>用的最多的一般是<code>ls</code>与<code>ls -lh</code></p>
<p>演示如下</p>
<p><img src="https://s2.loli.net/2024/11/26/J7ckzjlp3CeAaFv.png" alt="002_目录切换命令_01.png"></p>
<p>语法中的选项是可以组合使用的，比如学习的-和-l可以组合应用,比如<code>ls -la</code></p>
<p><img src="https://s2.loli.net/2024/11/26/BsDfNTpLqO5CzP9.png" alt="002_目录切换命令_02.png"></p>
<p>绝对路径和相对路径作为参数，效果相同|这里演示-h不配合-l使用的效果</p>
<p><img src="https://s2.loli.net/2024/11/26/Knm1CiuPWSXY6BD.png" alt="002_目录切换命令_03.png"></p>
<h3 id="cd命令">cd命令</h3>
<p>change directory</p>
<p><strong>注意</strong>：Linux登录的时候会将当前<strong>登录用户</strong>的HOME目录作为当前工作目录，所以<code>ls</code>命令列出的是HOME目录的内容,不要错将<code>~</code>当成根目录。HOME目录是指每个操作用户在Linux系统的个人账户目录，普通用户的HOME目录默认路径在：<code>/home/用户</code>。而root用户的HOME目录，在：<code>/root</code></p>
<p>功能：切换工作目录</p>
<p>语法：<code>cd [linux路径]</code></p>
<p>参数：目标目录，要切换去的地方，不提供默认切换到<strong>当前登录用户HOME目录</strong></p>
<h3 id="pwd命令">pwd命令</h3>
<p>print work directory</p>
<p>功能：展示当前所在的工作目录(绝对路径)</p>
<p>语法:<code>pwd</code></p>
<p><img src="https://s2.loli.net/2024/11/26/z7Wtw4VnYUTSGuD.png" alt="002_目录切换命令_04.png"></p>
<h2 id="文件-夹-操作命令">文件(夹)操作命令</h2>
<h3 id="mkdir命令">mkdir命令</h3>
<p>make directory</p>
<p>功能：创建文件夹</p>
<p>语法：<code>mkdir [-p] 参数</code></p>
<ul>
<li>参数：被创建文件夹的路径</li>
<li>选项：-p，可选，表示创建前置路径，比如你输入<code>mkdir -p /usr/test/work</code> 但是test文件夹没有创建，那么<code>-p</code>会帮助创建一个test的文件夹，然后再创建work文件夹</li>
<li>此图第一个d表示这是一个文件夹，后面的与<strong>权限</strong>有关</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/rC72GPEdxv38otU.png" alt="003_文件操作命令_01.png"></p>
<h3 id="touch命令">touch命令</h3>
<p>功能：创建文件，注意要<strong>添加后缀</strong></p>
<p>语法：<code>touch 参数</code> 参数：被创建的文件路径</p>
<h3 id="cat命令">cat命令</h3>
<p>功能：查看文件内容</p>
<p>语法：<code>cat 参数</code> 参数：被查看的文件路径</p>
<p><img src="https://s2.loli.net/2024/11/26/h8ZQkoU4KqxFrMR.png" alt="003_文件操作命令_02.png"></p>
<h3 id="more命令">more命令</h3>
<p>功能：查看文件，可以支持翻页查看</p>
<p>语法：<code>more 参数</code> 参数：被查看的文件路径</p>
<p>在查看过程中：按<strong>空格键翻页</strong> <code>q</code>退出查看 读者可以试试<code>more /etc/services</code> etc(法语et cetera,表示<strong>以及其他内容</strong>)</p>
<h3 id="cp命令">cp命令</h3>
<p>copy</p>
<p>功能：复制文件、文件夹</p>
<p>语法：<code>cp [-r] 参数1 参数2</code></p>
<ul>
<li>参数1，被复制的</li>
<li>参数2，要复制去的地方</li>
<li>选项：-r，可选,本意为<strong>递归</strong>(recursion),Linux中能<strong>递归的就是文件夹</strong>了，复制文件夹使用</li>
</ul>
<p>示例：cp a.txt test/，复制当前目录a.txt到test文件夹内</p>
<p><img src="https://s2.loli.net/2024/11/26/khIsrqxdXJYmwgH.png" alt="003_文件操作命令_03.png"></p>
<h3 id="mv命令">mv命令</h3>
<p>move</p>
<p>功能：移动文件、文件夹</p>
<p>语法：<code>mv 参数1 参数2</code></p>
<ul>
<li>参数1：被移动的</li>
<li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li>
</ul>
<h3 id="rm命令">rm命令</h3>
<p>remove</p>
<p>功能：删除文件、文件夹</p>
<p>语法：<code>rm [-r -f] 参数1 ...参数N</code></p>
<ul>
<li>参数：支持多个，每一个表示被删除的，空格进行分隔</li>
<li>选项：-r，删除文件夹使用</li>
<li>选项：-f，强制删除(force)，不会给出确认提示，一般root用户会用到,rm命令很危险，小心使用，最好留下快照</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/2JUPFtE4ISlRM5i.png" alt="003_文件操作命令_04.png"></p>
<p><strong>通配符</strong></p>
<p>符号*表示通配符，<br>
即匹配任意内容（包含空），示例：</p>
<ul>
<li>test*,表示匹配任何以test开头的内容</li>
<li>*test,表示匹配任何以test结尾的内容</li>
<li>*test*,表示匹配任何包含test的内容</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/h16uMsfSqGk9o5r.png" alt="003_文件操作命令_05.png"></p>
<h2 id="查找命令">查找命令</h2>
<h3 id="which命令">which命令</h3>
<p>功能：查看命令的程序本体文件<strong>路径</strong></p>
<p>语法：<code>which 参数</code> 参数：被查看的命令  比如<code>which cd</code> 返回的是/usr/bin/cd</p>
<h3 id="find命令">find命令</h3>
<p>功能：搜索文件</p>
<p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p>
<ul>
<li>路径，搜索的起始路径</li>
<li>参数，搜索的关键字，同理支持通配符</li>
<li>按文件大小查找命令：<code>find 起始路径 -size +|-n[KMG]</code>  ±表示大于和小于，n表示数字，KMG表示大小单位。如<code>find / -size -10k</code></li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/vHkjMrWmg8eY62T.png" alt="004_文件查找命令_01.png"></p>
<h2 id="grep、wc和管道符">grep、wc和管道符</h2>
<h3 id="grep命令">grep命令</h3>
<p>功能：过滤关键字，就是搜索关键字，将关键字所在的行展示并标记为红色。</p>
<p>语法：<code>grep [-n] 关键字 文件路径</code></p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号。</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为<strong>内容输入端口(就是|)</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/ki4l2UDp1Cx7Xrt.png" alt="005_过滤命令_01.png"></p>
<h3 id="wc命令">wc命令</h3>
<p>功能：统计</p>
<p>语法：<code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li>选项，-c，统计bytes数量</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行(line)数</li>
<li>选项，-w，统计单词(word)数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/Af7culsIYgEryBz.png" alt="005_过滤命令_02.png"></p>
<p>从左到右分别是行数、单词数、字符数、字节数.</p>
<h3 id="管道符">管道符|</h3>
<p>写法：<code>|</code></p>
<p>功能：<strong>将符号左边的结果，作为符号右边的输入</strong></p>
<p>示例：<code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p>
<p>可以支持嵌套：<code>cat a.txt | grep itheima | grep itcast</code> 还比如<code>ls -l /usr/bin | wc -l</code>表示展示bin文件夹内有多少个文件</p>
<p><img src="https://s2.loli.net/2024/11/26/QfDMwOpiykCdcg3.png" alt="005_过滤命令_03.png"></p>
<h2 id="echo、tail和重定向符">echo、tail和重定向符</h2>
<h3 id="echo命令">echo命令</h3>
<p>功能：输出内容</p>
<p>语法：<code>echo 参数</code> 参数：被输出的内容 比如<code>echo &quot;hello world!&quot;</code> 输出内容就是hello world！</p>
<h3 id="反引号">`反引号</h3>
<p>功能：被两个反引号包围的内容，会作为命令执行</p>
<p>示例： echo `pwd`，会输出当前工作目录</p>
<h3 id="重定向符">重定向符</h3>
<p>功能：将符号左边的结果，输出到右边指定的文件中去</p>
<ul>
<li><code>&gt;</code>，表示覆盖输出</li>
<li><code>&gt;&gt;</code>，表示追加输出</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/dxmLvrVRMj9y6T2.png" alt="006_命令_01.png"></p>
<h3 id="tail命令">tail命令</h3>
<p>功能：查看文件尾部内容，就是跟踪文件的最新更改。</p>
<p>语法：<code>tail [-f -num] 参数</code></p>
<ul>
<li>参数：被查看的文件</li>
<li>选项：-f，持续跟踪文件修改。使用两个会话，一个负责修改，一个负责删除，效果会更加明显。</li>
<li>num表示查看尾部多少行 示例<code>tail -f -10 test.txt</code> 表示从后往前查看test.txt文件内容10行，</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/gEpJPxZ75VorBm6.png" alt="006_命令_02.png"></p>
<h3 id="head命令">head命令</h3>
<p>功能：查看文件头部内容</p>
<p>语法：<code>head [-n] 参数</code></p>
<ul>
<li>参数：被查看的文件</li>
<li>选项：-n，查看的行数,不写相当于cat命令</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/5nodCKDBQtxZkRa.png" alt="006_命令_03.png"></p>
<hr>
<h2 id="vi编辑器">vi编辑器</h2>
<p>vim(visual interface,就是文本编辑器)是vi的加强版本，兼容ⅵ的所有指令，不仅能编辑文本，而且还具有shell程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p>
<p>vi\vim工作模式</p>
<ul>
<li>命令模式(Command mode)：所敲的按键编辑器都理解为命令，此时不能自由进行文本编辑</li>
<li>输入模式(Insert mode)：编辑模式,可以对文件内容进行自由编辑</li>
<li>底线命令模式(Last line mode):以<code>:</code>开始，通常用于文件的保存和退出</li>
</ul>
<p>示意图</p>
<p><img src="https://s2.loli.net/2024/11/26/3Nh2FL7tEqaWlOV.png" alt="007_vim编辑器_01.png"></p>
<p>语法：<code>vim 文件路径</code> 没有就会创建</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令模式(按键都是命令)</td>
<td>i</td>
<td>在当前光标位置进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>a</td>
<td>在当前光标位置之后进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>I</td>
<td>在当前行的开头，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>A</td>
<td>在当前行的结尾，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>o</td>
<td>在当前光标下一行进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>O</td>
<td>在当前光标上一行进入输入模式</td>
</tr>
<tr>
<td>输入模式(编辑模式)</td>
<td>esc</td>
<td>任何情况下输入esc都能回到命令模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>键盘上、键盘k</td>
<td>向上移动光标(以行为单位)</td>
</tr>
<tr>
<td>命令模式</td>
<td>键盘下、键盘j</td>
<td>向下移动光标(以行为单位)</td>
</tr>
<tr>
<td>命令模式</td>
<td>键盘左、键盆h</td>
<td>向左移动光标</td>
</tr>
<tr>
<td>命令模式</td>
<td>键盘右、键盘1</td>
<td>向后移动光标</td>
</tr>
<tr>
<td>命令模式</td>
<td>0</td>
<td>移动光标到当前行的开头</td>
</tr>
<tr>
<td>命令模式</td>
<td>$</td>
<td>移动光标到当前行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>pageup(PgUp)</td>
<td>向上翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>pangdown(PgDn)</td>
<td>向下翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>/</td>
<td><strong>进入搜索模式</strong></td>
</tr>
<tr>
<td>命令模式</td>
<td>n</td>
<td>向下继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>N</td>
<td>向上继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>dd</td>
<td>删除光标所在行的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td>ndd</td>
<td>n是数字，表示删除当前光标向下n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>命令模式</td>
<td>nyy</td>
<td>n是数字，复制当前行和下面的n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>p</td>
<td><strong>粘贴复制的内容</strong></td>
</tr>
<tr>
<td>命令模式</td>
<td>u</td>
<td><strong>撤销修改</strong></td>
</tr>
<tr>
<td>命令模式</td>
<td>ctrl+r</td>
<td>反向撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td>gg</td>
<td>跳到首行</td>
</tr>
<tr>
<td>命令模式</td>
<td>G</td>
<td>跳到行尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>dG</td>
<td>从当前行开始，向下全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>dgg</td>
<td>从当前行开始，向上全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>d$</td>
<td>从当前光标开始，删除到本行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>d0</td>
<td>从当前光标开始，删除到本行的开头</td>
</tr>
<tr>
<td>底线命令模式(涉及文件的退出与保存)</td>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q</td>
<td>仅退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:w</td>
<td>仅保存</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set nonu</td>
<td>取消显示行号</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set paste</td>
<td>设置粘贴模式</td>
</tr>
</tbody>
</table>
<h2 id="帮助手册">帮助手册</h2>
<p>如果想要对命令的其它选项进行查阅，可以通过如下方式</p>
<p>语法：<code>命令 --help</code></p>
<p>示例：如图列出ls命令的帮助文档。就是不怎么好用ㅍ_ㅍ</p>
<p><img src="https://s2.loli.net/2024/11/26/tG45neUQlfsiABY.png" alt="008_帮助手册_01.png"></p>
<p>如果要查看命令的详细手册，可以通过<code>man 命令</code>查看(man &lt;- manual)</p>
<p>一般下载的Centos默认是英文(不过我的设置成中文＜（＾－＾）＞).如果阅读吃力，可以通过重定向符：man ls &gt; ls-man.txt，输出手册到文件然后通过翻译软件翻译内容查看</p>
<h1>Linux用户与权限</h1>
<p>Linux采用多用户的管理模式进行权限管理，而拥有<strong>最大权限的账户名为root</strong>;而普通用户的权限，一般在其HOME目录内是不受限的，出了HOME目录，一般普通用户仅有只读和执行权限，无修改权限。</p>
<p><img src="https://s2.loli.net/2024/11/26/tl1V9TrCE2wsPGm.png" alt="009_用户与权限_01.png"></p>
<p>切换用户命令：<code>su [-] [用户名]</code>  或者ctrl+d退回到上一个用户</p>
<p>为了避免长期使用root导致系统损坏，可以使用<code>sudo</code>命令为普通的命令授权。</p>
<p>语法：<code>sudo 其他命令</code> 需要为普通用户配置sudo认证。</p>
<p>未认证的情况</p>
<p><img src="https://s2.loli.net/2024/11/26/Pd1KLFrSDhfvVpG.png" alt="009_用户与权限_02.png"></p>
<p><strong>sudo认证方法</strong></p>
<ol>
<li>
<p>切换到root用户，在命令行中输入<code>visudo</code>命令，打开/etc/sudoers</p>
</li>
<li>
<p>文件最后(命令模式按G到文件末尾)添加<code>用户名 ALL=(ALL)   NOPASSWD:ALL</code> 最后退出并保存</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/CHepjnVKaGEbJmL.png" alt="009_用户与权限_03.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/7jnOQrLTe8m4ayf.png" alt="009_用户与权限_04.png"></p>
<h3 id="用户管理">用户管理</h3>
<p><strong>用户与用户组</strong></p>
<p>不同的用户可以加入多个组中，用组来管理用户。</p>
<p>创建用户组：<code>groupadd 用户组名</code> 删除用户组: <code>groupdel 用户组名</code></p>
<p>查看用户组：<code>getend group</code></p>
<ul>
<li>
<p>创建用户<br>
<code>useradd [-g-d] 用户名</code>:-g指定用户的组，不指定-g,会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g;-d指定用户HOME路径，不指定，HOME目录默认在：/home/用户名</p>
</li>
<li>
<p>删除用户<br>
<code>userdel [-r] 用户名</code> :-r，删除用户的HOME目录。不使用-r删除用户时，HOME目录保留</p>
</li>
<li>
<p>查看用户所属组<br>
<code>id [用户名]</code>：被查看的用户，如果不提供则查看自身</p>
</li>
<li>
<p>修改用户所属组<br>
<code>usermod -aG 用户组 用户名</code>： ，将指定用户加入指定用户组</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/k5OTNnxlaDIErQP.png" alt="009_用户与权限_06.png"></p>
<p>可以看到jerry有两个组，一个是和自己同名的组，一个是之后创建并添加的组。</p>
<ul>
<li>
<p>查看系统中的用户：<code>getent passwd</code></p>
<p><img src="https://s2.loli.net/2024/11/26/Q7FN6qiXzvDYZrT.png" alt="009_用户与权限_05.png"></p>
<p>信息格式为：用户名：密码(X):用户ID:组ID:描述信息（无用）：HOME目录：执行终端(默认bash）可以使用<code>getent group</code>查看系统中有哪些组</p>
</li>
<li>
<p>查看系统所有变量： <code>env</code>.</p>
</li>
</ul>
<h3 id="权限信息">权限信息</h3>
<p>如图所示</p>
<p><img src="https://s2.loli.net/2024/11/26/wSXPx1LIU36fF5d.png" alt="009_用户与权限_07.png"></p>
<p>序号1表示文件和文件夹的权限控制信息，序号2中的两个分别表示文件和文件夹所属的<strong>用户</strong>和<strong>用户组</strong>。</p>
<p>权限讲解如下图</p>
<p><img src="https://s2.loli.net/2024/11/26/udHDhpZJa1qSw3l.png" alt="009_用户与权限_08.png"></p>
<p>r\w\x分别代表可读、可写(增删改等)、可执行(可以cd进入)。</p>
<h3 id="chmod命令">chmod命令</h3>
<p>语法：<code>chmod [-R] 权限 参数</code></p>
<p>权限：比如755，表示：<code>rwxr-x--x</code> 示例<code>chmod</code></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>无任何权限，即–</td>
</tr>
<tr>
<td>1</td>
<td>仅有x权限，即–x</td>
</tr>
<tr>
<td>2</td>
<td>仅有w权限，即-w-</td>
</tr>
<tr>
<td>3</td>
<td>有w和x权限，即-wx</td>
</tr>
<tr>
<td>4</td>
<td>仅有r权限，即r–</td>
</tr>
<tr>
<td>5</td>
<td>有r和x权限，即r-x</td>
</tr>
<tr>
<td>6</td>
<td>有r和w权限，即rw-</td>
</tr>
<tr>
<td>7</td>
<td>有全部权限，即rwx</td>
</tr>
</tbody>
</table>
<p>参数：被修改的文件和文件夹</p>
<p>-R:设置文件夹和其内容全部一样生效。</p>
<p>示例：<code>chmod u=rwx,g=rx,o=x hello.txt</code> 将文件的权限修改为<code>rwxr-x--x</code> u表示user的权限，g表示组的权限，o表示其他(other)的权限</p>
<p><img src="https://s2.loli.net/2024/11/26/UG89rT456RCVYdt.png" alt="009_用户与权限_09.png"></p>
<h3 id="chown命令">chown命令</h3>
<blockquote>
<p>此命令只适用于root用户使用</p>
</blockquote>
<p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p>
<p>示例:<code>chown jerry:emp hello.txt</code>  将hello.txt所属的用户修改为jerry,用户组改为emp</p>
<p><img src="https://s2.loli.net/2024/11/26/iLYpb9XKo4ePIJc.png" alt="009_用户与权限_10.png"></p>
<h1>Linux实用操作</h1>
<h2 id="快捷键技巧">快捷键技巧</h2>
<p><code>ctrl+c</code>:强制停止命令运行，或者是退出当前命令的输入</p>
<p><code>ctrl+d</code>:退出账户,或者是某些页面</p>
<p><code>ctrl+l</code>:清屏</p>
<p>键盘上下键：查看历史命令，同样可以用<code>history</code>，可以通过!命令前缀自动执行上一次匹配前缀的命令，比如<code>!grep</code></p>
<p><code>ctrl+r</code>:输入内容匹配历史命令，是就回车；左右键得到此命令</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ctrl+c</td>
<td>强制停止命令运行，或者是退出当前命令的输入</td>
</tr>
<tr>
<td>ctrl+d</td>
<td>退出账户,或者是某些页面</td>
</tr>
<tr>
<td>ctrl+l</td>
<td>清屏</td>
</tr>
<tr>
<td>键盘上下键</td>
<td>查看历史命令，同样可以用<code>history</code>，可以通过!命令前缀自动执行上一次匹配前缀的命令，比如<code>!grep</code></td>
</tr>
<tr>
<td>ctrl+r</td>
<td>输入内容匹配历史命令，是就回车；左右键得到此命令</td>
</tr>
<tr>
<td>ctrl+a</td>
<td>跳到命令开头</td>
</tr>
<tr>
<td>ctrl+e</td>
<td>跳到命令结尾</td>
</tr>
<tr>
<td>ctrl+左键</td>
<td>向左跳一个单词</td>
</tr>
<tr>
<td>ctrl+右键</td>
<td>向右跳一个单词</td>
</tr>
</tbody>
</table>
<h2 id="安装软件">安装软件</h2>
<p>有两种方式，一种是自行下载安装包，另一种是在系统的“应用商店”内下载安装。</p>
<p>yum.RPM包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题</p>
<p>在Centos中安装。</p>
<ul>
<li><code>yum [install remove search] [-y] 软件名称</code>；install 安装；remove 卸载；search 搜索；-y，自动确认。常见的格式有.exe .pkg .rpm等。注意yum需要root权限且需要联网</li>
</ul>
<blockquote>
<p>由于Centos7在24年6月不再更新，需要自行配置yum源。方法请自行Google。</p>
</blockquote>
<p>在Ubuntu系统使用“应用商店”——apt管理器。</p>
<ul>
<li><code>apt [install remove search] [-y] 软件名称</code>；install 安装；remove 卸载；search 搜索；-y，自动确认。常见的格式有 .deb等。同样需要root权限且要联网。</li>
</ul>
<h2 id="系统命令">系统命令</h2>
<h3 id="systemctl">systemctl</h3>
<p>功能：控制系统服务的启动关闭等，常用于防火墙等的开闭</p>
<p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p>
<p>常见的服务有NetworkManager,主网络服务;network,副网络服务;firewalld,防火墙服务;sshd,ssh服务(远程登录Linux使用的就是这个服务)</p>
<p>start，启动|stop，停止|status，查看状态|disable，关闭开机自启|enable，开启开机自启|restart，重启</p>
<p><img src="https://s2.loli.net/2024/11/26/9ZPWiyB72LVJ4nv.png" alt="010_系统命令_01.png"></p>
<h3 id="软链接">软链接</h3>
<p>功能：创建文件、文件夹软链接（快捷方式）</p>
<p>语法：<code>ln -s 参数1 参数2</code>；参数1：被链接的；参数2：要链接去的地方（快捷方式的名称和存放位置）</p>
<p><img src="https://s2.loli.net/2024/11/26/PCtAJm78h2lnEjD.png" alt="010_系统命令_02.png"></p>
<p>图中红色方框部分就是软链接.</p>
<h3 id="日期及其计算">日期及其计算</h3>
<p>语法：<code>date [-d] [+格式化字符串]</code></p>
<ul>
<li>
<p>-d 按照给定的字符串显示日期，一般用于日期计算</p>
</li>
<li>
<p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p>
<ul>
<li>
<p>%Y   年%y   年份后两位数字 (00…99)</p>
</li>
<li>
<p>%m   月份 (01…12)</p>
</li>
<li>
<p>%d   日 (01…31)</p>
</li>
<li>
<p>%H   小时 (00…23)</p>
</li>
<li>
<p>%M   分钟 (00…59)</p>
</li>
<li>
<p>%S   秒 (00…60)</p>
</li>
<li>
<p>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</p>
</li>
</ul>
</li>
</ul>
<p>示例<code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 以2022-01–01 00:00:00 展示时间</p>
<p><img src="https://s2.loli.net/2024/11/26/3PBiesFClJNHcoA.png" alt="010_系统命令_03.png"></p>
<p><strong>计算</strong> 示例<code>date -d &quot;+1 [时间标记]&quot; +%Y%m%d</code> 如果时间标记是day ,则显示后一天的日期;如果时间标记是year，则表示后一年的日期。<code>-</code>表示显示前一天；支持的时间标记为:year\month\day\hour\minutes\second.</p>
<p><strong>修改</strong>：修改时区为中国时区.</p>
<p>原理：将系统自带的localtime文件删除，并将/usr/share/zoneinfo/Asia/Shanghai文件链接为localtime文件即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f /etc/localtime</span><br><span class="line">sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>
<p><strong>同步</strong>：同步时间</p>
<p>安装：<code>yum install -y ntp</code></p>
<p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p>
<h2 id="IP与主机">IP与主机</h2>
<p>此部分内容与计算机网络密切相关，建议读者学习和掌握计算机网络相关知识，以下内容会更易理解。</p>
<h3 id="ip地址">ip地址</h3>
<p>IPv4格式：a.b.c.d。abcd为0~255的数字，比如192.168.88.102</p>
<p>特殊IP：127.0.0.1，代指本机 ；0.0.0.0：可以表示本机也可以表示任意IP(看使用场景)</p>
<p>查看ip：<code>ifconfig</code> <code>ens33：</code>中的inet就是IP，<code>lo:</code>本地回环的网卡 <code>virbr0</code>:虚拟机专用的网卡</p>
<h3 id="主机名">主机名</h3>
<p>功能：Linux系统的名称</p>
<p>查看：<code>hostname</code></p>
<p>设置：<code>hostnamectl set-hostname 主机名</code></p>
<p>扩展：<strong>域名解析</strong>：简单来说就是根据输入的域名(比如百度)自动分析出服务器对应的IP地址，然后再访问,而不是先记住IP再访问。也就是说IP与域名之间存在<strong>映射</strong>关系.</p>
<p><img src="https://s2.loli.net/2024/11/26/cO2PiaVDeMynRCN.png" alt="011_IP与主机_01.png"></p>
<h3 id="配置VMware固定IP">配置VMware固定IP</h3>
<p>原因：Linux操作系统，其IP地址是通过<strong>DHCP</strong>服务获取的。<strong>DHCP</strong>:动态获取IP地址，即每次重启设备后都会获取一次，可能导致IP地址频繁变更。这一部分在之前的“初识Linux”中的“Linux固定IP“中讲解过详细步骤，这里只是强调重点。</p>
<p>核心步骤如下：</p>
<p>修改文件：<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p>示例文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;			# 改为static，固定IP</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=&quot;192.168.88.131&quot;		# IP地址，自己设置，要匹配网络范围</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;		# 子网掩码，固定写法255.255.255.0</span><br><span class="line">GATEWAY=&quot;192.168.88.2&quot;		# 网关，要和VMware中虚拟网络编辑器中的配置一致</span><br><span class="line">DNS1=&quot;192.168.88.2&quot;			# DNS1服务器，和网关一致即可</span><br></pre></td></tr></table></figure>
<h2 id="网络传输">网络传输</h2>
<h3 id="ping命令">ping命令</h3>
<p>测试网络是否联通</p>
<p>语法：ping [-c num] 参数：-c,检查的次数，不使用-c选项，将无限次数持续检查;ip或主机名，被检查的服务器的ip地址或主机名地址 示例<code>ping -c 3 www.baidu.com</code></p>
<p><img src="https://s2.loli.net/2024/11/26/zNv1YklJrU67d8n.png" alt="012_网络传输_01.png"></p>
<h3 id="wget命令">wget命令</h3>
<p>wgt是非交互式的文件下载器，可以在命令行内下载网络文件<br>
语法：<code>wget [-b] url</code>选项：-b,可选，后台下载，会将日志写入到当前工作目录的wget-log文件;urL,下载链接<br>
示例：<code>wget -b http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/hadoop-3.3.0.tar.gz</code> 监视后台下载进度 :<code>tail -f wget-log</code></p>
<h3 id="curl命令">curl命令</h3>
<p>curl可以发送http网络请求，可用于：下载文件、获取信息等,本质和浏览器访问网页是一样的<br>
语法：<code>curl [-O] ur1</code><br>
选项：-O,用于下载文件，当url是下载链接时，可以使用此选项保存文件<br>
参数：url,要发起请求的网络地址</p>
<p>示例:<code>curl -O http://archive.apache.org/dist/hadoop/common/hadoop- 3.3.0/hadoop-3.3.0.tar.gz</code></p>
<h3 id="端口">端口</h3>
<p>计算机程序之间的通讯，通过IP只能锁定计算机，而端口是更加精确的“地址”，能够锁定计算机上具体的程序，便于程序之间的沟通。</p>
<p>Linux的端口分类如下</p>
<ul>
<li>公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口</li>
<li><strong>注册端口</strong>：1024~49151，通常可以随意使用，用于松散的绑定一些程序\服务。</li>
<li>动态端口：49152~65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/nAf3gcTG9sJKXVb.png" alt="012_网络传输_02.png"></p>
<h3 id="nmap命令">nmap命令</h3>
<p>查看端口占用情况</p>
<blockquote>
<p>由于Centos停止更新，镜像源波动大，其网络下载困难较大。</p>
</blockquote>
<p>下载：<code>yum -y install nmap</code></p>
<p>语法：<code>nmap 被查看的IP地址</code></p>
<p>或者也可以使用<code>netstat</code>命令查看端口的占用情况</p>
<p>语法：<code>netstat -anp | grep 端口号</code> ,需要实现安装netstat</p>
<h2 id="进程">进程</h2>
<p>操作系统为管理运行的程序，每一个程序在运行的时候，就会被操作系统注册为系统中的一个进程，并且会为每一个进程都分配一个独有的进程ID(PID)。</p>
<h3 id="ps命令">ps命令</h3>
<p>功能：查看进程信息</p>
<p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p>
<p>示例如下图</p>
<p><img src="https://s2.loli.net/2024/11/26/ACGYa6mJMNsoyv7.png" alt="013_进程_01.png"></p>
<p>从左到右分别是：UID是指进程所属的用户ID|PID：进程的进程号ID|PPID:进程的父ID(启动此进程的其它进程）|C:此进程的CPU占用率（百分比）|STIME:进程的启动时间|TTY:启动此进程的终端序号，如显示？，表示非终端启动|TIME :进程占用cpu的时间|CMD：进程的启动路径或者命令。</p>
<h3 id="kill命令">kill命令</h3>
<p>语法：<code>kill [-9] 进程ID</code> -9表示强制关闭进程，进程ID可以通过ps和管道符命令实现</p>
<p><img src="https://s2.loli.net/2024/11/26/xiF2dqn6Mm1G9wz.png" alt="013_进程_02.png"></p>
<h2 id="主机状态">主机状态</h2>
<h3 id="top命令">top命令</h3>
<p>功能：查看主机运行状态。 相当于任务管理器</p>
<p>语法：<code>top</code>，查看基础信息，按<code>q</code>退出</p>
<p>示意图如下</p>
<p><img src="https://s2.loli.net/2024/11/26/F45XC1OepbRAjrx.png" alt="014_主机状态_01.png"></p>
<p>解释：</p>
<ul>
<li>第一行：top:命令名称，08:31:30：当前系统时间，up 38 min:启动了38分钟，1 users:1个用户登录，load average:1、5、15分钟负载</li>
<li>第二行：Tasks:244个进程，1 running:1个进程子在运行，243 sleeping:243个进程睡眠，0个停止进程，0个僵尸进程</li>
<li>第三行：%Cpu(s):CPU使用率，us:用户CPU使用率，sy:系统CPU使用率，ni:高优先级进程占用CPU时间百分比，id:空闲CPU率，wa:IO等待CPU占用率，hi:CPU硬件中断率，Si:CPU软件中断率，st:强制等待占用CPU率</li>
<li>第四、五行：Kib Mem:物理内存，total:总量，free:空闲，used:使用，buff/cache:buff和cache占用，KibSwap:虚拟内存（交换空间），total:总量，free:空闲，used:使用，buff/cache:buff和cache占用</li>
</ul>
<p>表格解释</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程ID</td>
</tr>
<tr>
<td>USER</td>
<td>进程所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>进程优先级，越小越高</td>
</tr>
<tr>
<td>NI</td>
<td>负值表示高优先级，正表示低优先级</td>
</tr>
<tr>
<td>VIRT</td>
<td>进程使用虚拟内存，单位KB</td>
</tr>
<tr>
<td>RES</td>
<td>进程使用物理内存，单位KB</td>
</tr>
<tr>
<td>SHR</td>
<td>进程使用共享内存，单位KB</td>
</tr>
<tr>
<td>S</td>
<td>进程状态(S休眠，R运行，Z僵死状态，N负数优先级，I空闲状态)</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用CPU率</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程占用内存率</td>
</tr>
<tr>
<td>TIME+</td>
<td>进程使用CPU时间统计，单位10毫秒</td>
</tr>
<tr>
<td>COMMAND</td>
<td>进程的命令或者名称或程序文件路径</td>
</tr>
</tbody>
</table>
<p>可用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>只显示某个进程的信息</td>
</tr>
<tr>
<td>-d</td>
<td>设置刷新时间，默认是5s</td>
</tr>
<tr>
<td>-c</td>
<td>显示产生进程的完整命令，默认是进程名</td>
</tr>
<tr>
<td>-n</td>
<td>指定刷新次数，能如top -n 3,刷新输出3次后退出</td>
</tr>
<tr>
<td>-b</td>
<td>以非交互非全屏模式运行，以批次的方式执行top,一般配合-n指定输出几次统计信息，将输出重定向到指定文件，比如<code>top -b -n 3 &gt; /tmp/top.tmp</code></td>
</tr>
<tr>
<td>-i</td>
<td>不显示任何闲置(idle)或无用(zombie)的进程</td>
</tr>
<tr>
<td>-u</td>
<td>查找特定用户启动的进程</td>
</tr>
</tbody>
</table>
<p>top的交互式选项</p>
<p>可以看如下黑马程序员的ppt图</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221354.png" alt="image-20221027221354137"></p>
<h3 id="df命令">df命令</h3>
<p>查看磁盘占用</p>
<p>语法：<code>df [-h]</code></p>
<p><img src="https://s2.loli.net/2024/11/26/d3uNpVbgrx4cWJS.png" alt="014_主机状态_02.png"></p>
<p>还有iostat命令</p>
<p>语法:<code>iostat [-x] [num1] [num2]</code> -x，显示更多信息;num1：数字，刷新间隔，num2：数字，刷新几次</p>
<p><img src="https://s2.loli.net/2024/11/26/oIstSuHzTYJR9OU.png" alt="014_主机状态_03.png"></p>
<p>具体更多信息看图</p>
<p><img src="https://s2.loli.net/2024/11/26/nx7sgDH2KvNU5rJ.png" alt="014_主机状态_04.png"></p>
<h3 id="网络监控">网络监控</h3>
<p>语法:<code>sar -n DEV num1 num2</code> -n表示查看网络，DEV表示查看网络接口。num1是刷新间隔(不填就查看一次结束)，num2是查看次数(不填无限次数)。</p>
<p><img src="https://s2.loli.net/2024/11/26/LaeOGzDKVkgxnMd.png" alt="014_主机状态_05.png"></p>
<h2 id="环境变量">环境变量</h2>
<p>环境变量是操作系统(Windows、Linux、Mac)在运行的时候，记录的一些关键性信息，用以辅助系统运行。比如说要执行cd命令，系统就在PATH环境变量里面的路径找cd的程序(因为cd命令的本体就是：/usr/bin/cd 这个程序文件)，找不到的时候再从当前路径开始查找。配置过<strong>Java</strong>的同学应该有体会。</p>
<p>查看环境变量：<code>env</code></p>
<ul>
<li>临时设置：export 变量名=变量值 ，变量值一般是路径，比如<code>export PATH=$PATH:/home/itheima/myenv</code> 将myenv临时添加到环境变量中</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/owqTVdjlNX2agiu.png" alt="015_环境变量_01.png"></p>
<ul>
<li>永久设置：
<ul>
<li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li>
<li>针对全局，设置<code>/etc/profile</code></li>
</ul>
</li>
</ul>
<p>并通过语法source配置文件进行立刻生效</p>
<h3 id="PATH变量">PATH变量</h3>
<p>记录了执行程序的搜索路径,可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p>
<p><img src="https://s2.loli.net/2024/11/26/nSWo8sEhaUz1xHL.png" alt="015_环境变量_02.png"></p>
<h3 id="符号">$符号</h3>
<p>可以取出指定的环境变量的值</p>
<p>语法：<code>$变量名</code></p>
<p>示例：</p>
<p><code>echo $PATH</code>，输出PATH环境变量的值</p>
<p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p>
<p>如果变量名和其它内容混淆在一起，可以使用${}</p>
<h2 id="压缩与解压">压缩与解压</h2>
<h3 id="文件上传与下载">文件上传与下载</h3>
<p>可以安装<a href="https://www.xshell.com/zh/">xfcp软件</a>进行文件上传，方法和Xshell大同小异。</p>
<p>在Linux中常见的压缩格式为tar、grip和zip格式。</p>
<h3 id="tar命令">tar命令</h3>
<p><code>tar [-c -v -x -f -z -C] 参数1 参数2 ... 参数N </code></p>
<ul>
<li>-z表示使用gzip(.gz)，不写就是.tar格式</li>
<li>-v显示压缩和解压过程，用于查看进度</li>
<li>-c创建压缩文件、用于压缩模式</li>
<li>-x解压模式</li>
<li>-f要创建的文件或者要解压的文件，必须在所有选项中的最后一个</li>
<li>-C：要单独使用，与其他参数隔开。选择解压的目的地，用于解压模式</li>
</ul>
<p>示例：压缩<code>tar -zcvf test.tar.gz 1.txt 2.txt</code> 将两个txt文件压缩到test.tar.gz内。使用gzip模式。解压：<code>tar -zxvf test.tar.gz -C /home/Tom</code> 将.gz文件解压到指定目录</p>
<h3 id="zip命令与unzip命令">zip命令与unzip命令</h3>
<p>语法：<code>zip [-r] 参数1 参数2 参数N</code> -r，被压缩的包含文件夹时，需要使用-r，也就是里面的东西都压缩进来。</p>
<p>示例：<code>zip -r test.zip a b.txt c.txt</code> 将后面两个txt文件和a文件夹压缩到test.zip文件内。</p>
<p>语法：<code>unzip [-d] 参数</code> -d指定要解压的位置，参数是被解压的zip压缩包文件。</p>
<h2 id="后续学习">后续学习</h2>
<p>读者在学习完Linux基础之后根据自己的需求学习如何在Linux中安装对应的软件(比如mysql、IDEA等)。可以参考黑马程序员的资料</p>
<h1>参考</h1>
<p><strong>软件资源</strong></p>
<ol>
<li>Xshell：<a href="https://www.xshell.com/zh/free-for-home-school/">家庭/学校免费 - NetSarang Website (xshell.com)</a></li>
<li>Linux相关发行版：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos-vault/">清华大学开源软件镜像站</a></li>
<li>vmware station:<a href="https://partnerportal.broadcom.com/">博通</a></li>
</ol>
<p><strong>参考视频和教程</strong></p>
<ol>
<li><a href="https://blog.csdn.net/weixin_74195551/article/details/127288338">安装虚拟机（VMware）保姆级教程（附安装包）</a></li>
<li><a href="https://www.bilibili.com/video/BV1Sv411r7vd?vd_source=bb8dacb993f11c0e39f8147c98a2894c">【小白入门 通俗易懂】韩顺平 一周学会Linux</a> ,注意韩顺平老师的视频是2021年的，视频中有些网站已经失效，请自行Google或百度查找。</li>
<li><a href="https://www.bilibili.com/video/BV1n84y1i7td?p=3&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">黑马程序员新版Linux零基础快速入门到精通，全涵盖linux系统知识、常用软件环境部署、Shell脚本、云平台实践、大数据集群项目实战等</a></li>
</ol>
<p><strong>参考书籍和资料</strong></p>
<ol>
<li><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站</a> 这个是学Linux必备的，相比某度、CSDN更加简洁，但是如果要更加细节的解释可能还是要依靠CSDN或者Google等搜索引擎。</li>
<li>黑马程序员资料：<a href="https://yun.itheima.com/course/1013.html">Linux零基础快速入门到精通</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记(二)进阶篇</title>
    <url>/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>注：本篇博客大部分是黑马pdf中的内容，根据我自己学习的实际情况进行修改和补充。</p>
</blockquote>
<h1>准备工作</h1>
<ol>
<li>准备好虚拟机并安装好mysql</li>
</ol>
<h1>存储引擎</h1>
<p>概念：<strong>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式</strong> 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。</p>
<h2 id="MySQL体系结构">MySQL体系结构</h2>
<p>参考博客<a href="https://blog.csdn.net/qq_45938466/article/details/107941557">数据库工作原理</a></p>
<p><img src="https://s2.loli.net/2024/11/26/9XL8m1xhEAgzGFU.png" alt="100_演示图_01.png"></p>
<ol>
<li>连接层<br>
<strong>最上层</strong>是一些客户端和链接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了<strong>线程池</strong>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li>服务层<br>
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</li>
<li>引擎层<br>
存储引擎层， 存储引擎真正的<strong>负责了MySQL中数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</li>
<li>存储层<br>
数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</li>
</ol>
<h2 id="语法">语法</h2>
<ol>
<li>创建表时指定存储引擎</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [ COMMENT 字段<span class="number">1</span>注释 ] ,</span><br><span class="line">	......</span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎 [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- MySQL中默认的储存引擎为InnoDB</span></span><br><span class="line"><span class="comment">-- 示例 使用默认的存储引擎创建表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> account;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/8Vtqa1grxSKcBsT.png" alt="001_存储引擎_01.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表my_myisam,并指定MyISAM储存引擎</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> my_myisam(</span><br><span class="line">                          id <span class="type">int</span>,</span><br><span class="line">                          name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">) engine <span class="operator">=</span> MyISAM;</span><br><span class="line"><span class="comment">-- 以ibd为后缀的都是使用InnoDB引擎的表</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/EZjosleKiPkRVxM.png" alt="001_存储引擎_03.png"></p>
<ol start="2">
<li>查询当前数据库支持的存储引擎</li>
</ol>
<p>语法：<code>show engines;</code></p>
<p><img src="https://s2.loli.net/2024/11/26/1NiTYUDPLfIlKeG.png" alt="001_存储引擎_02.png"></p>
<p>可以看到&quot;engine&quot;这一行中InnoDB的&quot;Support&quot;字段为&quot;<strong>DEFAULT</strong>&quot;,也就是<strong>默认</strong>的意思。</p>
<h2 id="存储引擎的区别和特点">存储引擎的区别和特点</h2>
<p>重点讲解InnoDB，MyISAM和Memory存储引擎的特点</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">InnoDB</button><button type="button" class="tab">MyISAM</button><button type="button" class="tab">Memory</button></div><div class="tab-contents"><div class="tab-item-content active"><ol>
<li>介绍<br>
InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</li>
<li>特点<br>
DML操作遵循ACID模型，支持<strong>事务</strong>；<strong>行级锁</strong>，提高并发访问性能；支持<strong>外键</strong>FOREIGN KEY<strong>约束</strong>，保证数据的完整性和正确性；</li>
<li>文件<br>
xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。参数：innodb_file_per_table</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/hj7oSZl5rtq3KIR.png" alt="001_存储引擎_04.png"></p>
<p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的数据存放目录：C:\ProgramData\MySQL\MySQL Server 8.0\Data(<strong>按照你MySQL的安装路径修改</strong>)， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库.任意打开一个自建的文件夹，就会发现里面有许多后缀为.ibd的文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p>
<p><img src="https://s2.loli.net/2024/11/26/vI6j8VMYKPaJsQ9.png" alt="001_存储引擎_05.png"></p>
<ol start="4">
<li>逻辑存储结构</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/G6DotI1dn4kKCv2.png" alt="001_存储引擎_06.png"></p>
<ul>
<li>表空间(Tablespace): InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据</li>
<li>段(Segment): 表空间是由各个段组成的， 分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段<br>
（Rollback segment）  等,InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</li>
<li>区(Extent): 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li>
<li>页(Page): 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
<li>行(Row): InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段.一个是Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。；另一个是Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</li>
</ul></div><div class="tab-item-content"><ol>
<li>介绍<br>
MyISAM是MySQL早期的默认存储引擎。</li>
<li>特点<br>
不支持事务，不支持外键;支持表锁，不支持行锁;访问速度快</li>
<li>文件<br>
xxx.sdi：存储表结构信息；xxx.MYD: 存储数据；xxx.MYI: 存储索引</li>
</ol></div><div class="tab-item-content"><ol>
<li>介绍<br>
Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</li>
<li>特点<br>
内存存放；hash索引（默认）</li>
<li>文件<br>
xxx.sdi：存储表结构信息</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<blockquote>
<p>InnoDB引擎与MyISAM引擎的区别 ?<br>
①. InnoDB引擎, 支持事务, 而MyISAM不支持。<br>
②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。<br>
③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。</p>
<p>具体其他细节可以参考官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html">MySQL :: MySQL 8.0 Reference Manual :: 17.1 Introduction to InnoDB</a></p>
</blockquote>
<h2 id="存储引擎的选择">存储引擎的选择</h2>
<blockquote>
<p>很多情况下技术的选择都具有局限性和折中性，不存在完美的选择，只有相对好的选择。</p>
</blockquote>
<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ol>
<li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li>
<li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ol>
<h1>索引</h1>
<p>概念：索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。简单来说就是数据结构在数据库中的应用(＾－＾)。</p>
<p>有索引和无索引搜索时间比较</p>
<p><img src="https://s2.loli.net/2024/11/26/UC9EAFGZgMlhL5a.png" alt="002_存储索引_01.png"></p>
<p>在表中数据较少的时候相差不大，但如果是千万级别的数据，差距就尤其明显。这是因为在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为<strong>全表扫描</strong>，其性能很低。 如果我们针对于这张表建立了索引 (比如二叉树) ,查询时就会按照二叉树的索引进行查找，二叉树搜索和穷举法哪个时间复杂度更小，不用我多说了吧（￣︶￣）。</p>
<p>索引的<strong>优点</strong>在于<strong>提高</strong>数据检索的<strong>效率</strong>，降低数据库的IO成本；通过索引列对数据进行排序，降低数据排序的成本，<strong>降低CPU的消耗</strong>，其<strong>缺点</strong>是索引列也是要<strong>占用空间</strong>的；索引大大提高了查询效率，同时却也<strong>降低更新表的速度</strong>， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</p>
<h2 id="索引结构">索引结构</h2>
<p>不同的存储引擎支持的索引结构不同，主要包含以下几种。</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索 引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td>
</tr>
<tr>
<td>Full-text(全文 索引)</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td>
</tr>
</tbody>
</table>
<p>不同存储索引对索引结构的支持情况</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>不加说明默认所说的索引都是B+数结构组织的索引</p>
</blockquote>
<h3 id="二叉树">二叉树</h3>
<blockquote>
<p>以下内容涉及到数据结构，有数据结构基础的读者会更容易理解。</p>
</blockquote>
<p>缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢 。使用红黑树也会存在层级较深的问题。</p>
<h3 id="B-Tree与B-Tree">B-Tree与B+Tree</h3>
<p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针</p>
<p><img src="https://s2.loli.net/2024/11/26/lBwy7UXRN35sjch.png" alt="100_演示图_02.png"></p>
<p>读者可以通过此网站观看B树数据插入的方式和节点的变化。<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization</a> 就会发现</p>
<ul>
<li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li>
<li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li>
<li>在B树中，非叶子节点和叶子节点都会存放数据。</li>
</ul>
<p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图</p>
<p><img src="https://s2.loli.net/2024/11/26/5SQDnqfm8HbcEyr.png" alt="100_演示图_03.png"></p>
<p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。  这样看来B+树和B-树有以下区别</p>
<ul>
<li>所有的数据都会出现在叶子节点。</li>
<li>叶子节点形成一个单向链表。</li>
<li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li>
</ul>
<p>在MySQL中，对经典的B+Tree数据结构进行了优化，在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。如下图。</p>
<p><img src="https://s2.loli.net/2024/11/26/7ZJbL1KVn4f8tBG.png" alt="100_演示图_04.png"></p>
<h3 id="Hash">Hash</h3>
<p>概念：哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p>
<p><img src="https://s2.loli.net/2024/11/26/pXyItfc4lT2AQvR.png" alt="100_演示图_05.png"></p>
<p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>
<p><img src="https://s2.loli.net/2024/11/26/rO6wJW3sibhPHY1.png" alt="100_演示图_06.png"></p>
<p>特点</p>
<ul>
<li>Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</li>
<li>无法利用索引完成排序操作</li>
<li>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</li>
</ul>
<p>存储引擎支持<br>
在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下<strong>自动构建</strong>的。</p>
<h2 id="索引分类">索引分类</h2>
<p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键 索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建, 只能 有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一 索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规 索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文 索引</td>
<td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody>
</table>
<h3 id="聚集索引-二级索引">聚集索引&amp;二级索引</h3>
<p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td>
<td>必须有,而且只 有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody>
</table>
<p>聚集索引选取规则:</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引。</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li>
</ul>
<p>聚集索引和二级索引的具体结构如下：</p>
<p><img src="https://s2.loli.net/2024/11/26/ElsgkG3fOBTnoPV.png" alt="100_演示图_07.png"></p>
<p>聚集索引的叶子节点下挂的是这一行的数据 ,二级索引的叶子节点下挂的是该字段值对应的主键值.</p>
<p>其具体的查找过程如下</p>
<p><img src="https://s2.loli.net/2024/11/26/7X291gyBJqfj53e.png" alt="100_演示图_08.png"></p>
<ol>
<li>由于是根据name字段进行查询，所以先根据name='Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li>
<li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li>
<li>最终拿到这一行的数据，直接返回即可。</li>
</ol>
<p><strong>回表查询</strong>： 这种<strong>先到二级索引中查找数据</strong>，找到主键值，然后<strong>再到聚集索引中根据主键值</strong>，获取数据的方式，就称之为回表查询。 由此我们可以推断，<strong>聚集索引搜索比二级索引搜索效率要高</strong>。</p>
<p>计算题：计算InnoDB主键索引的B+Tree高度。</p>
<p>查看答案</p>
<div class="hide-block"><button type="button" class="hide-button" style>查看答案
    </button><div class="hide-content"><p>解：设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。<br>
当树的高度为2：n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170，得1171* 16 = 18736<br>
也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p>
</div></div>
<h2 id="索引语法">索引语法</h2>
<ol>
<li>查看索引</li>
</ol>
<p>语法：<code>show index from table_name;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 展示索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="comment">-- 在linux中输出结果表格断行，建议末尾加上\G,其他情况的表格断行也可以使用</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/4aPLT5uwqbXyEzn.png" alt="002_存储索引_02.png"></p>
<ol start="2">
<li>创建索引</li>
</ol>
<p>语法：<code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一般索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/tq8DZxeBIvc5FfL.png" alt="002_存储索引_03.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/m74j3DMpszYdy6S.png" alt="002_存储索引_04.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/EGKDjf1e2vgF8hq.png" alt="002_存储索引_05.png"></p>
<ol start="3">
<li>删除索引</li>
</ol>
<p>语法：<code>DROP INDEX index_name ON table_name</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br></pre></td></tr></table></figure>
<h2 id="SQL性能分析">SQL性能分析</h2>
<h3 id="SQL执行频率">SQL执行频率</h3>
<p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql执行频率</span></span><br><span class="line"><span class="comment">-- session 是查看当前会话</span></span><br><span class="line"><span class="comment">-- global 是查询全局数据</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/qerfIgZlNWaAnPD.png" alt="003_SQL性能分析_01.png"></p>
<p>这其中<code>Com_delete</code>是删除次数 <code>Com_insert</code>是插入次数 <code>Com_select</code>是查询次数 <code>Com_update</code>是更新次数</p>
<blockquote>
<p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了</p>
</blockquote>
<h3 id="慢查询日志">慢查询日志</h3>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>
MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variable <span class="keyword">like</span> &quot;slow_query_log&quot;</span><br><span class="line"><span class="comment">-- 结果为</span></span><br><span class="line"><span class="comment">-- +----------------+-------+</span></span><br><span class="line"><span class="comment">-- | Variable_name  | Value |</span></span><br><span class="line"><span class="comment">-- +----------------+-------+</span></span><br><span class="line"><span class="comment">-- | slow_query_log | OFF    |</span></span><br><span class="line"><span class="comment">-- +----------------+-------+</span></span><br></pre></td></tr></table></figure>
<p>在MySQL中慢查询默认关闭，如果要开启慢日志，需要先退出MySQL(<code>quit</code>)在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启MySQL慢日志查询开关</span></span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">-- 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/X7mtJbciK8aWDwR.png" alt="003_SQL性能分析_02.png"></p>
<p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 重启MySQL服务器</span><br><span class="line">systemctl restart mysqld</span><br><span class="line">-- 其慢查询文件放在cd /var/lib/mysql 下，文件名为localhost-slow.log(我这里是hspEdu01-slow.log)</span><br></pre></td></tr></table></figure>
<p>再次查询后就会发现OFF变成了ON</p>
<p>这样当以后查询的时间超过2秒的时候，就会视为慢查询，然后记录在慢查询日志里，如下</p>
<p><img src="https://s2.loli.net/2024/11/26/VN1bIeY58jE2Jl3.png" alt="003_SQL性能分析_04.png"></p>
<h3 id="profile">profile</h3>
<p><code>show profiles</code> 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看是否支持profile</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/w8oApP5kCujXniH.png" alt="003_SQL性能分析_05.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看profile是否开启</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line"><span class="comment">-- +-------------+</span></span><br><span class="line"><span class="comment">-- | @@profiling |</span></span><br><span class="line"><span class="comment">-- +-------------+</span></span><br><span class="line"><span class="comment">-- |           0 |</span></span><br><span class="line"><span class="comment">-- +-------------+</span></span><br></pre></td></tr></table></figure>
<p>可以看到MySQL支持profile操作但是没有开启,可以通过set语句在(session/global级别开启profiling)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启profile</span></span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>测试一下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 测试</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;白起&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles ;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/k8TcEnhs6tdRpeo.png" alt="003_SQL性能分析_06.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看指定ID的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">55</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/D27WAfRiap5zSy6.png" alt="003_SQL性能分析_07.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看指定ID的占用CPU的情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query <span class="number">92</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/8VhEsyrmHNwXKO1.png" alt="003_SQL性能分析_08.png"></p>
<h3 id="explain">explain</h3>
<p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 ;</span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="comment">-- 在语句前添加explain就行</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ES3yUGID4Jcd8iF.png" alt="003_SQL性能分析_09.png"></p>
<p>解释</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
</tbody>
</table>
<h2 id="索引使用">索引使用</h2>
<p>演示索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 演示</span></span><br><span class="line">explain <span class="keyword">select</span> s.<span class="operator">*</span>,c.<span class="operator">*</span> <span class="keyword">from</span> student s,course c,student_course sc <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/fcy6dRDePrOplZt.png" alt="003_SQL性能分析_10.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 嵌套语句的分析</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student s <span class="keyword">where</span> s.id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> studentid <span class="keyword">from</span> student_course sc <span class="keyword">where</span> sc.courseid <span class="operator">=</span> (</span><br><span class="line">        <span class="keyword">select</span> id <span class="keyword">from</span> course c <span class="keyword">where</span> c.name <span class="operator">=</span> <span class="string">&#x27;MySQL&#x27;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/rTy2sdWij8IHvRn.png" alt="003_SQL性能分析_11.png"></p>
<p>如果是数据量大的数据库，在查询的时候有索引和没有索引是两个效率，所以对于数据量大、经常被查询的表，创建索引是非常有效的方法。</p>
<h3 id="最左前缀法则">最左前缀法则</h3>
<p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会<strong>部分失效</strong>(后面的字段索引失效)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询从索引的最左列开始，并且不跳过索引中的列</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/q4gkK6H5IoUzPZb.png" alt="003_SQL性能分析_12.png"></p>
<p>讲解：假设存在一张tb_user 表，其中有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。对于最左前缀法则指的是，查询时，<strong>最左边的列</strong>，也就是profession<strong>必须存在</strong>，否则索引<strong>全部失效</strong>。而且中间不能跳过某一列，否则该列后面的字段索引将失效。  比如上面的在查询的时候只有<code>age</code>和<code>status</code> 没有<code>profession</code> 所以索引失效(NULL).</p>
<blockquote>
<p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p>
</blockquote>
<h3 id="范围查询">范围查询</h3>
<ol>
<li>联合索引中，出现范围查询，则范围查询右侧的列索引失效</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 范围查询</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">&gt;</span><span class="number">30</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/zkTKXrRZSCtyElf.png" alt="003_SQL性能分析_13.png"></p>
<p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。</p>
<p>在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或  &lt;.</p>
<ol start="2">
<li>不要在索引列上进行运算操作，否则索引失效</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/GfIDjSvUcKJ64qd.png" alt="003_SQL性能分析_14.png"></p>
<ol start="3">
<li>字符串不加引号会失效:原因 <strong>存在隐式类型转换</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990013</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/exET3cPQr4uYXI5.png" alt="003_SQL性能分析_15.png"></p>
<ol start="4">
<li>头部模糊匹配会导致索引失效</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/OgnzGJqHS1KZE78.png" alt="003_SQL性能分析_16.png"></p>
<ol start="5">
<li>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/Khek5VsH41QGIgd.png" alt="003_SQL性能分析_17.png"></p>
<ol start="6">
<li>当mysql评估使用索引比全表搜索慢，就不会使用索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span><span class="string">&#x27;17799990000&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/NUkL5yI4ZqFRb8G.png" alt="003_SQL性能分析_18.png"></p>
<ol start="7">
<li>还有一种情况是使用<code>is null</code> 和<code>is not null</code> 是否走索引并不固定</li>
</ol>
<h3 id="SQL提示">SQL提示</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL提示</span></span><br><span class="line"><span class="comment">-- 准备索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro <span class="keyword">on</span> tb_user(profession);</span><br><span class="line"><span class="comment">-- 一般情况下此SQL语句使用的索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/9dph53gMBIrGNQX.png" alt="003_SQL性能分析_19.png"></p>
<p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示(指定MySQL使用哪些索引)来达到优化操作的目的。</p>
<ol>
<li>建议MySQL使用指定索引： <code>use index;</code> 有可能MySQL不接受</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用单列索引 某些情况下mysql可能不接受</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/SU2WMLKhZTbVzHx.png" alt="003_SQL性能分析_20.png"></p>
<ol start="2">
<li>忽略指定索引：<code>ignore index;</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 忽略某个索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/BMSYIK9u8k1iC4D.png" alt="003_SQL性能分析_21.png"></p>
<ol start="3">
<li>强制使用指定索引：<code>force index;</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 强制使用某个索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="覆盖索引">覆盖索引</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。也尽量减少使用select *</span></span><br><span class="line">explain <span class="keyword">select</span> id,profession,age,status,name <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/Wn23oEkjlsDqdPM.png" alt="003_SQL性能分析_22.png"></p>
<p>其中我们重点关注<code>Extra</code></p>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Using where; Using Index</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td>
</tr>
<tr>
<td>Using index condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody>
</table>
<p>所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引），所以不建议使用select * 进行全字段查询。</p>
<p>演示覆盖索引与回表查询</p>
<p><img src="https://s2.loli.net/2024/11/26/lO4uocK1yfkV3jx.png" alt="100_演示图_09.png"></p>
<p>其中id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p>
<p><img src="https://s2.loli.net/2024/11/26/tAr8YFsZHLbvenU.png" alt="100_演示图_10.png"></p>
<p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p>
<p><img src="https://s2.loli.net/2024/11/26/Gr2doMCASYqgmNz.png" alt="100_演示图_11.png"></p>
<p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索<br>
引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p>
<p><img src="https://s2.loli.net/2024/11/26/Hyk5LjU2K9IzAim.png" alt="100_演示图_12.png"></p>
<p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。</p>
<h3 id="前缀索引">前缀索引</h3>
<p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法:<code>create index idx_xxxx on table_name(column(n)) ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建前缀索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p><strong>前缀长度</strong>：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 选择性 当选择性趋于1(也就是唯一索引)的时候效率最高</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">10</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/6ln1rRwVsoSvjyK.png" alt="003_SQL性能分析_23.png"></p>
<p>展示索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 展示索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/rGiv74XynOIWP3T.png" alt="003_SQL性能分析_24.png"></p>
<p>前缀索引的查询流程</p>
<p><img src="https://s2.loli.net/2024/11/26/At9TiYkLUS5fmgc.png" alt="100_演示图_13.png"></p>
<h3 id="单列索引与联合索引">单列索引与联合索引</h3>
<p>单列索引：一个索引只包含单个列；联合索引：一个索引包含多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<h3 id="索引设置原则">索引设置原则</h3>
<ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索<br>
引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，<br>
避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增<br>
删改的效率。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含<br>
NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<hr>
<h1>SQL优化</h1>
<h2 id="插入优化">插入优化</h2>
<p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p>
<ol>
<li>使用批量插入</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 优化前</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用事务(设置为手动提交)</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>主键顺序插入</li>
</ol>
<p>主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89  效率要高于乱序</p>
<ol start="4">
<li>大批量数据插入(万级别)</li>
</ol>
<p>使用MySQL的load指令，也就是读取sql文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 1. 客户端连接服务端时，加上参数 -–local-infile</span><br><span class="line">mysql –-local-infile -u root -p</span><br><span class="line">-- 2. 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">-- 3. 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.sql(数据的路径)&#x27; into table tb_user(指定的表) fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ; -- 读取数据时以逗号为间隔读取单个数据，当读取到\n自动换行。</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/nKyNkxEVT27wIqR.png" alt="003_SQL性能分析_25.png"></p>
<h2 id="主键优化">主键优化</h2>
<p>InnoDB中数据的组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表</p>
<p>见图<strong>100_演示图_04</strong> 其逻辑结构图见图 <strong>001_存储引擎_06</strong></p>
<p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。</p>
<p><strong>页分裂</strong>：页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p>
<p>此处留空:<strong>做三个manim动画演示顺序、乱序、页合并的步骤</strong></p>
<p><strong>顺序插入</strong>步骤如下</p>
<ol>
<li>从磁盘中申请页， 主键顺序插入</li>
<li>第一个页没有满，继续往第一页插入</li>
<li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li>
<li>当第二页写满了，再往第三页写入</li>
</ol>
<p><strong>乱序插入</strong>步骤如下</p>
<ol start="0">
<li>假如1、2页已满</li>
<li>再插入一个id为1、2页之中的数据，会直接开辟一个页(页3).</li>
<li>然后将1页后一半的数据放在刚开辟的页，再插入数据。</li>
<li>然后设置链表指针，为1-&gt;3-&gt;2</li>
</ol>
<p><strong>页合并</strong>：</p>
<ol>
<li>持续删除某个页的记录，看是否达到MERGE_THRESHOLD（默认为页的50%)</li>
<li>如果达到界限，InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</li>
<li>然后删除数据，并将页合并之后，如果再次插入新的数据，就会在后面的页面添加</li>
</ol>
<blockquote>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定</p>
</blockquote>
<p><strong>索引设置原则</strong></p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
<li>业务操作时，避免对主键的修改</li>
</ul>
<h2 id="order-by优化">order by优化</h2>
<p>MySQL的排序，有两种方式：</p>
<ol>
<li>
<p><strong>Using filesort</strong> : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p>
</li>
<li>
<p><strong>Using index</strong> : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p>
</li>
</ol>
<p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p>
<p>测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql优化，由于字段没有索引，所以用filesort</span></span><br><span class="line">explain <span class="keyword">select</span> id, age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/QL4mE81asPrDnwG.png" alt="004_SQL优化_01.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> phone,age;</span><br></pre></td></tr></table></figure>
<p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了。</p>
<p>排序时,也需要满足<strong>最左前缀法则</strong>,否则也会出现 filesort。</p>
<p>order by<strong>优化原则</strong></p>
<ol>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li>
</ol>
<h2 id="group-by优化">group by优化</h2>
<p>没有索引情况下的查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 没有索引情况下的查询</span></span><br><span class="line">explain <span class="keyword">select</span> profession,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/J7disnyOeESvgR5.png" alt="004_SQL优化_02.png"></p>
<p>对于分组操作，在联合索引中，也是符合<strong>最左前缀法则</strong>的。</p>
<p>有索引情况下的查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建联合索引之后再次执行</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br><span class="line">explain <span class="keyword">select</span> profession,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ZjixyRaB5p8tmEk.png" alt="004_SQL优化_03.png"></p>
<p><strong>group by优化原则</strong></p>
<ol>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在给联合索引命名时注意从左到右命名，方便查看是否符合最左前缀法则，如下</span></span><br><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/XxwmjUiyza68gKQ.png" alt="004_SQL优化_04.png"></p>
<h2 id="limit优化">limit优化</h2>
<p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p>
<p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 优化前</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 优化后，页数越多优化效果越明显</span></span><br><span class="line">explain <span class="keyword">select</span> s.<span class="operator">*</span> <span class="keyword">from</span> tb_user s,(<span class="keyword">select</span> id <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>,<span class="number">10</span>) a <span class="keyword">where</span> s.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure>
<h2 id="count优化">count优化</h2>
<p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p>
<ul>
<li>
<p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p>
</li>
<li>
<p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
</li>
</ul>
<p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</p>
<p>count的用法</p>
<table>
<thead>
<tr>
<th>count用 法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>count(主 键)</td>
<td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null)</td>
</tr>
<tr>
<td>count(字 段)</td>
<td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返 回给服务层，直接按行进行累加。</td>
</tr>
<tr>
<td>count(数 字)</td>
<td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。</td>
</tr>
<tr>
<td>count(*)</td>
<td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接 按行进行累加。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽量使用 count(*)。</p>
</blockquote>
<h2 id="update优化">update优化</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;javaEE&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放</p>
<p>当我们在执行如下SQL时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;SpringBoot&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;PHP&#x27;</span> ;</span><br></pre></td></tr></table></figure>
<p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</p>
<blockquote>
<p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p>
</blockquote>
<h1>视图</h1>
<h2 id="语法-2">语法</h2>
<p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>
通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<ol>
<li>创建视图</li>
</ol>
<p>语法：<code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]  ;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图 会生成一个视图的文件夹，里面存放视图</span></span><br><span class="line"><span class="comment">-- or replace 是如果有就覆盖</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查询视图</li>
</ol>
<p>语法：<code>查看创建视图语句：SHOW CREATE VIEW 视图名称;  查看视图数据：SELECT * FROM 视图名称 ...... ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询创建视图语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="comment">-- 查看视图数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/Sbg6XFJ5inM3VNc.png" alt="005_视图_01.png"></p>
<ol start="3">
<li>修改视图</li>
</ol>
<p>语法：<code>方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]; 方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]  ;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改视图</span></span><br><span class="line"><span class="comment">-- 方式1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,<span class="keyword">no</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 方式2</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/kBOWxVqrRSPl4bH.png" alt="005_视图_02.png"></p>
<ol start="4">
<li>删除视图</li>
</ol>
<p>语法：<code>DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...  ;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> stu_v_1;</span><br></pre></td></tr></table></figure>
<h2 id="视图检查">视图检查</h2>
<p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p>
<ol>
<li>
<p>CASCADED(级联)<br>
比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p>
</li>
<li>
<p>LOCAL(本地)</p>
<p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创<br>
建时未指定检查选项。 则在执行检查时，知会检查v2，不会检查v2的关联视图v1。</p>
</li>
</ol>
<h2 id="视图更新">视图更新</h2>
<p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一<br>
项，则该视图不可更新：</p>
<ol>
<li>
<p>聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</p>
</li>
<li>
<p>DISTINCT</p>
</li>
<li>
<p>GROUP BY</p>
</li>
<li>
<p>HAVING</p>
</li>
<li>
<p>UNION 或者 UNION</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 视图的更新和作用</span></span><br><span class="line"><span class="comment">-- 前提：视图中的行与基础表中的行之间必须存在一一对应的关系。</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_v_count <span class="keyword">as</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_count <span class="keyword">values</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/IAPDmJVkQYCOn1N.png" alt="005_视图_05.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> learning.stu_v_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> learning.stu_v_1 <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;Tom&#x27;</span>);<span class="comment">-- 视图本身不能插入数据，会将数据插入原来的表中</span></span><br><span class="line"><span class="comment">-- 检查30&gt;20 所以报错</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> learning.stu_v_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/X4s9muVaWDlBnRj.png" alt="005_视图_03.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于视图创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> learning.stu_v_1 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 测试插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">18</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="comment">-- 也就是说，如果基于视图创建视图但不添加检查选项时，就会依赖于父视图进行检查。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/casGbjU4vwHP3Oi.png" alt="005_视图_04.png"></p>
<p><strong>视图的优点</strong></p>
<ol>
<li><strong>简单</strong>：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li>
<li><strong>安全</strong>：数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</li>
<li><strong>数据独立</strong>：视图可帮助用户屏蔽真实表结构变化带来的影响。</li>
</ol>
<h2 id="视图的应用">视图的应用</h2>
<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 视图有点像是定制化的备份</span></span><br><span class="line"><span class="comment">-- 案例</span></span><br><span class="line"><span class="comment">-- 屏蔽手机号和邮箱</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_user_view <span class="keyword">as</span> <span class="keyword">select</span> id,name,profession,age,gender,status,createtime <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user_view;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/wgmxi9zOG2rIPAn.png" alt="005_视图_06.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 通过视图实现三表联查</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> <span class="keyword">select</span> s.name student_name,s.no student_no,c.name course_name <span class="keyword">from</span> student s,student_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> sc.courseid <span class="operator">=</span> c.id;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_stu_course_view;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/79g5UMTRO3EHatp.png" alt="005_视图_07.png"></p>
<h1>存储过程</h1>
<p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。<br>
存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用</p>
<p>特点：</p>
<ol>
<li>
<p>封装，复用。可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p>
</li>
<li>
<p>可以接收参数，也可以返回数据。在存储过程中，可以传递参数，也可以接收返回值。</p>
</li>
<li>
<p>减少网络交互，效率提升。如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p>
</li>
<li>
<p>创建存储过程</p>
</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 存储过程</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/TWOvLQjxdeamCog.png" alt="006_储存过程_01.png"></p>
<ol start="2">
<li>调用存储过程</li>
</ol>
<p>语法：<code>CALL 名称 ([ 参数 ]);  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">call</span> p1();</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/PLz8hEqwNHGnSUJ.png" alt="006_储存过程_02.png"></p>
<ol start="3">
<li>查看存储过程</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>; <span class="comment">-- 查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ; <span class="comment">-- 查询某个存储过程的定义</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库的存储过程</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;learning&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/hlkrDbZH1gUTOiQ.png" alt="006_储存过程_03.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看存储过程的创建语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/miUKeBIfbs3CRW9.png" alt="006_储存过程_04.png"></p>
<ol start="4">
<li>删除存储过程</li>
</ol>
<p>语法：<code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除存储过程</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:在命令行中(Linux使用MySQL)，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">    select count(*) from student;</span><br><span class="line"><span class="meta prompt_">end$</span><span class="language-bash">$</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/CeoEHSvudahNsfA.png" alt="006_储存过程_05.png"></p>
<h2 id="变量">变量</h2>
<h3 id="系统变量">系统变量</h3>
<p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p>
<ol>
<li>查看系统变量</li>
</ol>
<p>语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES ; <span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;......&#x27;</span>; <span class="comment">-- 可以通过LIKE模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] 系统变量名; <span class="comment">-- 查看指定变量的值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看系统变量</span></span><br><span class="line"><span class="keyword">show</span> session variables ;</span><br><span class="line"><span class="comment">-- 模糊匹配</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看某一个变量</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/VoETYOUq63tmgPW.png" alt="007_变量_01.png"></p>
<ol start="2">
<li>设置系统变量</li>
</ol>
<p>语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] 系统变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>]系统变量名 <span class="operator">=</span> 值 ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置系统变量</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- mysql服务重新启动后所设置的全局参数会失效，如果要永久改变需要在/etc/my.cnf中配置</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>概念：</p>
<ol>
<li>全局变量(GLOBAL): 全局变量针对于所有的会话。</li>
<li>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</li>
<li>未指定session或者global的时候默认是session</li>
</ol>
</blockquote>
<h3 id="用户定义变量">用户定义变量</h3>
<p>用户定义变量：是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。</p>
<ol>
<li>赋值</li>
</ol>
<p>语法1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr [, <span class="variable">@var_name</span> <span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 自定义变量 冒号可加可不加,建议表示赋值的时候加</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myname</span> <span class="operator">=</span> <span class="string">&#x27;Lloyd&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myage</span> :<span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<p>语法2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var_name</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用自定义变量</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@myname</span>,<span class="variable">@myage</span>;</span><br><span class="line"><span class="comment">-- 将查询的结果赋值给某变量</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@mycount</span> <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/gVpwnvRb6MTjm4Y.png" alt="007_变量_02.png"></p>
<blockquote>
<p>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p>
</blockquote>
<h3 id="局部变量">局部变量</h3>
<p>局部变量：是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，<strong>局部变量的范围是在其内声明的BEGIN … END块</strong>。</p>
<ol>
<li>声明</li>
</ol>
<p>语法：<code>DECLARE 变量名 变量类型 [DEFAULT ... ] ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明 使用关键字declare 一旦超出范围无法使用</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p2()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> stu_count <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> stu_count <span class="keyword">from</span> student;</span><br><span class="line">    <span class="keyword">select</span> stu_count;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p2();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>赋值</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名 ... ;</span><br></pre></td></tr></table></figure>
<h3 id="常使用的“关键字”">常使用的“关键字”</h3>
<h4 id="if">if</h4>
<p>和编程语言一样。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">	.....</span><br><span class="line">ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> <span class="comment">-- 可选</span></span><br><span class="line">	.....</span><br><span class="line"><span class="keyword">ELSE</span> <span class="comment">-- 可选</span></span><br><span class="line">	.....</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">57</span>;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">    if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">    elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p3();</span><br></pre></td></tr></table></figure>
<h4 id="参数">参数</h4>
<p>类型如下</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody>
</table>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ <span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 存储过程的参数</span></span><br><span class="line"><span class="comment">-- 输入的参数是score 输出的参数是result</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p4(<span class="keyword">in</span> score <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">    elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明</span></span><br><span class="line"><span class="keyword">call</span> p4(<span class="number">68</span>,<span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;<span class="comment">-- 返回结果为及格</span></span><br></pre></td></tr></table></figure>
<h4 id="case">case</h4>
<p>和C语言的case基本一样</p>
<p>语法1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，</span></span><br><span class="line">执行statement_list2， 否则就执行 statement_list</span><br><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line">	<span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">	[ <span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">	[ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>
<p>语法2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成</span></span><br><span class="line">立时，执行statement_list2， 否则就执行 statement_list</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">	<span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">	[<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">	[<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- case</span></span><br><span class="line"><span class="comment">-- 案例：按照季度展示数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p6(<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第一季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第二季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第三季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">12</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第四季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;非法参数&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为: &#x27;</span>,<span class="keyword">month</span>,<span class="string">&#x27;,所属的季度为: &#x27;</span>,<span class="keyword">result</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p6(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="while">while</h4>
<p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span></span><br><span class="line">WHILE 条件 DO</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- while</span></span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p7(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    while n <span class="operator">&gt;</span> <span class="number">0</span> do</span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n:<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 从1到10累加循环</span></span><br><span class="line"><span class="keyword">call</span> p7(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/IbVMag5PJ794F6l.png" alt="008_循环_01.png"></p>
<h4 id="repeat">repeat</h4>
<p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。和<code>do ...while </code>很像。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span></span><br><span class="line">REPEAT</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line">	UNTIL 条件</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- repeat</span></span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p8(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    until n<span class="operator">&lt;=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> repeat ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">10</span>);<span class="comment">-- 结果同图008_循环_01 为55</span></span><br></pre></td></tr></table></figure>
<h4 id="loop">loop</h4>
<p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	SQL逻辑...</span><br><span class="line">END LOOP [end_label];</span><br><span class="line">-- </span><br><span class="line">-- 以上所有的label都是自定义的标记</span><br><span class="line">LEAVE label; -- 退出指定标记的循环体 相当于break</span><br><span class="line">ITERATE label; -- 直接进入下一次循环 相当于continue</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- loop</span></span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span></span><br><span class="line"><span class="comment">-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xx</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sum:loop</span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span>  <span class="comment">-- 终止条件</span></span><br><span class="line">            leave sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 判断是否为奇数</span></span><br><span class="line">        if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">            iterate sum;<span class="comment">-- iterate 表示进入下一次循环，相当于continue</span></span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span> loop sum;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 累加偶数</span></span><br><span class="line"><span class="keyword">call</span> p9(<span class="number">10</span>); <span class="comment">-- 结果为 30</span></span><br></pre></td></tr></table></figure>
<h3 id="游标">游标</h3>
<p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法为</p>
<ol>
<li>声明游标</li>
</ol>
<p>语法：<code>DECLARE 游标名称 CURSOR FOR 查询语句 ;  </code></p>
<ol start="2">
<li>打开游标</li>
</ol>
<p>语法：<code>OPEN 游标名称;</code></p>
<ol start="3">
<li>获取游标记录</li>
</ol>
<p>语法：<code>FETCH 游标名称 INTO 变量 [, 变量 ] ;  </code></p>
<ol start="4">
<li>关闭游标</li>
</ol>
<p>语法：<code>CLOSE 游标名称;</code></p>
<p>以上语句在不使用条件处理程序的时候虽然能实现需求，但是MySQL会报错，在逻辑上是有漏洞的，需要增加条件处理程序进行修补。</p>
<p><strong>条件处理程序</strong></p>
<p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤(相当于<code>try.. default</code>)</p>
<p>语法为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_action HANDLER <span class="keyword">FOR</span> condition_value [, condition_value] ... statement ;</span><br><span class="line">handler_action 的取值：</span><br><span class="line">	CONTINUE: 继续执行当前程序</span><br><span class="line">	EXIT: 终止执行当前程序</span><br><span class="line">condition_value 的取值：</span><br><span class="line">	<span class="keyword">SQLSTATE</span> sqlstate_value: 状态码，如 <span class="number">02000</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SQLWARNING</span>: 所有以<span class="number">01</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">	<span class="keyword">NOT</span> FOUND: 所有以<span class="number">02</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">	<span class="keyword">SQLEXCEPTION</span>: 所有没有被<span class="keyword">SQLWARNING</span> 或 <span class="keyword">NOT</span> FOUND捕获的<span class="keyword">SQLSTATE</span>代码的简写</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 储存查询结果集的数据类型</span></span><br><span class="line"><span class="comment">-- 声明游标</span></span><br><span class="line"><span class="comment">-- 添加条件处理程序</span></span><br><span class="line"><span class="comment">-- 逻辑:</span></span><br><span class="line"><span class="comment">-- A. 声明游标, 存储查询结果集</span></span><br><span class="line"><span class="comment">-- B. 准备: 创建表结构</span></span><br><span class="line"><span class="comment">-- C. 开启游标</span></span><br><span class="line"><span class="comment">-- D. 获取游标中的记录</span></span><br><span class="line"><span class="comment">-- E. 插入数据到新表中</span></span><br><span class="line"><span class="comment">-- F. 关闭游标</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p10(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 声明一个游标并记录查询结果的表</span></span><br><span class="line">    <span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">    <span class="comment">-- 当状态码为02000时 将游标关闭</span></span><br><span class="line">    <span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span>  tb_user_pro(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">        profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 开启游标</span></span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    <span class="comment">-- 循环获取表中的记录</span></span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">        <span class="comment">-- 获取游标中的记录并复制给相应的变量</span></span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">        <span class="comment">-- 插入到表中</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span>(<span class="keyword">null</span>,uname,upro);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="comment">-- 关闭游标</span></span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 查询年龄小于40的用户并将其插入表中</span></span><br><span class="line"><span class="keyword">call</span> p10(<span class="number">40</span>);</span><br></pre></td></tr></table></figure>
<p>错误状态码<a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">参考网站</a></p>
<h2 id="存储函数">存储函数</h2>
<p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">RETURNS</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line">	<span class="keyword">RETURN</span> ...;</span><br><span class="line"><span class="keyword">END</span> ;</span><br><span class="line"><span class="comment">-- characteristic说明</span></span><br><span class="line"><span class="comment">-- DETERMINISTIC：相同的输入参数总是产生相同的结果</span></span><br><span class="line"><span class="comment">-- NO SQL ：不包含 SQL 语句</span></span><br><span class="line"><span class="comment">-- READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</span></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 存储函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fun1(n <span class="type">int</span>) <span class="comment">-- 不写默认为in</span></span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    while n <span class="operator">&gt;</span> <span class="number">0</span> do</span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n :<span class="operator">=</span> n <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 如果报错就登录Linux的mysql，然后输入set global log_bin_trust_function_creators = 1;即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="keyword">select</span> fun1(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报错</p>
<h1>触发器</h1>
<p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。<br>
使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<p>类型</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
<ol>
<li>创建</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	trigger_stmt ;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时创建触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_logs(</span><br><span class="line">                          id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">                          operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作类型, insert/update/delete&#x27;</span>,</span><br><span class="line">                          operate_time datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">                          operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作的ID&#x27;</span>,</span><br><span class="line">                          operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line">                          <span class="keyword">primary</span> key(`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"><span class="comment">-- 插入时创建触发器</span></span><br><span class="line"><span class="comment">-- 插入时的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">    after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">        (<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),NEW.id,concat(<span class="string">&#x27;插入的数据内容为:id=&#x27;</span>,NEW.id,<span class="string">&#x27;,name=&#x27;</span>,NEW.name,<span class="string">&#x27;,phone = &#x27;</span>,NEW.phone,<span class="string">&#x27;,email=&#x27;</span>, NEW.email,<span class="string">&#x27;,profession=&#x27;</span>,NEW.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看</li>
</ol>
<p>语法：<code>SHOW TRIGGERS;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">show</span> triggers ;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/xRLljMB1zPG9XHw.png" alt="009_触发器_01.png"></p>
<ol start="3">
<li>删除</li>
</ol>
<p>语法：<code>DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> tb_user_insert_trigger;</span><br></pre></td></tr></table></figure>
<p>示例，测试触发器是否在插入的时候正常出发</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 测试-插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id, name, phone, email, profession, age, gender, status, createtime)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">25</span>,<span class="string">&#x27;二皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试-更新数据</span></span><br><span class="line"><span class="comment">-- 修改数据的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">    after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">        (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),NEW.id,concat(<span class="string">&#x27;更新前的数据内容为:id=&#x27;</span>,OLD.id,<span class="string">&#x27;,name=&#x27;</span>,OLD.name,<span class="string">&#x27;,phone = &#x27;</span>,OLD.phone,<span class="string">&#x27;,email=&#x27;</span>, OLD.email,<span class="string">&#x27;,profession=&#x27;</span>,OLD.profession,<span class="string">&#x27;</span></span><br><span class="line"><span class="string">           | 更新后的数据内容为:id=&#x27;</span>,NEW.id,<span class="string">&#x27;,name=&#x27;</span>,NEW.name,<span class="string">&#x27;,phone = &#x27;</span>,NEW.phone,<span class="string">&#x27;,email=&#x27;</span>, NEW.email,<span class="string">&#x27;,profession=&#x27;</span>,NEW.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试-删除数据</span></span><br><span class="line"><span class="comment">-- 删除数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">    after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">        (<span class="keyword">null</span>,<span class="string">&#x27;delete&#x27;</span>,now(),OLD.id,concat(<span class="string">&#x27;删除前的数据内容为:id=&#x27;</span>,OLD.id,<span class="string">&#x27;,name=&#x27;</span>,OLD.name,<span class="string">&#x27;,phone = &#x27;</span>,OLD.phone,<span class="string">&#x27;,email=&#x27;</span>, OLD.email,<span class="string">&#x27;,profession=&#x27;</span>,OLD.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure>
<p>插入后</p>
<p><img src="https://s2.loli.net/2024/11/26/XRCnGSgbQp4uZ5q.png" alt="009_触发器_02.png"></p>
<p>更新后</p>
<p><img src="https://s2.loli.net/2024/11/26/YJxd7BpvKR5WuoF.png" alt="009_触发器_03.png"></p>
<p>删除后</p>
<p><img src="https://s2.loli.net/2024/11/26/eafiS1lWk9B5g3h.png" alt="009_触发器_04.png"></p>
<h1>锁</h1>
<p>定义：锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>分类为</p>
<ul>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据</li>
</ul>
<h2 id="全局锁">全局锁</h2>
<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>
其典型的使用场景是做<strong>全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>原理：比如先备份了库存表，在备份订单表之前就被修改了，然后导致备份的订单表和之前备份的库存表对不上。</p>
<p>解决方案：对数据库进行进行逻辑备份之前，先对<strong>整个数据库加上全局锁</strong>，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，<strong>但是可以执行DQL语句，也就是处于只读状态</strong>，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p>
<ol>
<li>加全局锁</li>
</ol>
<p>语法：<code>flush tables with read lock;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock ;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数据备份</li>
</ol>
<p>语法：<code>mysqldump -uroot –p用户密码 指定的表 &gt; 指定名字.sql  ;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 备份(windows系统)</span></span><br><span class="line"><span class="comment">-- mysqldump -h虚拟机的IP -uroot -p你的密码 learning &gt; D:/copy/learning.sql 要保存到的路径</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>释放锁</li>
</ol>
<p>语法：<code>unlock tables;</code></p>
<p>加全局锁会有以下问题</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/pRtqX7hukbaVD3g.png" alt="010_锁_01.png"></p>
<p>当解锁之后才能进行更新</p>
<p><img src="https://s2.loli.net/2024/11/26/vjpDof7VP6QeIkc.png" alt="010_锁_02.png"></p>
<ul>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ul>
<p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- InnoDB引擎中，不加锁的一次性备份</span></span><br><span class="line"><span class="comment">-- mysqldump --single-transaction -h虚拟机的IP  -uroot -p你的密码 learning &gt;D:/code/remove/learning.sql</span></span><br></pre></td></tr></table></figure>
<h2 id="表级锁">表级锁</h2>
<p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中</p>
<p>分类</p>
<ul>
<li>表锁
<ul>
<li>表共享读锁(read lcok)</li>
<li>表独占写锁(write lock)</li>
</ul>
</li>
<li>元数据锁(meta data lcok,MDL)</li>
<li>意向锁</li>
</ul>
<h3 id="表锁">表锁</h3>
<ol>
<li>添加锁：</li>
</ol>
<p>语法：<code>lock tables 表名... read/write;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加只读锁</span></span><br><span class="line">lock tables course read;</span><br><span class="line"><span class="comment">-- DQL语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/dVLrF6CSuqDoMGj.png" alt="010_锁_03.png"></p>
<p>在设置共享读锁的时候只能读不能写</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不能写</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">&#x27;Linux&#x27;</span>);<span class="comment">-- 如果是其他的进程尝试写会阻塞</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/W6PApbLxGRkj5a7.png" alt="010_锁_04.png"></p>
<ol start="2">
<li>释放锁：<code>unlock tables;</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 释放表锁</span></span><br><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/jI5PUeVvWTOyl4N.png" alt="010_锁_05.png"></p>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加独写锁</span></span><br><span class="line">lock tables course write ;</span><br><span class="line"><span class="comment">-- 可读可写</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">&#x27;Linux&#x27;</span>);<span class="comment">-- 其他的进程尝试读写会阻塞</span></span><br><span class="line"><span class="comment">-- 释放</span></span><br><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p>
</blockquote>
<h3 id="元数据锁">元数据锁</h3>
<p>meta data lock , 元数据锁，简写<strong>MDL</strong>。MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动<strong>事务</strong>的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。<br>
这里的<strong>元数据</strong>，大家可以简单理解为就是一张表的<strong>表结构</strong>。 也就是说，某一张表涉及到<strong>未提交的事务时，是不能够修改这张表的表结构的</strong>。<br>
在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。<br>
常见的SQL操作时，所添加的元数据锁</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock tables xxx read / write</td>
<td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、 delete、select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody>
</table>
<p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ /SHARED_WRITE），之间是兼容的，也就是允许并行开发。</p>
<p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。</p>
<p><img src="https://s2.loli.net/2024/11/26/cJNioFDxT79wL56.png" alt="010_锁_06.png"></p>
<p>事务提交之后</p>
<p><img src="https://s2.loli.net/2024/11/26/rFYl18MI6fjVzX3.png" alt="010_锁_07.png"></p>
<p>查看数据库中的元数据锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看元数据锁</span></span><br><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/xsCi6jkAbqpfREv.png" alt="010_锁_08.png"></p>
<h3 id="意向锁">意向锁</h3>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。  其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p>
<p>分类</p>
<ul>
<li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li>
<li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li>
</ul>
<blockquote>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
</blockquote>
<p>查看意向锁及行锁的加锁情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span></span><br><span class="line">performance_schema.data_locks;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/PRN87WgcB3inCSY.png" alt="010_锁_09.png"></p>
<p>注意：意向共享锁与表读锁是兼容的、意向排他锁与表读锁、写锁都是互斥的</p>
<h2 id="行锁">行锁</h2>
<p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。<br>
InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的<br>
锁。对于行级锁，主要分为以下三类：</p>
<ul>
<li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/27/ghdv8so6mr7CAVY.png" alt="100_演示图_15.png"></p>
<ul>
<li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/27/B4K8fF5vmpiAxMd.png" alt="100_演示图_16.png"></p>
<ul>
<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/27/FrnjGt8akCq2W5E.png" alt="100_演示图_17.png"></p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他<br>
锁</li>
</ul>
<table>
<thead>
<tr>
<th>当前锁类型\请求锁类型</th>
<th>S(共享锁)</th>
<th>X(排他锁)</th>
</tr>
</thead>
<tbody>
<tr>
<td>S(共享锁)</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X(排他锁)</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody>
</table>
<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td>不加任何 锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在SELECT之后加LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在SELECT之后加FOR UPDATE</td>
</tr>
</tbody>
</table>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li>
</ul>
<p>示例</p>
<p><img src="https://s2.loli.net/2024/11/26/pgS6c4uqOitQlx2.png" alt="010_锁_10.png"></p>
<p>兼容性</p>
<p><img src="https://s2.loli.net/2024/11/26/nw8tjYNKgEZ9bpo.png" alt="010_锁_11.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/a4q61XnvMCwRzge.png" alt="010_锁_12.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/qDL4jZaR53QVK8c.png" alt="010_锁_13.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/BPMGV58fFr3gZdO.png" alt="010_锁_14.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/SQsb3XhgW7HaBOJ.png" alt="010_锁_15.png"></p>
<p>如果没有索引，更新语句行锁会升级为表锁(因为行锁是对索引项加的锁，而某字段没有索引)  ，这样我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。</p>
<p>间隙锁和临键锁</p>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜<br>
索和索引扫描，以防止幻读。</p>
<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li>
<li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li>
</ul>
<blockquote>
<p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/26/UZwhtQ5VvrxecpL.png" alt="010_锁_16.png"></p>
<p>图中方框中的GAP就是间隙锁</p>
<p>常见的上锁情况</p>
<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li>
</ul>
<p>分析</p>
<p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p>
<p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。  比如查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：[19]、 (19,25]、 (25,+∞] 所以数据库数据在加锁时，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p>
<h1>InnoDB引擎</h1>
<p>逻辑存储结构见<code>001_存储引擎_06.png</code>和逻辑存储结构部分</p>
<p>参考黑马和这篇博客<a href="https://blog.csdn.net/2401_83283514/article/details/140721803">InnoDB引擎：底层结构及底层原理</a> ，讲解得足够详细。</p>
<p>这一部分的重点在于<strong>理解其实现原理</strong>，而不是死记硬背。</p>
<h1>MySQL管理</h1>
<p>系统自带的数据库</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql</td>
<td>存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用 户、权限等）</td>
</tr>
<tr>
<td>information_schema</td>
<td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类 型及访问权限等</td>
</tr>
<tr>
<td>performance_schema</td>
<td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集 数据库服务器性能参数</td>
</tr>
<tr>
<td>sys</td>
<td>包含了一系列方便 DBA 和开发人员利用 performance_schema 性能数据库进行性能调优和诊断的视图</td>
</tr>
</tbody>
</table>
<h2 id="常用工具">常用工具</h2>
<h3 id="mysql的客户端工具"><strong>mysql的客户端工具</strong></h3>
<p>语法：<code>mysql [options] [database]</code> 在<strong>命令行</strong>中输入</p>
<p>option</p>
<ul>
<li>-u, --user=name #指定用户名</li>
<li>-p, --password[=name] #指定密码</li>
<li>-h, --host=name #指定服务器IP或域名</li>
<li>-P, --port=port #指定连接端口</li>
<li>-e, --execute=name #执行SQL语句并退出</li>
</ul>
<p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便</p>
<p><img src="https://s2.loli.net/2024/11/26/cVr7FzLDwqs1lnk.png" alt="012_mysql管理_02.png"></p>
<h3 id="mysqladmin">mysqladmin</h3>
<p>是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p>
<p>语法：<code>mysqladmin --help</code></p>
<p><img src="https://s2.loli.net/2024/11/26/24y6eSqDIjfm8oi.png" alt="012_mysql管理_03.png"></p>
<p>语法：<code>mysqlamin [options] command </code></p>
<p>options:</p>
<ul>
<li>-u, --user=name #指定用户名</li>
<li>-p, --password[=name] #指定密码</li>
<li>-h, --host=name #指定服务器IP或域名</li>
<li>-P, --port=port #指定连接端口</li>
</ul>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot –p1234 drop &#x27;test01&#x27;;</span><br><span class="line">mysqladmin -uroot –p1234 version;</span><br></pre></td></tr></table></figure>
<h3 id="mysqlbinlog">mysqlbinlog</h3>
<p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p>
<p>语法：<code>mysqlbinlog [options] log-files1 log-files2 ...  </code></p>
<p>options:</p>
<ul>
<li>-d, --database=name 指定数据库名称，只列出指定的数据库相关操作。</li>
<li>-o, --offset=# 忽略掉日志中的前n行命令。</li>
<li>-r,–result-file=name 将输出的文本格式日志输出到指定文件。</li>
<li>-s, --short-form 显示简单格式， 省略掉一些信息。</li>
<li>–start-datatime=date1 --stop-datetime=date2 指定日期间隔内的所有日志。</li>
<li>–start-position=pos1 --stop-position=pos2 指定位置间隔内的所有日志。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/dHcx7UXhZiTa3kV.png" alt="012_mysql管理_04.png"></p>
<h3 id="mysqlshow">mysqlshow</h3>
<p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
<p>语法：<code>mysqlshow [options] [db_name [table_name [col_name]]]  </code></p>
<p>options</p>
<ul>
<li>–count 显示数据库及表的统计信息（数据库，表 均可以不指定）</li>
<li>-i 显示指定数据库或者指定表的状态信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询<span class="built_in">test</span>库中每个表中的字段书，及行数</span></span><br><span class="line">mysqlshow -uroot -p2143 test --count</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询<span class="built_in">test</span>库中book表的详细情况</span></span><br><span class="line">mysqlshow -uroot -p2143 test book --count</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/cIYJA9Lbjktq3g1.png" alt="012_mysql管理_05.png"></p>
<h3 id="mysqldump">mysqldump</h3>
<p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p>
<p>语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br><span class="line"></span><br><span class="line">连接选项 ：</span><br><span class="line">-u, --user=name 指定用户名</span><br><span class="line">-p, --password[=name] 指定密码</span><br><span class="line">-h, --host=name 指定服务器ip或域名</span><br><span class="line">-P, --port=# 指定连接端口</span><br><span class="line">输出选项：</span><br><span class="line">--add-drop-database 在每个数据库创建语句前加上 drop database 语句</span><br><span class="line">--add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)</span><br><span class="line">-n, --no-create-db 不包含数据库的创建语句</span><br><span class="line">-t, --no-create-info 不包含数据表的创建语句</span><br><span class="line">-d --no-data 不包含数据</span><br><span class="line">-T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/k1IKbloOEAeWP2t.png" alt="012_mysql管理_06.png"></p>
<h3 id="mysqlimport-source">mysqlimport/source</h3>
<p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件</p>
<p>语法：<code>mysqlimport [options] db_name textfile1 [textfile2...]  </code></p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p2143 test /tmp/city.txt</span><br></pre></td></tr></table></figure>
<p>语法：如果需要导入sql文件,可以使用mysql中的source 指令 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /root/xxxxx.sql  # 这里的/root/xxxxx.sql是文件路径</span><br></pre></td></tr></table></figure>
<h1>参考</h1>
<ol>
<li><a href="https://blog.csdn.net/qq_45938466/article/details/107941557">数据库工作原理</a></li>
<li>黑马程序员的视频和pdf资料</li>
<li><a href="https://dev.mysql.com">MySQL官网</a></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客系列(三)博客写作指南</title>
    <url>/2024/10/26/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%B8%89)%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1>简介</h1>
<p>在撰写博客的过程中，内容至关重要但不是唯一重要的因素，排版、图片、交互体验等视觉设计也同样需要关注。一个设计精美、易于阅读的博客会吸引更多读者，提升用户体验。本文将为你提供一套完整的 markdown 博客创作指南，从实战的角度帮助你写出既有深度又美观的博客文章。</p>
<h1>准备工具</h1>
<h2 id="写作工具">写作工具</h2>
<p>个人比较推崇<strong>Typora</strong>这种简洁的支持<strong>markdown</strong>格式的编辑器，相比之下，obsidian的布局不利于专注于写作，notion的自定义布局和数据库这两大突出优势在markdown格式下会有损失，vscode依赖于插件。</p>
<p>总之就是一句话:</p>
<blockquote>
<p>能让你心无旁骛地去写的编辑器就是最好的</p>
</blockquote>
<h2 id="博客引擎">博客引擎</h2>
<p>本文基于hexo+butterfly的主题进行博客创作，但读者无须担心，博客创作更多的在于<strong>文章结构</strong>、<strong>词句修辞</strong>、<strong>排版和可读性</strong>方面下功夫，其他方面依赖博客引擎和前端特性的并不多，读者可以在CSDN、博客园、掘金社区等其他地方同样可以撰写和托管博客。</p>
<h1>博客撰写讲解</h1>
<h2 id="目录结构">目录结构</h2>
<p>好的目录结构要梳理文章逻辑，如果是<strong>新闻热点点评类</strong>，就要能讲清楚事件发生的时间地点人物，发生原因及其分析，结论、启示或者经验教训；如果是<strong>技术分享类</strong>，就要说明技术的应用范围，原理，怎样配置技术所需的环境，阐明使用技术的效果等。这方面主要靠读者多看技术大佬的博客、优秀的公众号推文等，看他们的目录是如何区分的，只要能达到<strong>行云流水</strong>的效果就行，不需要在分级、格式方面过于讲究。</p>
<p>可供参考的文章结构：大部分都是<strong>总-分-总</strong>结构</p>
<ul>
<li>提出问题-&gt;分析问题-&gt;解决问题-&gt;总结经验，技术问题分享。</li>
<li>背景-&gt;思考-&gt;尝试-&gt;遇到的困难-&gt;解决方案-&gt;最后结果，问题分享</li>
<li>摘要-&gt;简介-&gt;分支主题-&gt;总结，一般技术分享。</li>
<li>是什么-原理-背景&gt;解决了什么问题-&gt;基本操作-&gt;同类对比-&gt;总结 ，适合新技术分享</li>
</ul>
<p>参考的目录结构如下，以markdown格式的代码块展示,这里<code>//</code>及其后面的内容代表注释</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 简介    </span></span><br><span class="line"><span class="section"># 一、准备工作 //一些环境配置，安装等，或者是解决问题的背景等</span></span><br><span class="line"><span class="section">## 1.centos安装  //以数字的形式合理分级，建议标题的层级不要超过四层</span></span><br><span class="line"><span class="section">## 2.idea解包</span></span><br><span class="line"><span class="section">## ……</span></span><br><span class="line"><span class="section"># 二、基本用法 //对于技术文章就像是语法书，对于问题就是发现问题，分析问题，</span></span><br><span class="line"><span class="section">## 1. 对页面的操作</span></span><br><span class="line"><span class="section">## 2. 1 初始化浏览器对象</span></span><br><span class="line"><span class="section">## 2. 2</span></span><br><span class="line"><span class="section">## ……</span></span><br><span class="line"><span class="section"># 三、高阶用法  //或者是多个解决方案</span></span><br><span class="line"><span class="section"># 总结  //对技术或者过程的总结，建议不要太长</span></span><br><span class="line"><span class="section"># 参考  //把你写作过程中参考的资料，或者是推荐的链接放在这里，便于读者后续学习</span></span><br><span class="line"><span class="section"># 开源协议  //如果使用的是hexo或者其他博客网站，撰写博客的时候会自动生成，不需要自己写</span></span><br></pre></td></tr></table></figure>
<h3 id="标题">标题</h3>
<p>取标题要注意几点</p>
<ol>
<li><strong>简洁直观</strong>：不仅仅是利于搜索引擎优化，更多的是便于读者和自己，读者可以通过标题判断博客的信息对于自己是否有效，作者可以根据标题了解自己博客的侧重方面。<strong>不要被国内电商式的标题所蒙蔽</strong>(比如“爆肝……”“震惊，百大up主齐聚一堂竟然是为……”)，虽然能带来流量，但是作者不太建议，这种标题就显得作者没有真才实学，只能靠眼球吸引读者，</li>
<li><strong>关键词</strong>：标题一定要包含文章的高频词或者是重点词语，比如如果你写的是有关MySQL的学习知识分享，那么关键字就是“MySQL”，可能有“教程”等其他关键词，再用适当的句子结构(问句、陈述句等)将其组合为标题。比如组合为”MySQL学习指南(一)“</li>
</ol>
<p><strong>特殊</strong>:所有<strong>系列文章</strong>(比如MySQL学习笔记)的标题要一致，<strong>相关的</strong>可以不一致。标题+XX:XX为数字，不满两位用0替代;比如mysql01;标题+(序数词):比如mysql学习(一)</p>
<h3 id="简介">简介</h3>
<p>文章的标题和简要介绍一下文章，要解决的是什么问题</p>
<p><strong>示例</strong>：Selenium是广泛使用的模拟浏览器运行的库，它是一个用于Web应用程序测试的工具。 Selenium测试直接运行在浏览器中，就像真正的用户在操作一样，并且支持大多数现代 Web 浏览器。下面就进入正式的学习阶段。</p>
<h3 id="文章主体">文章主体</h3>
<p>以下主要侧重于排版。</p>
<ol>
<li>段落：建议不要太长，最好保持在300字以内</li>
<li>字体效果：用黑体强调重要词汇，用斜体或者下划线强调重要段落</li>
<li>列表：恰当使用无序和有序列表，对于超过10个点的列表建议使用markdown里面的表格</li>
<li>图片：如果图片能便于读者理解，减少文字量，可以使用。</li>
<li>代码块：建议默认收起或者收缩，需要的时候读者点击即可全部展开。指明代码块对应的编程语言，不是的话要提前说明</li>
<li>分割线：建议用在两个一级标题或者是两段长段落之间。</li>
</ol>
<p>注意事项</p>
<ol>
<li>所有的代码至少要在自己的电脑上或者对应的运行环境上运行，否则不写</li>
<li>不易理解或者抽象的地方要用图解释，可以是GIF动图制作也可以是chartjs、echart等，注意不要泄漏私人信息。</li>
<li>模棱两可或者自己不懂的不要轻易写，写的话注意叠甲。</li>
</ol>
<h2 id="超文本内容">超文本内容</h2>
<p>这一部分主要涉及前端的特性，属于是锦上添花的内容，即使没有也不是特别影响文章的质量，就算《资本论》只有文字，也无可争议是最伟大的鸿篇巨著之一。</p>
<p>常用的类型有：图片、动画(gif等)、视频、音频、表情、标签外挂、图标、链接等。</p>
<h3 id="图表">图表</h3>
<ol>
<li><a href="https://excalidraw.com/">Excalidraw</a>：手绘风格的开源工具，适合绘制思维导图、流程图等。</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/lvhXLijoyQYUnkb.png" alt="博客写作指南_01"></p>
<ol start="2">
<li><a href="https://mermaid.nodejs.cn/">Mermaid 中文网</a>：基于 Markdown 的流程图工具，可以生成流程图、时序图等。或者也可以使用<a href="https://app.diagrams.net/">draw.io</a>。主要侧重于计算机方面的知识图表，常用于UML统一建模语言。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  
sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;&gt;John: Hello John, how are you?
    loop HealthCheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br&#x2F;&gt;prevail!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!

  </pre></div>
<ol start="3">
<li><a href="https://chartjs.cn/docs/latest/">Chart.js 中文网</a>：是一个用于创建动态图表的 JavaScript 库，适合做一些比较复杂的数据分析图。</li>
</ol>
<div class="chartjs-container chartjs-abreast" data-chartjs-id data-width="40%">
            <pre class="chartjs-src" hidden>{
    &quot;type&quot;: &quot;pie&quot;,
    &quot;data&quot;: {
        &quot;labels&quot;: [
            &quot;编程&quot;,
            &quot;音乐&quot;,
            &quot;阅读&quot;,
            &quot;游戏&quot;,
            &quot;健身&quot;,
            &quot;旅游&quot;
        ],
        &quot;datasets&quot;: [
            {
                &quot;label&quot;: &quot;喜爱指数&quot;,
                &quot;data&quot;: [
                    30,
                    24,
                    19,
                    14,
                    9,
                    4
                ],
                &quot;backgroundColor&quot;: {
                    &quot;dark-mode&quot;: [
                        &quot;rgba(255, 99, 132, 0.5)&quot;,
                        &quot;rgba(54, 162, 235, 0.5)&quot;,
                        &quot;rgba(255, 206, 86, 0.5)&quot;,
                        &quot;rgba(75, 192, 192, 0.5)&quot;,
                        &quot;rgba(153, 102, 255, 0.5)&quot;,
                        &quot;rgba(255, 159, 64, 0.5)&quot;
                    ],
                    &quot;light-mode&quot;: [
                        &quot;rgba(255, 99, 132, 0.2)&quot;,
                        &quot;rgba(54, 162, 235, 0.2)&quot;,
                        &quot;rgba(255, 206, 86, 0.2)&quot;,
                        &quot;rgba(75, 192, 192, 0.2)&quot;,
                        &quot;rgba(153, 102, 255, 0.2)&quot;,
                        &quot;rgba(255, 159, 64, 0.2)&quot;
                    ]
                },
                &quot;borderColor&quot;: {
                    &quot;dark-mode&quot;: [
                        &quot;rgba(255, 99, 132, 1)&quot;,
                        &quot;rgba(54, 162, 235, 1)&quot;,
                        &quot;rgba(255, 206, 86, 1)&quot;,
                        &quot;rgba(75, 192, 192, 1)&quot;,
                        &quot;rgba(153, 102, 255, 1)&quot;,
                        &quot;rgba(255, 159, 64, 1)&quot;
                    ],
                    &quot;light-mode&quot;: [
                        &quot;rgba(255, 99, 132, 1)&quot;,
                        &quot;rgba(54, 162, 235, 1)&quot;,
                        &quot;rgba(255, 206, 86, 1)&quot;,
                        &quot;rgba(75, 192, 192, 1)&quot;,
                        &quot;rgba(153, 102, 255, 1)&quot;,
                        &quot;rgba(255, 159, 64, 1)&quot;
                    ]
                }
            }
        ]
    },
    &quot;options&quot;: {
        &quot;plugins&quot;: {
            &quot;legend&quot;: {
                &quot;labels&quot;: {
                    &quot;color&quot;: {
                        &quot;dark-mode&quot;: &quot;rgba(255, 255, 255, 0.8)&quot;,
                        &quot;light-mode&quot;: &quot;rgba(0, 0, 0, 0.8)&quot;
                    }
                }
            }
        }
    }
}
</pre>
            <div class="chartjs-desc"><p>除了<strong>计算机编程</strong>外，我想不出还有其他让我感兴趣的工作。<br>
我可以无中生有地创造出<strong>精美的范式</strong>和<strong>结构</strong>，<br>
在此过程中也解决了无数的小谜团。<br>
<span style="font-size:0.8em;color: var(--sep-secondtext);">I can’t think of any other job other than <strong>computer programming</strong> that interests me.<br>
I can create <strong>beautiful paradigms</strong> and <strong>structures</strong> out of nothing,<br>
Countless small mysteries are also solved in the process.</span></p></div>
          </div>
<h3 id="视频">视频</h3>
<ol>
<li>B站引用：打开网页版的bilibili，点击要分享的视频-“分享”-“嵌入代码”，然后粘贴到markdown文件内即可。参考如下</li>
</ol>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=552211531&bvid=BV1vi4y1C73C&cid=547518386&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;">
    </iframe>
</div>
<h3 id="公式">公式</h3>
<p>建议使用katex，或者是markdown本地的公式嵌入。</p>
<p>参考教程<a href="https://freeopen.github.io/mathjax/">Markdown 数学公式指导手册 | Freeopen</a></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mrow><mi>sin</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mrow><mi>cos</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sin^2(\theta) + \cos^2(\theta) = 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1219em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">sin</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8719em;"><span style="top:-3.1208em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">cos</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<h3 id="表情符号">表情符号</h3>
<ol>
<li><a href="https://www.lddgo.net/common/emoticons">在线颜文字大全</a> ：与markdown兼容，基本不会有不显示等问题</li>
<li><a href="https://www.emojiall.com/zh-hans/categories/A">表情包</a> ：注意typora的表情(格式为<code>:表情</code>)无法在hexo显示，所以只能用图片替代表情</li>
<li><a href="https://fontawesome.com/v4/icons/">图标</a>：适当的图标可以让人记忆犹新，见图思义。</li>
</ol>
<h3 id="交互式的组件">交互式的组件</h3>
<p>比如butterfly中的button、图床等，由于不同的博客引擎涉及的组件不同，这里就不展开。建议读者不要舍本逐末，过度美化而忽视文章的内容。</p>
<h2 id="总结与参考">总结与参考</h2>
<ul>
<li>
<p>用一段话给文章内容作总结。</p>
</li>
<li>
<p><strong>参考</strong>要注明来源，比如链接、转载出处，注意定期更新以防失效。</p>
</li>
</ul>
<h1>参考</h1>
<ol>
<li><a href="https://www.cnblogs.com/returntmp/p/17591866.html">【全方位解析】如何写好技术文章 - ReturnTmp - 博客园</a></li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客系列(一)测试与更新</title>
    <url>/2024/06/10/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%B8%80)%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1>hexo博客更新和待更新计划</h1>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">更新内容</button><button type="button" class="tab">未来可能更新内容</button><button type="button" class="tab">更新方法与经验</button></div><div class="tab-contents"><div class="tab-item-content active"><blockquote>
<p>以下更新内容都是从最后一次更新开始的</p>
</blockquote>
<div class="timeline green"><div class="timeline-item headline"><div class="timeline-item-title"><div class="item-circle"><p>2024</p>
</div></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>11-9</p>
</div></div><div class="timeline-item-content"><ol>
<li>在网页/privacy下添加了隐私用户政策</li>
</ol>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>10-29</p>
</div></div><div class="timeline-item-content"><ol>
<li>修复了手机端视频溢出显示部分的问题</li>
<li>修改了几处笔误和显示问题。</li>
<li>优化了所有博客的参考部分</li>
</ol>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>10-26</p>
</div></div><div class="timeline-item-content"><ol>
<li>butterfly主题从5.0.0更新到5.1.0版本</li>
<li>优化了chart插件</li>
<li>更新了一篇新博客</li>
</ol>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>10-10</p>
</div></div><div class="timeline-item-content"><ol>
<li>butterfly主题从4.13.0更新到5.0.0版本</li>
<li>首页添加了磁贴,修复了磁贴名字和描述不匹配的问题</li>
<li>更新了留言板</li>
<li>优化了搜索功能</li>
<li>禁止B站视频自动播放</li>
<li>更新了主页“关于”部分</li>
<li>修复了几处笔误的问题</li>
<li>优化了评论功能的选择</li>
<li>添加了站点工具(谷歌与必应)，优化了文章的描述部分</li>
<li>优化一下图片无法放大查看的问题</li>
</ol>
</div></div></div></div><div class="tab-item-content"><ol>
<li>子菜单展示内容；方法：通过基本的markdown语言和butterfly专有语法-标签外挂实现效果，建议写成总领式的文章或者展示页面。可以参考此博客<a href="https://blog.guole.fun/posts/butterfly-custom/#%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E8%BD%AE%E6%92%AD%E6%A8%A1%E5%9D%97">我的Blog美化日记——Hexo+Butterfly | Guo Le’s Blog</a> 里面的“volantis”部分，和这个<code>[Hexo Built-in Tag Plugins (Hexo内置标签外挂) | Ofra Serendipity](https://www.huangshiqing.website/2022/11/03/HexoTagPlugins/)</code></li>
<li>添加一下赞助墙</li>
<li>更新算法相关博客并添加数学动画视频或者是算法演示动画</li>
<li>学习并在博客中添加图表-对于本网站以chartjs的图表为主，涉及UML就用Mermaid,对于精致的图表(比如数据分析)才会用Echart.</li>
<li>考虑21cloudbox或者阿里云等托管平台部署网站，实在不行就用域名+CDN的方式让游客能间接访问我的github.io网站。</li>
<li>如果托管平台不负责，就早日申请SSL证书、域名绑定(可选)和完成网站备案，参考网站<a href="https://xuezenghui.com/posts/hexo-deploy-to-netlify/">将 Hexo 博客部署至 Netlify | Zander Hsueh</a>  域名申请<a href="https://tech.yemengstar.com/hexo-tutorial-use-your-domain-beginner/">为HEXO绑定自己的域名</a></li>
</ol></div><div class="tab-item-content"><h2 id="debug经验">debug经验</h2>
<p>目前由于butterfly的版本更新，导致以前的部分功能失效，建议<strong>先看官方文档，将对应过时的代码注释或者去除，没有的代码添加</strong>，然后再<strong>根据</strong>F12检查对应的板块，<strong>用前端的知识去搜查问题发生的地点和原因</strong>，然后再纠错。</p>
<h2 id="hexo框架更新">hexo框架更新</h2>
<p>参考此博客<a href="https://blog.zhheo.com/p/6d1f1f98.html">如何更新Hexo及插件的版本？如何更新主题版本？ | 张洪Heo (zhheo.com)</a></p>
<p>简单来说就是先进入博客根目录然后在终端输入<code>npm update</code> ，确保node.js包是最新版本。然后输入<code>npm outdated</code> 看哪些插件已经过时，可以更新。然后修改根目录的package.json文件，将对应插件名称所对应的版本号更改为要更新的版本号。再在终端输入<code>npm install --save</code> 开始更新hexo及其插件，通过<code>hexo version</code> 查看是否已经更新</p>
<h2 id="butterfly主题更新">butterfly主题更新</h2>
<blockquote>
<p>更新前记得留下blog快照</p>
</blockquote>
<p>官方文档：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 文檔(一) 快速開始 | Butterfly</a></p>
<p>从butterfly5.0.0版本开始，可以直接在hexo根目录下输入<code>npm update hexo-theme-butterfly</code></p>
<p>如果不行，就在你的博客/themes/butterfly 根目录下打开git bash并输入<code>git pull</code> 即可更新</p>
<p>建议以后更新博客直接在命令行输入<code>hexo cl;hexo g</code> 一键清除与生成，多个分号代表分别执行。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="个人hexo博客更新讲解">个人hexo博客更新讲解</h2>
<p>在md文件开头的是配置部分，tags是标签(就是在文档末尾出现的几个按钮文字)，<strong>可以有很多个</strong>;categories是分类，建议将其分为大类，<strong>小类从属于大类</strong>。在首页中博客只显示发布日期，更新日期、分类和标签(第一个).</p>
<p>示例代码如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">测试</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">教程</span></span><br></pre></td></tr></table></figure>
<p><strong>评论功能</strong>：我设置的是twikoo静态评论控制+Valine评论。</p>
<p><strong>文章置顶功能</strong>：可以直接在文章的 <code>front-matter</code> 区域里添加 <code>sticky: 1</code> 属性来把这篇文章置顶。数值越大，置顶的优先级越大。参考<code>梁圣磊の博客</code></p>
<p><strong>文章加密功能</strong>：文章加密插件  <a href="https://polar-bear.eu.org/2023/07/21/ce-shi/">参考链接</a> 也许以后添加。</p>
<p><strong>博客撰写</strong>：</p>
<ol>
<li>hexo会自动给分级标题编号，不需要自己添加</li>
<li><u>不要给标点符号加标签或者是特性</u>，容易出现显示问题。</li>
</ol>
<p><strong>磁贴功能</strong>：我干脆把主设置里面的<strong>descr</strong>部分删掉，没写就是对的o(<em>￣▽￣</em>)ブ</p>
<p><strong>同步问题</strong>：在zeabur的部署大概会间隔一天左右才会同步上。</p>
<p><strong>图片方面</strong></p>
<ul>
<li>
<p>方法1：通过picgo图床实现图片上传。参考<a href="https://www.bilibili.com/video/BV1ci4y1L7j8?vd_source=bb8dacb993f11c0e39f8147c98a2894c">Typora+PicGo+阿里云OSS实现云笔记|Typora上传图片</a></p>
</li>
<li>
<p>方法2-本地上传图片：参考此博客<a href="https://blog.csdn.net/weixin_43702620/article/details/118655308">hexo搭建博客后图片无法显示的完美解决_hexo博客图片不显示-CSDN博客</a> 简单来说就是在post文件夹内对应每一个md文件创建同名的文件夹，然后将图片放在里面，需要引用的时候就按照<code>![](./文件夹名/图片名.png</code> 进行引用。如果部署到zeabur的博客图片不显示，可以使用<code>![图片名](图片名.png)</code> 此方法，<strong>注意图片必须放在与md文件同名的文件夹下且不允许中文命名</strong>。</p>
</li>
<li>
<p>方法3：使用其他的图床网站如<a href="https://smms.app/">SMMS</a>。上传图片后，点击markdown格式就可以复制图片路径，再用markdown语法粘贴即可。<strong>博主因为部署的原因绝大多数图片都使用此方法</strong>，如果读者只使用github page作为网站托管平台那么三个方法都可以用。</p>
</li>
</ul>
<p><strong>音乐</strong></p>
<ol>
<li>我使用的是网易云的平台，如果要修改就在自己的那个歌单修改就行了。</li>
</ol>
<p><strong>导航栏设置</strong>：在<code>_config.butterfly.yml</code> 文件中搜索menu, 注意格式要和下面的一样，可以自行设置。  图标（就是||后面的内容）在这里<a href="https://fontawesome.com/v4/icons/">Font Awesome Icons</a>_ 搜索然后复制class= &quot; 复制这里的内容&quot; 替代即可。</p>
<p><strong>系列文章</strong>：在文章的 front-matter 上添加参数 series，并给予一個标签</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% series %&#125;</span><br><span class="line">&#123;% series [series name] %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<h3 id="测试图片">测试图片</h3>
<p><strong>阿里云图片测试</strong></p>
<p>得出结论，在github.io上无法显示。</p>
<p><code>https://blog-img-copy.oss-cn-guangzhou.aliyuncs.com/C:%5CUsers%5Ckai98%5CPictures%5C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%5Cpost-imggame_menu.png</code></p>
<p><strong>本地图片测试</strong></p>
<p>由于github镜像源限制的问题，<strong>不推荐站主们使用github作为文件或者是图片的镜像源，而是使用比较正规的托管平台或者图片上传平台</strong>。</p>
<p><strong>标签外挂测试图片</strong></p>
<div class="gallery-container" data-type="data" data-button>
      <div class="gallery-items">[{"url":"https://s2.loli.net/2024/06/14/4RrcPzbG3fsqyC6.png","alt":"3.png"}]</div>
    </div>
<p><strong>图床图片测试</strong></p>
<p><img src="https://s2.loli.net/2024/10/24/MQ6gGn4LtBDyduJ.png" alt="苍之彼方的四重奏.png"></p>
<h3 id="测试系列文章">测试系列文章</h3>
<ol class="series-items"><li><a href="/2024/06/10/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%B8%80)%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%9B%B4%E6%96%B0/" title="hexo博客系列(一)测试与更新">hexo博客系列(一)测试与更新</a></li><li><a href="/2024/10/26/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%B8%89)%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/" title="hexo博客系列(三)博客写作指南">hexo博客系列(三)博客写作指南</a></li><li><a href="/2024/06/12/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%BA%8C)%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/" title="hexo博客系列(二)博客创建指南">hexo博客系列(二)博客创建指南</a></li></ol>
<h3 id="标签外挂测试">标签外挂测试</h3>
<blockquote>
<p>本以下基于hexo+butterfly的主题，其他的主题请读者自行查阅有关资料</p>
</blockquote>
<p>官方文档：<a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 文檔(四) 標簽外挂 | Butterfly</a></p>
<ol>
<li>Note (Bootstrap Callout)</li>
</ol>
<p>个人使用，感觉比较适合知识的分层结构，比如我博客里面的《英语语法(英语兔版)》</p>
<ol start="2">
<li>tag-hide</li>
</ol>
<p>个人感觉比较适合于问答类型或者是部分内容较多，需要的时候再展开的文章内容。测试如下</p>
<p><strong>Block测试</strong></p>
<p>查看答案</p>
<div class="hide-block"><button type="button" class="hide-button" style>查看答案
    </button><div class="hide-content"><p>答案就在你心中</p>
</div></div>
<p><strong>Toggle测试</strong></p>
<details class="toggle"><summary class="toggle-button" style>Butterfly安裝方法</summary><div class="toggle-content"><p>在你的博客根目錄裏</p>
<p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</code></p>
<p>如果想要安裝比較新的 dev 分支，可以</p>
<p><code>git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</code></p>
</div></details>
<p><strong>Mermaid测试</strong></p>
<p>这是和图表有关的标签，可以画流程图，时序图等</p>
<p>注意要先写<code>&#123;% mermaid %&#125; &#123;% endmermaid %&#125;</code> 然后就在这两个标签内写相关代码。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  
sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;&gt;John: Hello John, how are you?
    loop HealthCheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br&#x2F;&gt;prevail!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!

  </pre></div>
<p><strong>乐谱测试</strong></p>
<div class="abc-music-sheet">X:1
T:alternate heads
M:C
L:1/8
U:n=!style=normal!
K:C treble style=rhythm
&quot;Am&quot; BBBB B2 B&gt;B | &quot;Dm&quot; B2 B/B/B &quot;C&quot; B4 |&quot;Am&quot; B2 nGnB B2 nGnA | &quot;Dm&quot; nDB/B/ nDB/B/ &quot;C&quot; nCB/B/ nCB/B/ |B8| B0 B0 B0 B0 |]
%%text This translates to:
[M:C][K:style=normal]
[A,EAce][A,EAce][A,EAce][A,EAce] [A,EAce]2 [A,EAce]&gt;[A,EAce] |[DAdf]2 [DAdf]/[DAdf]/[DAdf] [CEGce]4 |[A,EAce]2 GA [A,EAce] GA |D[DAdf]/[DAdf]/ D[DAdf]/[DAdf]/ C [CEGce]/[CEGce]/ C[CEGce]/[CEGce]/ |[CEGce]8 | [CEGce]2 [CEGce]2 [CEGce]2 [CEGce]2 |]
GAB2 !style=harmonic![gb]4|GAB2 [K: style=harmonic]gbgb|
[K: style=x]
C/A,/ C/C/E C/zz2|
w:Rock-y did-nt like that</div>
<p><strong>测试自带的chartjs</strong>——可以实现动态效果，建议使用。</p>
<div class="chartjs-container chartjs-abreast" data-chartjs-id data-width="40%">
            <pre class="chartjs-src" hidden>{
    &quot;type&quot;: &quot;pie&quot;,
    &quot;data&quot;: {
        &quot;labels&quot;: [
            &quot;编程&quot;,
            &quot;音乐&quot;,
            &quot;阅读&quot;,
            &quot;游戏&quot;,
            &quot;健身&quot;,
            &quot;旅游&quot;
        ],
        &quot;datasets&quot;: [
            {
                &quot;label&quot;: &quot;喜爱指数&quot;,
                &quot;data&quot;: [
                    30,
                    24,
                    19,
                    14,
                    9,
                    4
                ],
                &quot;backgroundColor&quot;: {
                    &quot;dark-mode&quot;: [
                        &quot;rgba(255, 99, 132, 0.5)&quot;,
                        &quot;rgba(54, 162, 235, 0.5)&quot;,
                        &quot;rgba(255, 206, 86, 0.5)&quot;,
                        &quot;rgba(75, 192, 192, 0.5)&quot;,
                        &quot;rgba(153, 102, 255, 0.5)&quot;,
                        &quot;rgba(255, 159, 64, 0.5)&quot;
                    ],
                    &quot;light-mode&quot;: [
                        &quot;rgba(255, 99, 132, 0.2)&quot;,
                        &quot;rgba(54, 162, 235, 0.2)&quot;,
                        &quot;rgba(255, 206, 86, 0.2)&quot;,
                        &quot;rgba(75, 192, 192, 0.2)&quot;,
                        &quot;rgba(153, 102, 255, 0.2)&quot;,
                        &quot;rgba(255, 159, 64, 0.2)&quot;
                    ]
                },
                &quot;borderColor&quot;: {
                    &quot;dark-mode&quot;: [
                        &quot;rgba(255, 99, 132, 1)&quot;,
                        &quot;rgba(54, 162, 235, 1)&quot;,
                        &quot;rgba(255, 206, 86, 1)&quot;,
                        &quot;rgba(75, 192, 192, 1)&quot;,
                        &quot;rgba(153, 102, 255, 1)&quot;,
                        &quot;rgba(255, 159, 64, 1)&quot;
                    ],
                    &quot;light-mode&quot;: [
                        &quot;rgba(255, 99, 132, 1)&quot;,
                        &quot;rgba(54, 162, 235, 1)&quot;,
                        &quot;rgba(255, 206, 86, 1)&quot;,
                        &quot;rgba(75, 192, 192, 1)&quot;,
                        &quot;rgba(153, 102, 255, 1)&quot;,
                        &quot;rgba(255, 159, 64, 1)&quot;
                    ]
                }
            }
        ]
    },
    &quot;options&quot;: {
        &quot;plugins&quot;: {
            &quot;legend&quot;: {
                &quot;labels&quot;: {
                    &quot;color&quot;: {
                        &quot;dark-mode&quot;: &quot;rgba(255, 255, 255, 0.8)&quot;,
                        &quot;light-mode&quot;: &quot;rgba(0, 0, 0, 0.8)&quot;
                    }
                }
            }
        }
    }
}
</pre>
            <div class="chartjs-desc"><p>除了<strong>计算机编程</strong>外，我想不出还有其他让我感兴趣的工作。<br>
我可以无中生有地创造出<strong>精美的范式</strong>和<strong>结构</strong>，<br>
在此过程中也解决了无数的小谜团。<br>
<span style="font-size:0.8em;color: var(--sep-secondtext);">I can’t think of any other job other than <strong>computer programming</strong> that interests me.<br>
I can create <strong>beautiful paradigms</strong> and <strong>structures</strong> out of nothing,<br>
Countless small mysteries are also solved in the process.</span></p></div>
          </div>
<p><strong>tab演示</strong></p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><strong>按钮button测试</strong></p>
<div class="btn-center">
<a class="btn-beautify outline larger" href="https://butterfly.js.org/" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a>
</div>
<p><strong>文字高亮</strong></p>
<mark class="hl-label color">text</mark> ,颜色可选default/blue/pink/red/purple/orange/green
<mark class="hl-label red">红色</mark>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>blog</tag>
        <tag>测试</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记(一)基础篇</title>
    <url>/2024/10/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>注：本篇博客大部分是黑马pdf中的内容，根据我自己学习的实际情况进行修改和补充。</p>
</blockquote>
<h1>简介</h1>
<p>数据库(database 简称DB)是存储数据的仓库，数据是有组织的进行存储.而数据库管理系统(database management system)是操作和管理数据库的大型软件(常用的有oracle、mysql等).SQL是操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准。</p>
<h1>准备工作</h1>
<blockquote>
<ol>
<li>建议读者具有一定的Linux基础再来学习本篇博客</li>
<li>本博客所使用的是Mysql8.0的版本</li>
<li>所有代码中的注释均使用<code>--</code>或者<code>/**/</code>以便适配不同的sql语言</li>
</ol>
</blockquote>
<h2 id="下载">下载</h2>
<h3 id="Windows下载MySQL8-0版本">Windows下载MySQL8.0版本</h3>
<p>官网：<a href="https://dev.mysql.com/downloads/windows/installer/">MySQL :: Download MySQL Installer</a></p>
<p>如图所示进行下载.<strong>后面一路默认安装</strong>，在输入mysql中root用户密码的时候建议稍复杂一点，牢记即可。<br>
<img src="https://s2.loli.net/2024/11/26/bdRZNfpYy6avmG3.png" alt="001_mysql安装_01.png"></p>
<p>然后再配置环境变量：在“开始”中搜索”编辑系统环境变量“-找到PATH点击去，将MySQL server的安装目录下的bin目录添加到环境变量，如图</p>
<p><img src="https://s2.loli.net/2024/11/26/HUo6qg2Bv1kWY5F.png" alt="001_mysql安装_02.png"></p>
<h3 id="Linux中下载MySQL8-0版本">Linux中下载MySQL8.0版本</h3>
<p>同样在上面的官网下载，选择合适的版本(当然用Linux联网下载也是可以的)。如果速度慢可以考虑此链接<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/">Index of /mysql/ | 清华大学开源软件镜像站</a></p>
<p><img src="https://s2.loli.net/2024/11/26/iqDna5rpZuIU7Ak.png" alt="001_mysql安装_03.png"></p>
<ol>
<li>用Xftp连接到Linux，然后将其上传到根目录下</li>
<li>创建目录并解压.注意这里的文件名是你自己下的文件的名字。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line">tar -xvf mysql-8.0.40-1.e17.x86_64.rpm-bundle.tar -C mysql</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装MySQL的安装包(注意严格按照顺序执行命令，否则会出现依赖错误)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd mysql</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-common-8.0.40-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.40-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-8.0.40-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.40-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install openssl-devel</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-devel-8.0.40-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-8.0.40-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-server-8.0.40-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动MySQL服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>
<p>设置<strong>开机自启动</strong>,以后只要打开Linux就会启动mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>登录MySQL并设置root密码</li>
</ol>
<p>查看自动生成的密码：<code>grep 'temporary password' /var/log/mysqld.log</code>并将其复制</p>
<p>命令行输入<code>mysql -u root -p</code> 并粘贴刚才的密码(<strong>shift+insert</strong>)</p>
<blockquote>
<p>注意 以下的命令输入是在登录MySQL后的</p>
</blockquote>
<p>登录到MySQL之后，需要将自动生成的不便记忆的密码修改了，修改成自己熟悉的便于记忆的密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER  USER  &#x27;root&#x27;@&#x27;localhost&#x27;  IDENTIFIED BY &#x27;1234(你自己设置密码)&#x27;;</span><br></pre></td></tr></table></figure>
<p>执行上述的SQL会报错，原因是因为设置的密码太简单，密码复杂度不够。我们可以设置密码的复杂度为简单类型(自己学习用可以设置简单密码，但是在<strong>生产中不建议使用简单密码</strong>)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set global validate_password.policy = 0;</span><br></pre></td></tr></table></figure>
<p>降低密码的校验规则之后，再次执行上述修改密码的指令。</p>
<ol start="6">
<li>创建远程登录用户</li>
</ol>
<p>默认的root用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个root账户，用户远程访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;自己设置密码&#x27;;</span><br></pre></td></tr></table></figure>
<p>分配权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>
<p>后面通过其他软件进行远程登录的时候就可以使用此用户进行登录了。</p>
<p>示例：使用IDEA进行远程登录</p>
<p>点击“+”-”数据源“-“MySQL”，然后按照图填写相关配置即可。</p>
<p><img src="https://s2.loli.net/2024/11/26/VBOFamZifkuNLCy.png" alt="001_mysql安装_04.png"></p>
<h2 id="Windows启动MySQL">Windows启动MySQL</h2>
<p>打开方式有如下三种</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">命令行</button><button type="button" class="tab">系统控制</button><button type="button" class="tab">开机自启动</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>通过命令行的方式打开(Windows11)</strong></p>
<ol>
<li>按<code>win+r</code>键，在弹出的窗口内输入cmd</li>
<li>再按ctrl+shift+enter以管理员的方式运行</li>
<li>输入<code>net start MySQL服务名(例如本机是mysql80)</code></li>
<li>停止Mysql命令：<code>net stop mMySQL服务名</code></li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/YF6mcAWnj8k1StC.png" alt="001_mysql安装_05.png"></p></div><div class="tab-item-content"><ol>
<li>按<code>win+r</code>键，在弹出的窗口内输入cmd</li>
<li>输入services.msc打开服务，找到对应的mysql，右键启动即可</li>
</ol></div><div class="tab-item-content"><p>按<code>win+x</code>键，选择“任务管理器”，在左侧栏点击“服务”，搜索mysql，然后鼠标右键点击“<strong>打开服务</strong>”(或者按照系统控制的方法打开服务也行)，然后找到mysql右键-“属性”，点开“启动类型”并选择自动，点击应用并确定即可实现开机自启动。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="MySQL连接方式">MySQL连接方式</h2>
<table>
<thead>
<tr>
<th>方式</th>
<th>效果</th>
<th>难度</th>
<th>连接操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL 8.0 Command Line Client</td>
<td>和命令行一样，可视性不是特别强</td>
<td>低，安装MySQL自带的</td>
<td>开始界面搜索MySQL 8.0 Command Line Client，然后输入密码即可</td>
</tr>
<tr>
<td><strong>Windows命令行</strong></td>
<td>命令行，无需多言</td>
<td>中，需要在系统属性里的PATH里面配置环境变量(就是<code>你的MySQL路径\bin</code>)</td>
<td>打开命令行之后输入<code>mysql -u用户名 -p密码</code>      或者<code>mysql -u root -p </code>  加密输入密码防止泄露</td>
</tr>
</tbody>
</table>
<p>Windows命令行打开示意图(<strong>和Linux一样</strong>)</p>
<p><img src="https://s2.loli.net/2024/11/26/W6Iyz1GEuvxLlFh.png" alt="001_mysql安装_06.png"></p>
<p>命令行工具指令讲解</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql[-h 127.0.0.1][-P 3306] -u root -p</span><br></pre></td></tr></table></figure>
<p>其中-h:MySQL服务所在的主机IP；-P:MySOL服务端口号，默认3306；-u:MySQL数据库用户名-p:MySQL数据库用户名对应的密码</p>
<hr>
<h1>MySQL基础篇</h1>
<h2 id="概念解析">概念解析</h2>
<p><strong>关系型数据库</strong></p>
<p>概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。二维表就是由行和列组成的表，就是Excel中的那种表</p>
<p><strong>SQL语言</strong></p>
<blockquote>
<p>Structured Query Language  操作关系型数据库的编程语言</p>
</blockquote>
<p>无论是MySQL，还是oracle等其他的数据库，都遵守一定的SQL通用语法，特点如下</p>
<ol>
<li><strong>不区分大小写</strong>，但<u>建议关键字大写</u></li>
<li>注释：<code>#</code>或者是<code>--</code>单行注释，<code>/**/</code>是多行注释</li>
<li>可以单行或者多行书写，以分号结尾</li>
</ol>
<h2 id="DDL">DDL</h2>
<blockquote>
<p>Data Definition Languages  即数据定义语言</p>
</blockquote>
<h3 id="数据库操作">数据库操作</h3>
<blockquote>
<p>以下我使用图形化工具IDEA展示效果，读者可以使用datagrip、Tomcat等图形化工具进行操作学习</p>
<p>由于hexo的原因，以下所有代码块中的语言都改为SQL，<strong>除特别指出，以下SQL均代表MySQL</strong></p>
</blockquote>
<ol>
<li>查询所有数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/fRWn4by6L1qCPji.png" alt="002_DDL_01.png"></p>
<p>因为我之间创建过一些数据库，所以会有读者没有的数据库，读者无需在意。</p>
<ol start="2">
<li>查询当前数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建数据库</li>
</ol>
<p>语法：<code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;  </code></p>
<blockquote>
<p>语法讲解</p>
<ol>
<li>[]内的内容表示非必写，或者是限定条件</li>
<li>对于某些版本的MySQL(比如5.7版本)可能需要设置字符集为utf-8</li>
</ol>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 由于mysql中不能创建两个名称相同的数据库，可以使用if语句事先判断是否存在同名的数据库</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> test1;</span><br><span class="line"><span class="comment">-- 创建一个数据库并指定字符集</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> Mydatabase01 <span class="keyword">default</span> charset utf8mb4;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>删除数据库</li>
</ol>
<p>语法：<code>drop database [ if exists ] 数据库名 ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database test3;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>切换数据库</li>
</ol>
<p>语法：<code>use 数据库名</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use test1;</span><br></pre></td></tr></table></figure>
<h3 id="表操作">表操作</h3>
<ol>
<li>展示当前数据库中所有的表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看表结构</li>
</ol>
<p>语法：<code>desc 表名</code>.可以查看表的字段、数据类型、主键等</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> emps;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ntjiL7VQqPsYzWf.png" alt="002_DDL_02.png"></p>
<p>查看表中所有的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> test1.emps;</span><br><span class="line"><span class="comment">-- 等效于以下语句</span></span><br><span class="line"><span class="keyword">show</span> columns <span class="keyword">from</span> emps;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查询指定表的建表语句</li>
</ol>
<p>语法：<code>show create table 表名</code>。就是查看创建表所使用的代码。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> emps;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/mLwBbvJaqi2VzYF.png" alt="002_DDL_03.png"></p>
<ol start="4">
<li>创建表结构</li>
</ol>
<p>语法如下：注意[…]为可选函数，最后一个字段后面没有逗号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [COMMENT 字段<span class="number">1</span>注释 ],</span><br><span class="line">	字段<span class="number">2</span> 字段<span class="number">2</span>类型 [COMMENT 字段<span class="number">2</span>注释 ],</span><br><span class="line">	字段<span class="number">3</span> 字段<span class="number">3</span>类型 [COMMENT 字段<span class="number">3</span>注释 ],</span><br><span class="line">	......</span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender <span class="type">varchar</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看错误与警告</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 展示错误与警告</span></span><br><span class="line"><span class="keyword">show</span> errors ;</span><br><span class="line"><span class="keyword">show</span> warnings ;</span><br></pre></td></tr></table></figure>
<h4 id="数据类型">数据类型</h4>
<p>常见的数据类型基本上和其他高级编程语言大致相同，主要分为三类，数值类型、字符串类型、日期时间类型。根据字段要存储的数据选择合适的数据类型(比如年龄适合用tinyint unsigned)</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">数值类型</button><button type="button" class="tab">字符串类型</button><button type="button" class="tab">日期类型</button></div><div class="tab-contents"><div class="tab-item-content active"><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号(SIGNED)范围</th>
<th>无符号(UNSIGNED)范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1byte</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整 数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2bytes</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整 数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3bytes</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整 数值</td>
</tr>
<tr>
<td>INT/INTEGER</td>
<td>4bytes</td>
<td>(-2147483648， 2147483647)</td>
<td>(0，4294967295)</td>
<td>大整 数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8bytes</td>
<td>(-2^63，2^63-1)</td>
<td>(0，2^64-1)</td>
<td>极大 整数 值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4bytes</td>
<td>(-3.402823466 E+38， 3.402823466351 E+38)</td>
<td>0 和 (1.175494351 E- 38，3.402823466 E+38)</td>
<td>单精 度浮 点数 值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8bytes</td>
<td>(-1.7976931348623157 E+308， 1.7976931348623157 E+308)</td>
<td>0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308)</td>
<td>双精 度浮 点数 值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td></td>
<td>依赖于M(精度)和D(标度)的值(精度就是数字长度，标度就是小数点后几位)</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>小数值(精确确定点数)</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>0-255 bytes</td>
<td><strong>定长</strong>字符串(需要指定长度)</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td><strong>变长</strong>字符串(需要指定最大长度)</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>不超过255个字符的二进制数据</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><table>
<thead>
<tr>
<th>类型</th>
<th>大 小</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 至 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 至 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续 时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时 间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时 间值，时间戳</td>
</tr>
</tbody>
</table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例-设置员工表</span></span><br><span class="line"><span class="comment">-- 1.编号（纯数字）</span></span><br><span class="line"><span class="comment">-- 2.员工工号(字符串类型，长度不超过10位)</span></span><br><span class="line"><span class="comment">-- 3.员工姓名(字符串类型，长度不超过10位)</span></span><br><span class="line"><span class="comment">-- 4.性别(男/女，存储一个汉字)</span></span><br><span class="line"><span class="comment">-- 5.年龄(正常人年龄，不可能存储负数)</span></span><br><span class="line"><span class="comment">-- 6.身份证号(二代身份证号均为18位，身份证中有x这样的字符)</span></span><br><span class="line"><span class="comment">-- 7.入职时间（取值年月日即可）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    workno <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;工号&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">    age tinyint unsigned comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    idcard <span class="type">char</span>(<span class="number">18</span>) comment <span class="string">&#x27;身份证号&#x27;</span>,</span><br><span class="line">    entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;员工表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="增删查改">增删查改</h4>
<ol>
<li>添加字段</li>
</ol>
<p>语法：<code>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> nickname <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;昵称&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改数据类型</li>
</ol>
<p>语法：<code>ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度);  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp change nickname username <span class="type">varchar</span>(<span class="number">30</span>) comment <span class="string">&#x27;用户名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改字段和字段类型</li>
</ol>
<p>语法：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp CHANGE nickname username <span class="type">varchar</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>删除字段</li>
</ol>
<p>语法：<code>ALTER TABLE 表名 DROP 字段名;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> username;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改表名</li>
</ol>
<p>语法：<code>ALTER TABLE 表名 RENAME TO 新表名  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp rename <span class="keyword">to</span> employee;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>删除表</li>
</ol>
<p>语法：<code>DROP TABLE [ IF EXISTS ] 表名;  </code>;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只有表名存在的时候才会删除该表，不存在的时候就不会删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>删除并重新创建表</li>
</ol>
<p>语法：<code>TRUNCATE TABLE 表名;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除并创建该表,这样就实现了数据清空但保留表结构的效果</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> employee;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：以上操作虽然可以通过图形化界面工具直接实现，但数据库常常在Linux上操作，建议读者使用命令行的方式实现有关需求。</p>
<p>方法：右键数据库-“新建”-“查询控制台”，然后就可以在界面中编写sql并执行。</p>
</blockquote>
<h2 id="DML">DML</h2>
<blockquote>
<p>Data Manipulation Languages  数据操作语言</p>
</blockquote>
<p><strong>增删查改数据</strong></p>
<ol>
<li>给指定字段添加数据</li>
</ol>
<p>语法：<code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee(id, workno, name, gender, age, idcard, entrydate) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;123456789012345678&#x27;</span>,<span class="string">&#x27;2000-11-01&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>数据查询如下</p>
<p><img src="https://s2.loli.net/2024/11/26/4QnbPRFrs8f1ayD.png" alt="003_DML_01.png"></p>
<p><u>如果是要给全部字段添加数据，就无需写字段名</u></p>
<ol start="2">
<li>批量添加</li>
</ol>
<p>语法：<code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;  </code>如果是全部字段添加数据则无需写明字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span></span><br><span class="line">	(<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;韦一笑&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">38</span>,<span class="string">&#x27;123456789012345670&#x27;</span>,<span class="string">&#x27;2005-01-01&#x27;</span>),</span><br><span class="line">	(<span class="number">4</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;赵敏&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;123456789012345670&#x27;</span>,<span class="string">&#x27;2005-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<ol>
<li>插入数据时指定的字段顺序需要与值的顺序是一一对应的</li>
<li>字符串和日期类型要在<strong>引号</strong>中</li>
<li>数据应在规定范围内，否则会报错</li>
</ol>
</blockquote>
<ol start="3">
<li>修改数据</li>
</ol>
<p>语法：<code>UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将id为1的员工的员工名字改为itheima，性别改为女</span></span><br><span class="line"><span class="keyword">update</span> employee <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;itheima&#x27;</span>,gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ZNFgmhJuCG9QEwt.png" alt="003_DML_02.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将所有员工的入职时期设置为同一个时期</span></span><br><span class="line"><span class="keyword">update</span> employee <span class="keyword">set</span> entrydate  <span class="operator">=</span> <span class="string">&#x27;2003-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/QUc96FmpXdLD74W.png" alt="003_DML_03.png"></p>
<blockquote>
<p>如果修改数据没有where语句，默认修改所有数据</p>
</blockquote>
<ol start="4">
<li>删除数据</li>
</ol>
<p>语法：<code>DELETE FROM 表名 [ WHERE 条件 ]   ;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除所有员工性别为女的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="comment">-- 相当于删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>delete语句不能删除某一个字段的值，需要使用update将该字段设置为null</p>
</blockquote>
<h2 id="DQL">DQL</h2>
<blockquote>
<p>Data Query Language  数据查询语言，用来查询数据库中表的记录</p>
</blockquote>
<p>在实际开发和业务中，查询也是最常用的</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>
<p><strong>这一语法非常重要，涉及到很多的知识</strong>。</p>
<h3 id="基础查询">基础查询</h3>
<ol>
<li>查询多个字段</li>
</ol>
<p>语法：<code>SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从emps表中查询employee_id、email和hire_date字段的数据</span></span><br><span class="line"><span class="keyword">select</span> employee_id,email,hire_date <span class="keyword">from</span> emps;</span><br><span class="line"><span class="comment">-- 如果要查询所有字段，可以使用select * from 表明，但是在开发规范中一般会规定不使用* 而用字段提高效率。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/6HKDnIRyjXG9342.png" alt="004_DQL_01.png"></p>
<ol start="2">
<li>字段设置别名</li>
</ol>
<p>语法：<code>SELECT 字段1 [ [AS] 别名1 ] , 字段2 [ [AS] 别名2 ] ... FROM 表名;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 给字段取别名 建议带上as</span></span><br><span class="line"><span class="keyword">select</span> employee_id <span class="keyword">as</span> <span class="string">&#x27;职工号&#x27;</span> <span class="keyword">from</span> emps;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/JqUpDIcVmO9jRN4.png" alt="004_DQL_02.png"></p>
<ol start="3">
<li>去除重复数据</li>
</ol>
<p>语法：<code>SELECT DISTINCT 字段列表 FROM 表名;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询字段数据且不重复</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> job_id <span class="string">&#x27;工作岗位&#x27;</span> <span class="keyword">from</span> emps;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/W9ABeQaI7YpM8Jt.png" alt="004_DQL_03.png"></p>
<h3 id="条件查询">条件查询</h3>
<p>语法：<code>SELECT 字段列表 FROM 表名 WHERE 条件列表 ;  </code><br>
常见的比较运算符和逻辑运算符如下</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">比较运算符</button><button type="button" class="tab">逻辑运算符</button></div><div class="tab-contents"><div class="tab-item-content active"><table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>在某个范围之内(含最小、最大值)</td>
</tr>
<tr>
<td>IN(…)</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>LIKE 占位符</td>
<td>模糊匹配(_匹配单个字符, %匹配任意个字符)</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND 或 &amp;&amp;</td>
<td>并且 (多个条件同时成立)</td>
</tr>
<tr>
<td>OR 或 ||</td>
<td>或者 (多个条件任意一个成立)</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非 , 不是</td>
</tr>
</tbody>
</table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 条件查询 </span></span><br><span class="line"><span class="comment">-- 从emps表中查询员工id为100的员工所有信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps <span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ty8h4JOMkUnIWLu.png" alt="004_DQL_04.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 多个字段的限制</span></span><br><span class="line"><span class="comment">-- 从emps表中查询工资等于2500且部门id为50的员工所有信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps <span class="keyword">where</span> salary <span class="operator">=</span> <span class="number">2500</span> <span class="keyword">and</span> department_id <span class="operator">=</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/VfTGd3ZY87qpgH2.png" alt="004_DQL_05.png"></p>
<p>字符串的查询：<strong>模糊匹配</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询姓最后一个字符是a的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps <span class="keyword">where</span> emps.first_name <span class="keyword">like</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/aE43p5XeAfS7RBM.png" alt="004_DQL_06.png"></p>
<h3 id="聚合函数">聚合函数</h3>
<p>概念：将一列数据作为整体进行数学运算，就像是Excel的函数库<br>
常见的聚合函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody>
</table>
<p>语法:<code>SELECT 聚合函数(字段列表) FROM 表名  ;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计有commission_pct字段数据的个数 注意null是不参与聚合函数的运算的</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(commission_pct) <span class="keyword">from</span> emps;</span><br><span class="line"><span class="comment">-- 统计总记录数 用count(1)同理</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emps;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/K2whiGnPMvR1Xfs.png" alt="004_DQL_07.png"></p>
<h3 id="分组查询">分组查询</h3>
<p>语法：<code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];  </code><br>
where与having区别</p>
<ol>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组<br>
之后对结果进行过滤。</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以</li>
</ol>
<blockquote>
<ol>
<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</li>
<li>执行顺序: where &gt; 聚合函数 &gt; having 。</li>
<li>支持多字段分组, 具体语法为 : group by columnA,columnB</li>
</ol>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计不同工资对应的人员数量</span></span><br><span class="line"><span class="comment">-- 先对工资分组，然后再统计每一组工资员工的数量</span></span><br><span class="line"><span class="keyword">select</span> salary,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emps <span class="keyword">group</span> <span class="keyword">by</span> salary;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/CFOLIrYm4cp3uWU.png" alt="004_DQL_08.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 根据部门分组，统计各部门的平均工资</span></span><br><span class="line"><span class="keyword">select</span> department_id,<span class="built_in">avg</span>(salary) <span class="keyword">from</span> emps <span class="keyword">group</span> <span class="keyword">by</span> department_id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/YGoMWyUF2BlSA6c.png" alt="004_DQL_09.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资小于等于4000的员工，并根据部门分组，获取员工数量大于等于2的部门id</span></span><br><span class="line"><span class="keyword">select</span> department_id,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emps <span class="keyword">where</span> salary <span class="operator">&lt;=</span><span class="number">4000</span> <span class="keyword">group</span> <span class="keyword">by</span> department_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/oj9OcCwBynfXpFE.png" alt="004_DQL_10.png"></p>
<h3 id="排序查询">排序查询</h3>
<p>语法：<code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;  </code>asc为升序(默认)，desc为降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 根据入职时间升序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps <span class="keyword">order</span> <span class="keyword">by</span> hire_date;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/sZwq3O7CiDfP4FB.png" alt="004_DQL_11.png"></p>
<blockquote>
<p>如果是多字段排序，当第一个字段相同的时候才会按照第二个字段进行排序</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先按照工资排序，年龄相同就按入职时间降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">asc</span>,hire_date <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/NlIefXg8oWVKnuD.png" alt="004_DQL_12.png"></p>
<h3 id="分页查询">分页查询</h3>
<p>就是在浏览网页的时候经常会有的分页条</p>
<p>语法：<code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;  </code></p>
<blockquote>
<p>• 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。<br>
• 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。<br>
• 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分页查询-尤其在电商网站上使用较多</span></span><br><span class="line"><span class="comment">-- 查询第一页员工数据，每一页显示10条数据,注意经典索引从0开始</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps limit <span class="number">0</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/RMaPj3FlQGJBLUS.png" alt="004_DQL_13.png"></p>
<p><strong>启示</strong>：<u>用英语“从句”的思维理解mysql语句执行的先后顺序</u></p>
<p>举例：查询性别为男，年龄在20-40岁之间(含)的前5个员工信息，对查询的结果按年龄升序排列，如果年龄相同就按照入职时间排序。</p>
<p>这里的关键在于找到“主句”-查询信息，谁的信息呢？，前面的修饰语就是“男”、“年龄”和“前五个”，后面的对……句都是状语，一般放在后面的，所以先写出<code>select * from emp where gender = '男' and age between 20 and 40</code>的语句，但是好像没有“前五个”，聪明的你应该发现前五个就是分页查询，按每页5个不就是能找到前五个了吗。那就是limit 5，由于mysql的特性，limit要放在句子的最后面。我们再考虑“状语”，关键词是“排序”，那就在前面语句的基础上再筛选 即<code>order by age asc,entrydate asc limit 5;</code>组合起来就是完整的语句了。执行顺序是 <strong>from-&gt;where-&gt;group by-&gt;select-&gt;having-&gt;order by-&gt;limit.</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">40</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> ,endrydate <span class="keyword">asc</span> limit <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="DCL">DCL</h2>
<blockquote>
<p>Data Control Languages  数据控制语言</p>
</blockquote>
<p>概念：用来管理数据库用户、控制数据库的访问权限</p>
<h3 id="管理用户">管理用户</h3>
<ol>
<li>查询用户</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询用户</span></span><br><span class="line">USE MYSQL;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user; </span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/AgT2wMblaQ6tXNd.png" alt="005_DCL_01.png"></p>
<p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的(用于远程访问的一般是Linux上的MySQL)。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户</p>
<ol start="2">
<li>创建用户</li>
</ol>
<p>语法：<code>CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户，只能够在当前主机上访问(localhost)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;jerry&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户，可以在任意主机上访问,主要是在虚拟机上使用的较多</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;tom&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改用户密码</li>
</ol>
<p>语法：<code>ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改用户密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;jerry&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;1234&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>删除用户</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;jerry&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;tom&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户</li>
<li>主机名可以使用 % 通配</li>
</ol>
</blockquote>
<h3 id="权限控制">权限控制</h3>
<p>分类</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALL, ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库/表/视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库/表</td>
</tr>
</tbody>
</table>
<p>具体的权限描述和其他的请查看官方网站<a href="https://dev.mysql.com">https://dev.mysql.com</a>；不会就找中文版的文档吧(ㆆᴗㆆ)</p>
<ol>
<li>查询权限</li>
</ol>
<p>语法：<code>SHOW GRANTS FOR '用户名'@'主机名' ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询权限</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;jerry&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/arPxdTF5kM6mYHq.png" alt="005_DCL_02.png"></p>
<ol start="2">
<li>授予权限</li>
</ol>
<p>很重要，远程登录的时候无法增删查改很大程度上都是因为没有授予相应的权限。</p>
<p>语法：<code>GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予权限 将test1数据库的所有表对jerry用户开放 *代表所有</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> test1.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;jerry&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ZXyb6tPOscIwghz.png" alt="005_DCL_03.png"></p>
<ol start="3">
<li>撤销权限</li>
</ol>
<p>语法：<code>REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 撤销权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span>  test1.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;jerry&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>多个权限之间用逗号连接</li>
<li>授权时数据库名和表名可以使用 * 进行通配，代表所有。</li>
</ol>
</blockquote>
<hr>
<h2 id="函数">函数</h2>
<h3 id="字符串函数">字符串函数</h3>
<p>常见的字符串函数如下</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT(S1,S2,…Sn)</td>
<td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串str全部转为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串str全部转为大写</td>
</tr>
<tr>
<td>LPAD(str,n,pad)</td>
<td>左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td>
</tr>
<tr>
<td>RPAD(str,n,pad)</td>
<td>右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str,start,len)</td>
<td>返回从字符串str从start位置起的len个长度的字符串</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 字符串拼接</span></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;mysql&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/dG8FHazo6M5NYVI.png" alt="006_函数_01.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 大小写转换</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;HELLO&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左填充与右填充 常用于日期、编号等的数据</span></span><br><span class="line"><span class="keyword">select</span> lpad(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;-&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/Fxr3X5GZCflwDRA.png" alt="006_函数_02.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 去除空格</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27; Hello MySQL &#x27;</span>);</span><br><span class="line"><span class="comment">-- 截取字符串 注意索引从1开始</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;hello mysql&#x27;</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/tQM4f2WhCjdGkya.png" alt="006_函数_03.png"></p>
<h3 id="数值函数">数值函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回x/y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数值函数 就是编程语言中常见的函数</span></span><br><span class="line"><span class="comment">-- 向上取整，</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">1.1</span>);<span class="comment">-- 结果为2</span></span><br><span class="line"><span class="comment">-- 向下取整-即保留整数位</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">1.9</span>);</span><br><span class="line"><span class="comment">-- 取模</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">mod</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 随机数 不写默认是0-1的数</span></span><br><span class="line"><span class="keyword">select</span> rand();</span><br><span class="line"><span class="comment">-- 四舍五入+保留小数位数</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="number">2.35</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>生成一个六位数的随机验证码</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- rand函数生成0-1的随机小数</span></span><br><span class="line"><span class="keyword">select</span> lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>,<span class="number">0</span>),<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/gpo3SsexIrOJt8F.png" alt="006_函数_04.png"></p>
<h3 id="日期函数">日期函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回一个日期/时间值加上一个时间间隔expr后的 时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回起始时间date1 和 结束时间date2之间的天 数</td>
</tr>
</tbody>
</table>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 英语中date表示日期，time表示具体的时间</span></span><br><span class="line"><span class="comment">-- 当前日期</span></span><br><span class="line"><span class="keyword">select</span> curdate();</span><br><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">select</span> curtime();</span><br><span class="line"><span class="comment">-- 当前日期+时间</span></span><br><span class="line"><span class="keyword">select</span> now();</span><br><span class="line"><span class="comment">-- 年月日函数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(now());</span><br><span class="line"><span class="comment">-- “增加”时间</span></span><br><span class="line"><span class="keyword">select</span> date_add(now(),<span class="type">interval</span> <span class="number">70</span> <span class="keyword">day</span>); # 这里的意思是在当前时间<span class="operator">+</span><span class="number">70</span>天</span><br></pre></td></tr></table></figure>
<p><strong>两时间之差：第一个参数-第二个参数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求2021-07-21与1921-07-21间隔的天数</span></span><br><span class="line"><span class="keyword">select</span> datediff(<span class="string">&#x27;2021-07-21&#x27;</span>,<span class="string">&#x27;1921-07-21&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有员工的入职天数，并根据入职天数倒序排序</span></span><br><span class="line"><span class="keyword">select</span> first_name,datediff(curdate(),hire_date) <span class="keyword">as</span> <span class="string">&#x27;entrydays&#x27;</span> <span class="keyword">from</span> emps <span class="keyword">order</span> <span class="keyword">by</span> entrydays <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/3tp8Gyj2z4JYVcH.png" alt="006_函数_05.png"></p>
<h3 id="流程函数">流程函数</h3>
<blockquote>
<p>就是高级语言中的控制函数</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF(value , t , f)</td>
<td>如果value为true，则返回t，否则返回 f</td>
</tr>
<tr>
<td>IFNULL(value1 , value2)</td>
<td>如果value1不为空，返回value1，否则 返回value2</td>
</tr>
<tr>
<td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td>
<td>如果val1为true，返回res1，… 否 则返回default默认值</td>
</tr>
<tr>
<td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td>
<td>如果expr的值等于val1，返回 res1，… 否则返回default默认值</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 流程控制函数 就是编程语言中的控制函数</span></span><br><span class="line"><span class="keyword">select</span> if(<span class="literal">true</span>,<span class="string">&#x27;OK&#x27;</span>,<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line"><span class="comment">-- 判断是否为null</span></span><br><span class="line"><span class="keyword">select</span> ifnull(<span class="keyword">null</span>,<span class="string">&#x27;default&#x27;</span>);</span><br><span class="line"><span class="comment">-- 多选择分支</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    name,</span><br><span class="line">    (<span class="keyword">case</span> note <span class="keyword">when</span> <span class="string">&#x27;novel&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;小说&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;drama&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;戏剧&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;其他类型&#x27;</span><span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;图书表&#x27;</span></span><br><span class="line"><span class="keyword">from</span> books;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/gYBwr9Z78fcEhtW.png" alt="006_函数_06.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例 按照不同的工资范围给予对应员工评价</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    first_name,</span><br><span class="line">    (<span class="keyword">case</span> <span class="keyword">when</span> salary <span class="operator">&gt;=</span><span class="number">10000</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> salary <span class="operator">&gt;=</span><span class="number">6000</span> <span class="keyword">then</span> <span class="string">&#x27;还行&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;加把劲&#x27;</span> <span class="keyword">end</span>) <span class="string">&#x27;工资表&#x27;</span></span><br><span class="line"><span class="keyword">from</span> emps;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/RSnAFzK42NJxkTC.png" alt="006_函数_07.png"></p>
<hr>
<h2 id="约束-constraint">约束(constraint)</h2>
<h3 id="一般约束">一般约束</h3>
<p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段的数据不能为null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束(8.0.16版本之后)</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在创建表过程或者已经创建均可以添加约束</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span><span class="number">120</span> ) comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> comment <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"><span class="comment">-- 插入数据 主键自增不需要添加数据</span></span><br><span class="line"><span class="comment">-- 同理可以在图形化界面添加对应的约束</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">value</span> (<span class="string">&#x27;Tom1&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;男&#x27;</span>),(<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">value</span> (<span class="keyword">null</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>第12行代码异常执行，不符合约束的数据不会添加</p>
<p><img src="https://s2.loli.net/2024/11/26/bQmP2UBw3MkD5zC.png" alt="007_约束_01.png"></p>
<h3 id="外键约束">外键约束</h3>
<p>概念：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</p>
<ol>
<li>添加外键</li>
</ol>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在创建表的时候添加</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	...</span><br><span class="line">	[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在修改表的时候添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 让两张表的数据之间建立联系，从而保证数据一致</span></span><br><span class="line"><span class="comment">-- 具有外键的表成为子表，而关联的表称为父表</span></span><br><span class="line"><span class="comment">-- 准备数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">                     id   <span class="type">int</span> auto_increment comment <span class="string">&#x27;ID&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">                     name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;部门名称&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;部门表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (id, name) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;研发部&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;市场部&#x27;</span>),(<span class="number">3</span>, <span class="string">&#x27;财务部&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;销售部&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;总经办&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">                    id  <span class="type">int</span> auto_increment comment <span class="string">&#x27;ID&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">                    name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">                    age  <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">                    job <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">                    salary <span class="type">int</span> comment <span class="string">&#x27;薪资&#x27;</span>,</span><br><span class="line">                    entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">                    managerid <span class="type">int</span> comment <span class="string">&#x27;直属领导ID&#x27;</span>,</span><br><span class="line">                    dept_id <span class="type">int</span> comment <span class="string">&#x27;部门ID&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;员工表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (id, name, age, job,salary, entrydate, managerid, dept_id) <span class="keyword">VALUES</span></span><br><span class="line">                                                                               (<span class="number">1</span>, <span class="string">&#x27;金庸&#x27;</span>, <span class="number">66</span>, <span class="string">&#x27;总裁&#x27;</span>,<span class="number">20000</span>, <span class="string">&#x27;2000-01-01&#x27;</span>, <span class="keyword">null</span>,<span class="number">5</span>),(<span class="number">2</span>, <span class="string">&#x27;张无忌&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;项目经理&#x27;</span>,<span class="number">12500</span>, <span class="string">&#x27;2005-12-05&#x27;</span>, <span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">                                                                               (<span class="number">3</span>, <span class="string">&#x27;杨逍&#x27;</span>, <span class="number">33</span>, <span class="string">&#x27;开发&#x27;</span>, <span class="number">8400</span>,<span class="string">&#x27;2000-11-03&#x27;</span>, <span class="number">2</span>,<span class="number">1</span>),(<span class="number">4</span>, <span class="string">&#x27;韦一笑&#x27;</span>, <span class="number">48</span>, <span class="string">&#x27;开发&#x27;</span>,<span class="number">11000</span>, <span class="string">&#x27;2002-02-05&#x27;</span>, <span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">                                                                               (<span class="number">5</span>, <span class="string">&#x27;常遇春&#x27;</span>, <span class="number">43</span>, <span class="string">&#x27;开发&#x27;</span>,<span class="number">10500</span>, <span class="string">&#x27;2004-09-07&#x27;</span>, <span class="number">3</span>,<span class="number">1</span>),(<span class="number">6</span>, <span class="string">&#x27;小昭&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;程序员鼓励师&#x27;</span>,<span class="number">6600</span>, <span class="string">&#x27;2004-10-12&#x27;</span>, <span class="number">2</span>,<span class="number">1</span>);                                                                               </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="comment">-- 为emp表中的dept_id字段添加外键约束，关联dept表中的主键id，并将外键命名为fk_emp_dept_id</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ZKmX3cShaUJt6bC.png" alt="007_约束_02.png"></p>
<ol start="2">
<li>删除外键</li>
</ol>
<p>语法：<code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_emp_dept_id;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>删除/更新行为</li>
</ol>
<p>概念：添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为<br>
分类</p>
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NO ACTION</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td>
</tr>
</tbody>
</table>
<p>语法：<code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 外键更新 父表更新时子表也会更新</span></span><br><span class="line"><span class="comment">-- on update 后面跟cascade 表明在更新的时候首先检查该记录是否有对应外键，如果有，则更新外键在子表中的记录。</span></span><br><span class="line"><span class="comment">-- on delete 后面跟cascade 表明在删除的时候首先检查该记录是否有对应外键，如果有，则删除外键在子表中的记录。</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在一般的业务系统中，一般不会 修改一张表的主键值</p>
</blockquote>
<hr>
<h2 id="多表查询">多表查询</h2>
<p>概念:从多张表中查询数据</p>
<h3 id="多表关系">多表关系</h3>
<p>分类</p>
<ul>
<li>一对多（多对一）</li>
<li>多对多</li>
<li>一对一</li>
</ul>
<p>示例：<strong>多对多</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表之间的联系，一对一，一对多(多对一),多对多</span></span><br><span class="line"><span class="comment">-- 一对多(一个部门对应多个员工，一个员工对应一个部门)</span></span><br><span class="line"><span class="comment">-- 多对多(比如学生与课程)</span></span><br><span class="line"><span class="comment">-- 一对一常用于单表拆分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多对多演示</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">                        id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">                        name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">                        <span class="keyword">no</span> <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;学号&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> (<span class="keyword">null</span>, <span class="string">&#x27;黛绮丝&#x27;</span>, <span class="string">&#x27;2000100101&#x27;</span>),(<span class="keyword">null</span>, <span class="string">&#x27;谢逊&#x27;</span>, <span class="string">&#x27;2000100102&#x27;</span>),(<span class="keyword">null</span>, <span class="string">&#x27;殷天正&#x27;</span>, <span class="string">&#x27;2000100103&#x27;</span>),(<span class="keyword">null</span>, <span class="string">&#x27;韦一笑&#x27;</span>, <span class="string">&#x27;2000100104&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">                       id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">                       name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;课程名称&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;课程表&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span> (<span class="keyword">null</span>, <span class="string">&#x27;Java&#x27;</span>), (<span class="keyword">null</span>, <span class="string">&#x27;PHP&#x27;</span>), (<span class="keyword">null</span> , <span class="string">&#x27;MySQL&#x27;</span>) , (<span class="keyword">null</span>, <span class="string">&#x27;Hadoop&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_course(</span><br><span class="line">                               id <span class="type">int</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">                               studentid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生ID&#x27;</span>,</span><br><span class="line">                               courseid  <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">                               <span class="keyword">constraint</span> fk_courseid <span class="keyword">foreign</span> key (courseid) <span class="keyword">references</span> course (id),</span><br><span class="line">                               <span class="keyword">constraint</span> fk_studentid <span class="keyword">foreign</span> key (studentid) <span class="keyword">references</span> student (id)</span><br><span class="line">)comment <span class="string">&#x27;学生课程中间表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/8rdb7htSDO1QImg.png" alt="008_多表查询_01.png"></p>
<p>右键表-‘图表’-‘显示可视化’</p>
<p><img src="https://s2.loli.net/2024/11/26/jSLElGYd5wg9y73.png" alt="008_多表查询_02.png"></p>
<h3 id="多表查询-2">多表查询</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 多表查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1.emp,dept;<span class="comment">-- 这样写出来的多表查询是笛卡尔积，考过计算机二级的同学应该学过</span></span><br></pre></td></tr></table></figure>
<p>简单来说，就是集合A与集合B的所有组合情况,显然这不是我们想要呈现的数据，消除笛卡尔积的方法就是让多个表以某种关系式连接起来(比如id相等)</p>
<p>笛卡尔积部分演示</p>
<p><img src="https://s2.loli.net/2024/11/26/ADj2WU5ZwXTGs97.png" alt="008_多表查询_03.png"></p>
<p>数学图演示</p>
<p><img src="https://s2.loli.net/2024/11/26/1UgqCXBSIoQndyP.png" alt="008_多表查询_04.png"></p>
<p>而我们不需要所有的组合情况，只需要按照一定的条件将多余的组合情况排除即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 消除笛卡尔积</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1.emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure>
<p>消除笛卡尔积之后</p>
<p><img src="https://s2.loli.net/2024/11/26/osut6nkyZ9SWpEr.png" alt="008_多表查询_05.png"></p>
<h3 id="连接分类">连接分类</h3>
<h4 id="内连接">内连接</h4>
<p>补图：用chartjs以韦恩图的形式展现连接</p>
<p>概念：就是求两张表的交集</p>
<ol>
<li>隐式内连接</li>
</ol>
<p>语法：<code>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 内、外、自连接(和集合中的概念相似)，子查询</span></span><br><span class="line"><span class="comment">-- 内连接-查找两个表之间的交集</span></span><br><span class="line"><span class="comment">-- 隐式内连接(没有直接写inner join) 从两张表中找到id相同的并展示其在不同表的名字</span></span><br><span class="line"><span class="keyword">select</span> emp.name,dept.name <span class="keyword">from</span> test1.emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 可以取别名缩短语句长度</span></span><br><span class="line"><span class="keyword">select</span> e.name,d.name <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/MuqJIPXTa5sWZ1z.png" alt="008_多表查询_06.png"></p>
<ol start="2">
<li>显式内连接</li>
</ol>
<p>语法：<code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 显示内连接,就是通过inner join实现</span></span><br><span class="line"><span class="keyword">select</span> e.name,d.name <span class="keyword">from</span> emp e <span class="keyword">inner</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
<p><strong>表的别名语法</strong></p>
<ol>
<li><code>tablea as 别名1 , tableb as 别名2;</code></li>
<li><code>tablea 别名1 , tableb 别名2; </code></li>
</ol>
<p>注意：<strong>一旦为表起了别名，就不能再使用表名来指定对应的字段</strong>了，此时只能够使用别名来指定字段。</p>
<h4 id="外连接">外连接</h4>
<p>就是两表的交集+其中一个表,比如</p>
<ol>
<li>左外连接 A+AUB</li>
</ol>
<p>语法：<code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;  </code> 就是关键字<strong>left join</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左外连接-相当于表1+表1与表2的交集，右连接同理</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.name <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/AMRSQwj8co3EylU.png" alt="008_多表查询_07.png"></p>
<ol start="2">
<li>右外连接 AUB+B</li>
</ol>
<p>语法：<code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;  </code>就是关键字<strong>right join</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>,e.<span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/VYXqrTbgJil4Sja.png" alt="008_多表查询_08.png"></p>
<blockquote>
<p>左右外连接理论上是可以相互替换和相互转换的，不过一般左外连接用的多。</p>
</blockquote>
<h4 id="自连接">自连接</h4>
<p>将表自身看做是另一张表，然后将两表连接<br>
语法：<code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;  </code></p>
<p>自连接可以是内连接也可以是外连接</p>
<p>示意图</p>
<p><img src="https://s2.loli.net/2024/11/26/VsB1neoXZOrH7iq.png" alt="008_多表查询_09.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 其实就是把自己看做是两张表进行连接 不过需要取别名否则会产生歧义</span></span><br><span class="line"><span class="keyword">select</span> a.name,b.name <span class="keyword">from</span> emp a,emp b <span class="keyword">where</span> a.managerid <span class="operator">=</span> b.id;</span><br><span class="line"><span class="keyword">select</span> a.name,b.name <span class="keyword">from</span> emp a <span class="keyword">left</span> <span class="keyword">join</span> emp b <span class="keyword">on</span> a.managerid <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/DSmIfrxGZyH1v5e.png" alt="008_多表查询_10.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/NpHh89GnyTPslIi.png" alt="008_多表查询_11.png"></p>
<blockquote>
<p>在自连接查询时必须取别名，否则会有歧义导致无法运行</p>
</blockquote>
<h4 id="联合查询">联合查询</h4>
<p>概念：就是把多次查询的结果合并起来，形成一个新的查询结果集</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [ <span class="keyword">ALL</span> ]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ....;</span><br></pre></td></tr></table></figure>
<ol>
<li>联合的表列数和字段类型必须保持一致</li>
<li>用all会将所有的数据合在一起，而不用all就会<strong>去重</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 联合查询</span></span><br><span class="line"><span class="comment">-- 相当于将查询得到的两张表上下拼起来</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span><span class="number">6000</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">50</span>;</span><br><span class="line"><span class="comment">-- 如果要去重，就不写all</span></span><br><span class="line"><span class="comment">-- 注意：查询的多张表列数要一致，字段类型要保持一致</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/4fFzeprCS7JdHh1.png" alt="008_多表查询_12.png"></p>
<p>这里的联合查询就是将两张表上下拼接的</p>
<h4 id="子查询">子查询</h4>
<p>概念：就是sql语句中嵌套select语句，也就是将select查询出的结果作为另一个sql语句的参数</p>
<p>示例：<code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );  </code></p>
<ol>
<li>标量子查询（子查询结果为单个值）</li>
</ol>
<p>常见的操作符：<code>= &lt;&gt; &gt; &gt;= &lt; &lt;=  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 子查询-又称嵌套查询</span></span><br><span class="line"><span class="comment">-- 把表看做是矩阵，就容易理解查询的结果</span></span><br><span class="line"><span class="comment">-- 标量子查询</span></span><br><span class="line"><span class="comment">-- select id from dept where name = &#x27;研发部&#x27;查询结果只有一个，称为标量子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;总经办&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> (<span class="keyword">select</span> entrydate <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;杨逍&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/sBlcqELTJZ6pKwb.png" alt="008_多表查询_13.png"></p>
<ol start="2">
<li>列子查询(子查询结果为一列)</li>
</ol>
<p>操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN</td>
<td>在指定的集合范围之内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定的集合范围之内</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>ANY</td>
<td>子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与ANY等同，使用SOME的地方都可以使用ANY</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列查询</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name  <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 比研发部所有人工资还要高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br><span class="line"><span class="comment">-- 比研发部任意一个人工资高的员工信息,用any和some都行</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/NAmWyOZJdFK9R3I.png" alt="008_多表查询_14.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/4tfWYH3PqxF1UQu.png" alt="008_多表查询_15.png"></p>
<ol start="3">
<li>行子查询(子查询结果为一行)</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 其实就是查询出来的多个字段作为另一个查询语句的条件</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;韦一笑&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/VYLNzSaIAylwvkZ.png" alt="008_多表查询_16.png"></p>
<ol start="4">
<li>表子查询(子查询结果为多行多列)</li>
</ol>
<p>关键字：<strong>in</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将查询出来的表作为范围继续查找</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary) <span class="keyword">in</span> (<span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;韦一笑&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/dYVlEfNDZ6hqtgM.png" alt="008_多表查询_17.png"></p>
<hr>
<h2 id="事务">事务</h2>
<p>概念：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。  常用于银行转账、贸易等。</p>
<p>注意：<strong>默认MySQL的事务是自动提交的</strong>，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。  用git来比喻的话就是当你执行一段DML语句之后，会将数据“add”，而由于MySQL默认提交事务，“add“的同时又”commit“了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一组操作的集合，“同患难共享福”，</span></span><br><span class="line"><span class="comment">-- 数据准备</span></span><br><span class="line"><span class="comment">-- 数据准备</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">                        id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">                        name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">                        money <span class="type">int</span> comment <span class="string">&#x27;余额&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;账户表&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(id, name, money) <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">2000</span>),(<span class="keyword">null</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="comment">-- 转账事务</span></span><br><span class="line"><span class="comment">-- 设置事务为自动提交 在MySQL中事务是自动提交的</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="comment">-- 设置事务为手动提交</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 转账操作 (张三给李四转账1000)</span></span><br><span class="line"><span class="comment">-- 1. 查询张三账户余额</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2. 将张三账户余额-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3. 将李四账户余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="comment">-- 也就是将事务放在set和commit语句之间(事务为手动提交时);</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务 </span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="comment">-- 恢复数据</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> <span class="number">2000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>事务正常运行的情况</p>
<p><img src="https://s2.loli.net/2024/11/26/sGg6tyENAzTrVQb.png" alt="009_事务_01.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/N79X1Z2woWJuHFh.png" alt="009_事务_02.png"></p>
<p>事务异常执行的情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第二种创建事务的方法</span></span><br><span class="line"><span class="comment">-- 转账操作 (张三给李四转账1000)</span></span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="comment">-- 1. 查询张三账户余额</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2. 将张三账户余额-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line">程序执行报错 ...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 将李四账户余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/HS3K1jQyLCqbaNJ.png" alt="009_事务_03.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/NztM1BFCqLldk32.png" alt="009_事务_04.png"></p>
<h4 id="控制事务">控制事务</h4>
<ol>
<li>开启事务</li>
</ol>
<p>语法：<code>START TRANSACTION 或 BEGIN ;  </code></p>
<ol start="2">
<li>查看/设置事务的提交方式</li>
</ol>
<p>语法：<code>SELECT @@autocommit ;  </code> 自动提交，或者是<code>SET @@autocommit = 0 ;</code>手动提交</p>
<ol start="3">
<li>提交事务</li>
</ol>
<p>语法：<code>COMIT</code> 如果是自动提交就不需要写,如果更改为手动提交，那么后面的sql语句要想修改数据必须运行此代码。</p>
<ol start="4">
<li>回滚事务</li>
</ol>
<p>语法：<code>ROLLBACK</code>;</p>
<h4 id="事务的特性">事务的特性</h4>
<p>四大特性</p>
<ol>
<li>
<p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p>
</li>
<li>
<p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p>
</li>
<li>
<p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p>
</li>
<li>
<p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p>
</li>
</ol>
<p>上述就是事务的四大特性，简称<strong>ACID</strong>。</p>
<h4 id="并发事务问题">并发事务问题</h4>
<p>补充示意图</p>
<ol>
<li>脏读：一个事务读到另外一个事务还没有提交的数据</li>
<li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</li>
<li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</li>
</ol>
<h4 id="事务隔离级别">事务隔离级别</h4>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<ol>
<li>查看事务隔离级别</li>
</ol>
<p>语法：<code>SELECT @@TRANSACTION_ISOLATION;  </code></p>
<p><img src="https://s2.loli.net/2024/11/26/AYSl1biIwhNH5Xy.png" alt="009_事务_05.png"></p>
<ol start="2">
<li>设置事务隔离级别</li>
</ol>
<p>语法：<code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;  </code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/D4Jdx58CovbzAM6.png" alt="009_事务_06.png"></p>
<blockquote>
<p>事务隔离级别越高，数据越安全，但是性能越低。</p>
</blockquote>
<p><strong>至此基础篇完结</strong></p>
<p>学习完之后可以参考此进阶篇学习</p>
<ol class="series-items"><li><a href="/2024/10/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%AF%87/" title="MySQL学习笔记(一)基础篇">MySQL学习笔记(一)基础篇</a></li><li><a href="/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/" title="MySQL学习笔记(二)进阶篇">MySQL学习笔记(二)进阶篇</a></li></ol>
<h1>参考</h1>
<p><strong>视频教程</strong></p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=2&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">黑马程序员</a></li>
<li><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?vd_source=bb8dacb993f11c0e39f8147c98a2894c">尚硅谷</a></li>
</ol>
<p><strong>笔记参考</strong></p>
<ol>
<li>在浏览器上搜索“黑马程序员”进入官网，然后点击免费教程-“搜索mysql”，下载对应文件</li>
<li><a href="https://jimhackking.github.io/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more">MySQL学习笔记 | 智云知识</a></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客系列(二)博客创建指南</title>
    <url>/2024/06/12/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%BA%8C)%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1>简介</h1>
<p>Hexo 是一个由Nodejs驱动的博客框架，支持 Markdown、一键部署、插件和多种模板引擎。Hexo 可以让你轻松创建、管理和部署你的个人或团队博客。本文基于个人的实践经验，<strong>以Windows为主要开发环境</strong>，旨在让那些对博客搭建感兴趣但碍于困难的朋友能搭建起基本的博客框架。</p>
<h1>准备工作</h1>
<h2 id="课前提醒——主要是针对非程序员">课前提醒——主要是针对非程序员</h2>
<p><strong>大部分的操作、代码输入</strong>都是在<strong>Windows</strong>系统<strong>终端</strong>中执行的。</p>
<p><strong>方法</strong>：点击开始-搜索“终端”-打开，或者在任意文件夹中“右键”-“在终端中打开”。会出现黑色的框。后续大部分代码都是在这“黑框”中输入且执行的。</p>
<p><img src="https://s2.loli.net/2024/11/26/2q15iMDwhdxRHPb.png" alt="博客创建指南01"></p>
<ul>
<li>代码块没有标明代码语言的都是在Windows终端中运行的。mac系统和linux系统相关指令请查询有关资料</li>
<li>默认电脑下载了git和注册了github。没有注册github和下载git的可以看这个<a href="https://www.bilibili.com/video/BV1o5411j7up/?buvid=XY8FE9283F9E25662FCF4765F2CEBCB3B2141&amp;from_spmid=main.space-search.0.0&amp;is_story_h5=false&amp;mid=ueF2Y5ca46qLJ%2B0TtsIVXA%3D%3D&amp;p=2&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=26f5f2ef-15df-4762-87af-a60e30f96419&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1718194497&amp;unique_k=7ayW8ON&amp;up_id=456828781&amp;vd_source=9d7958a1b86a1d76c255b26c5fa353b7">github入门及如何提交代码-清晰版本_哔哩哔哩_bilibili</a></li>
<li>默认会“科学上网”，不会的可以参考此大佬的教程<a href="https://mubu.com/doc/5OeZGO2XKgh">搭建个人博客网站 - 幕布 (mubu.com)</a>，可以在他的博客中搜索&quot;搭建个人博客“   <a href="https://starlike-daydream.github.io/Cesteo.github.io/">Ceasteo’s Blog</a>。按照此大佬的方法也可以实现简单的hexo博客创建。<strong>注意大佬文档中的淘宝镜像已经失效,请换成</strong><code>https://registry.npmmirror.com</code></li>
</ul>
<h2 id="相关资料下载">相关资料下载</h2>
<ol>
<li><a href="https://nodejs.cn/">Node.js 中文网 (nodejs.cn)</a>安装，进去后点击下载安装，选择长期支持版（LTS）即可</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/BZNOMvsk15YIKr8.png" alt="博客创建指南02"></p>
<ol start="2">
<li>安装cnpm并配置淘宝镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/J9FsPLaTqZ1Ygb8.png" alt="博客创建指南03"></p>
<blockquote>
<p><strong>注意</strong>：后面代码中我打//并且后面跟着文字的（比如//这里是初始化)都是<strong>注释</strong>，<strong>不要写在终端里面</strong></p>
</blockquote>
<ol start="3">
<li>测试cnpm是否安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm -v   </span><br></pre></td></tr></table></figure>
<p><strong>v</strong>：version 版本的意思</p>
<ol start="4">
<li>安装hexo博客框架</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>测试hexo博客框架是否安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<h2 id="初始化博客">初始化博客</h2>
<blockquote>
<p>后续可以通过blog文件(<strong>shift+鼠标右键-在终端中打开</strong>）直接进入终端，也可以用Visual Studio Code将此文件打开并创建终端（建议使用vscode，后续博客维护很方便）。</p>
</blockquote>
<ol start="6">
<li>在空文件夹（我这里事先创建并将其命名为temp)中初始化hexo博客框架,然后通过cd指令进入此目录。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//示例：cd .\Desktop\temp\</span><br><span class="line">hexo init</span><br><span class="line">//如果报错的话就输入cnpm install 然后再输入hexo s即可</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>启动博客  start   用来预览修改后的博客 按ctrl+c即可停止运行。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>清除博客内容</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean  //或者hexo cl</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>生成博客内容</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h2 id="部署">部署</h2>
<p><strong>我这里只讲解部署到github的思路</strong>，部署到其他平台或者服务器请自行查询有关资料。没有注册github和git的可以看这个<a href="https://www.bilibili.com/video/BV1o5411j7up/?buvid=XY8FE9283F9E25662FCF4765F2CEBCB3B2141&amp;from_spmid=main.space-search.0.0&amp;is_story_h5=false&amp;mid=ueF2Y5ca46qLJ%2B0TtsIVXA%3D%3D&amp;p=2&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=26f5f2ef-15df-4762-87af-a60e30f96419&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1718194497&amp;unique_k=7ayW8ON&amp;up_id=456828781&amp;vd_source=9d7958a1b86a1d76c255b26c5fa353b7">github入门及如何提交代码-清晰版本_哔哩哔哩_bilibili</a></p>
<ol start="10">
<li>github创建仓库,注意格式严格为<code>你的github用户名.github.io</code> 并复制SSH的clone地址，我这里以Tom为例</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/Ju7GXhRZjFKTbSQ.png" alt="博客创建指南04"></p>
<ol start="11">
<li>安装部署插件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<ol start="12">
<li>修改_config.yml文件</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/ij6X1BzdSGuLOnm.png" alt="博客创建指南05"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//一般是最后一行。</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">粘贴你10步复制的地址。</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<ol start="13">
<li>部署到github</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<ol start="14">
<li>
<p>13步后有的会提示输入github账号密码，没有就跳过14和15步</p>
</li>
<li>
<p>分别输入用户名与密码。</p>
</li>
</ol>
<p>输入密码之后报错并<strong>提醒你github已经停止使用密码登录</strong>，需要用密钥或者是ssh，这里我采用ssh的方式。</p>
<ol start="16">
<li>初始化用户名与邮箱(“yourname”和”youremail“改成你之前注册github设置的)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot; //（注意user.name/email和英文双引号&quot;之间要有一个空格）</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<ol start="17">
<li>确认是否设置成功</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//用户名与邮箱</span><br><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>
<ol start="18">
<li>下载github部署插件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol start="19">
<li>本地生成密钥</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;（这里改为16步你设置的邮箱）</span><br></pre></td></tr></table></figure>
<ol start="20">
<li>获取你生成的密钥，并复制返回的结果</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<ol start="21">
<li>
<p><strong>登录github</strong>, 点击头像——settings——点击SSH and GPG keys-再点击New SSH key,自己取一个标题,然后将复制的密钥粘贴到&quot;key&quot;文本框内并提交（Add SSH key)。</p>
</li>
<li>
<p>验证：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<ol start="23">
<li>再次提交</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<ol start="24">
<li>运行并检验是否成功</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s   //或者在浏览器URL栏输入“你的github用户名.github.io”，验证是否已经部署。</span><br></pre></td></tr></table></figure>
<p>至此你已经成功部署一个简单的hexo博客，恭喜你我的朋友(^o^)/~，<strong>但这只是伟大征程的第一步，这是结束也是开始</strong>……</p>
<h1>博客维护</h1>
<h2 id="基础指令">基础指令</h2>
<p>主题、文章修改之后要重新生成并部署。<br>
简单讲解：</p>
<ol>
<li><code>hexo cl</code> 将之前上传的清除</li>
<li><code>hexo g</code> 生成框架</li>
<li><code>hexo s</code> 将其打开在主机上</li>
<li><code>hexo d</code> 提交到github上</li>
</ol>
<blockquote>
<p>总结：<strong>最重要的是第2,4个代码（部分插件使用需要第一个代码，这样通过你的用户名.github.io打开的博客才会更改。</strong></p>
</blockquote>
<h2 id="md文件">md文件</h2>
<p><strong>命令行创建md文件</strong><br>
<code>hexo n &quot;博客文章名&quot;</code>， <strong>必须先进入到文件中才能使用</strong>，会自动在 你所创建的文件夹\source_posts\博客文件名.md  路径下创建一个md文件。</p>
<p><strong>md文件保存位置</strong><br>
一般就在/_ posts 文件下创建md文件即可（或者把md文件移动到这里），要在开头加上如下语句即可.<strong>注意冒号后面要留空格</strong></p>
<p><strong>示例格式如下</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;! -- 这里是html的注释 写的时候不要添加 - - &gt;</span><br><span class="line">title: 我的第一篇博客文章</span><br><span class="line">date: 2024-06-01  19:10:34</span><br><span class="line">tags: C++</span><br><span class="line">no<span class="emphasis">_valine: true&lt;!- - 关闭评论- - &gt;</span></span><br><span class="line"><span class="emphasis">comments: 是否开启评论(true or false)</span></span><br><span class="line"><span class="emphasis">top: &lt;!- - 文章置顶true- - &gt;</span></span><br><span class="line"><span class="emphasis">no_</span>word<span class="emphasis">_count: true&lt;!- -关闭字数统计- - &gt;</span></span><br><span class="line"><span class="emphasis">password: &lt;! - -如果加密，这里填写密码 - - &gt;</span></span><br><span class="line"><span class="emphasis">reward: true&lt;!- - 当前文章是否开启打赏 - - &gt;</span></span><br><span class="line"><span class="emphasis">copyright: true&lt;!- - 当前文章是否开启版权声明 - - &gt;</span></span><br><span class="line"><span class="emphasis">categories: &lt;! - -如下，分类2是分类1的子分类- - &gt;</span></span><br><span class="line"><span class="emphasis">- [分类1，子分类1]</span></span><br><span class="line"><span class="emphasis">- [分类1，子分类2]</span></span><br><span class="line"><span class="emphasis">- [分类2]</span></span><br><span class="line"><span class="emphasis">tags: </span></span><br><span class="line"><span class="emphasis">- 标签1</span></span><br><span class="line"><span class="emphasis">- 标签2</span></span><br></pre></td></tr></table></figure>
<h2 id="插件下载与使用">插件下载与使用</h2>
<p><strong>提醒：少即是多, 避免华而不实。</strong></p>
<p>打开官方文档<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a>，点击插件，点击中意的插件，按照作者的教程去配置插件</p>
<p><strong>举例</strong><br>
<strong>DPlayer插件</strong></p>
<p><strong>播放代码</strong><br>
<code>&#123;% dplayer "url=" "pic=" "theme=#FADFA3" "autoplay=false" "mutex=true" %&#125;</code></p>
<p><strong>示例</strong><br>
打开对应视频资源网页版（这里以b站为例），鼠标移动到分享-“嵌入代码”，将代码复制到md文件里面，如果需要调整大小，可添加<code>height=450 width=600</code> ,根据需要调整即可</p>
<h2 id="主题的下载与使用">主题的下载与使用</h2>
<p><strong>安装思路同插件</strong><br>
注意在themes界面中可以点击“visit preview site”预览主题。</p>
<ol>
<li>看作者介绍如何安装，一步步安装  ，复杂一点的主题还有一系列插件安装</li>
<li>打开根目录下的_config.yml  将theme: 以前的主题 改为 theme: 现在的主题</li>
<li>后续的改动都是要基于作者文档。熟悉前端开发的朋友可以用“<strong>检查</strong>“了解作者网页的结构，然后自行修改</li>
</ol>
<p><strong>推荐主题</strong>：</p>
<ul>
<li>极简风格：
<ul>
<li>yilia-plus：<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus">一个简洁优雅的hexo主题</a></li>
</ul>
</li>
<li>优雅又实用：
<ul>
<li>butterfly：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></li>
<li>matery：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery/README_CN.md</a></li>
</ul>
</li>
</ul>
<h1>Hexo进阶-butterfly主题安装及其定制化</h1>
<blockquote>
<p>我目前安装的是5.1.0版本的。</p>
</blockquote>
<p>虽然主菜单栏里面可以分成多个子菜单，但是似乎每一个子菜单只能放一个md文件，所以<u>建议此md文件作为某一类型的东西的索引来呈现。</u></p>
<p>所有的博客md文件都需要放在_post文件夹里面，其他地方大多只能放索引md文件。<strong>建议使用</strong><code>hexo n post 标题名</code> ,这样就会<strong>自动将对应的文件夹也生成</strong>。</p>
<p>建议修改的使用经常使用Hexo s命令，修改无误之后再提交。</p>
<p><strong>To be continue……</strong></p>
<hr>
<h1>总结</h1>
<p>本篇文章主要侧重于基础的hexo博客搭建，至于进阶的hexo主题搭建和插件安装，限于笔者能力难以展开，有兴趣的读者可以去官方文档找对应的资料，按照作者的文档去安装。</p>
<h1>结束语</h1>
<p>有的朋友会说这也太难了吧，确实对于零基础的小白配置一个复杂的博客主题绝非易事，但是我想用王安石的一句话共勉想要变得更强、超越自我的朋友。<br>
<strong>“而世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕之焉，故非有志者不能之也。”</strong></p>
<h1>参考资料</h1>
<ol>
<li><strong>官方网站</strong>：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li>
<li><strong>其他人的教程</strong>：<a href="https://mubu.com/doc/5OeZGO2XKgh">搭建个人博客网站 - 幕布 (mubu.com)</a></li>
<li>git和github<strong>下载和使用</strong>：<a href="https://www.bilibili.com/video/BV1o5411j7up/?buvid=XY8FE9283F9E25662FCF4765F2CEBCB3B2141&amp;from_spmid=main.space-search.0.0&amp;is_story_h5=false&amp;mid=ueF2Y5ca46qLJ%2B0TtsIVXA%3D%3D&amp;p=2&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=26f5f2ef-15df-4762-87af-a60e30f96419&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1718194497&amp;unique_k=7ayW8ON&amp;up_id=456828781&amp;vd_source=9d7958a1b86a1d76c255b26c5fa353b7">github入门及如何提交代码-清晰版本_哔哩哔哩_bilibili</a></li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>《高质量C、C++》笔记整理</title>
    <url>/2024/06/25/%E3%80%8A%E9%AB%98%E8%B4%A8%E9%87%8FC%E3%80%81C++%E3%80%8B%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>本文章会随着编程能力的提高和思维的扩展不断更新,目前是1.0版本    2024/6/25</p>
</blockquote>
<h1>简介</h1>
<p>本书以高质量编写C/C++代码为主题，在代码风格等方面列举了常见的规则和示例，旨在帮助读者写出风格统一的、可读性强的、易于维护的代码。</p>
<h1>代码风格</h1>
<blockquote>
<p>什么是优秀的、高质量的代码?</p>
</blockquote>
<ul>
<li>优秀的编程风格</li>
<li>有出错处理</li>
<li>算法复杂度分析</li>
</ul>
<h2 id="文章结构">文章结构</h2>
<h3 id="版权与版本的声明">版权与版本的声明</h3>
<p><strong>版权和版本的声明</strong>:<br>
位于<strong>头文件</strong>(.h)和<strong>定义文件</strong>(.cpp或者.c)的开头,主要内容有：</p>
<ul>
<li>版权信息.</li>
<li>文件名称,标识符,摘要.</li>
<li>当前版本号,作者/修改者,完成日期.</li>
<li>版本历史信息.</li>
</ul>
<p><strong>示例1-1</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Copyright(c)200l,上海贝尔有限公司网络应用事业部</span></span><br><span class="line"><span class="comment">* All rights reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 文件名称：filename.h</span></span><br><span class="line"><span class="comment">* 文件标识：见配置管理计划书</span></span><br><span class="line"><span class="comment">* 摘　要：简要描述本文件的内容</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 当前版本：1.1</span></span><br><span class="line"><span class="comment">* 作者：输入作者(或修改者)名字</span></span><br><span class="line"><span class="comment">*完成日期：2001年7月20日</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 取代版本：1.0</span></span><br><span class="line"><span class="comment">＊原作者：输入原作者(或修改者)名字</span></span><br><span class="line"><span class="comment">* 完成日期：2001年5月10日</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="头文件的结构">头文件的结构</h3>
<ul>
<li>头文件开头处的版权和版本声明(参见示例1-1).</li>
<li>预处理块.</li>
<li>函数和类结构声明等.</li>
</ul>
<p><strong>规则</strong>;</p>
<ol>
<li>&lt;&gt;导入标准库的头文件,“” 导入非标准库的头文件</li>
<li>头文件只存放<strong>声明</strong>而不放<strong>定义</strong></li>
</ol>
<p><strong>示例1-2</strong> 使用ifndef</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设头文件名称为graphics.h</span></span><br><span class="line"><span class="comment">//版权和版本声明见示例1-1,此处省略.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GRAPHICS_H ∥防止graphics.h被重复引用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRAPHICS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> ∥引用标准库的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> ∥引用非标准库的头文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Functionl</span><span class="params">()</span></span>;<span class="comment">//全局函数声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> <span class="comment">//类结构声明</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>特点：能跨平台,但是编译时间较长,而且一旦宏名重复就会“不知所措“</p>
<p><strong>示例1-2</strong>  使用#pragma once</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>特点：编译时间短,但是难以跨平台.</p>
<h3 id="定义文件的结构">定义文件的结构</h3>
<ul>
<li>定义文件开头处的版权和版本声明(参见示例1-1).</li>
<li>对一些头文件的引用.</li>
<li>程序的实现体(包括数据和代码).<br>
假设定义文件的名称为graphics.cpp,定义文件的结构参见示例1-3.</li>
</ul>
<p><strong>示例1-3</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版权和版本声明见示例1-1,此处省略.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>“graphics.h”∥引用头文件</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">//全局函数的实现体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Functionl</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类成员函数的实现体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::Draw</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目录结构">目录结构</h3>
<p>如果一个软件的头文件数目比较多(如超过十个),通常应将头文件和定义文件分别保存于不同的目录,以便于维护.例如可将头文件保存于include目录,将定义文件保存于source目录(可以是多级目录).</p>
<h2 id="程序的版式">程序的版式</h2>
<h3 id="空行">空行</h3>
<p><strong>适当留空行保持呼吸感</strong></p>
<p><strong>规则</strong>:</p>
<ul>
<li>在每个类声明之后、每个函数定义结束之后都要加空行.</li>
<li>在一个函数体内,逻揖上密切相关的语句之间不加空行,其它地方应加空行分隔.参见示例2-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑连续,不空行</span></span><br><span class="line"><span class="type">int</span> ii = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;typeid(int)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="type">int</span>).<span class="built_in">name</span>() &lt;&lt; endl,</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;typeid(ii)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(ii).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数,前后逻辑不相连,空行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">power</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码行">代码行</h3>
<p><strong>规则</strong></p>
<ul>
<li><strong>一行代码只做一件事情</strong>,如只定义一个变量,或只写一条语句.这样的代码容易阅读,并且方便于写注释.</li>
<li>if、for、while、do等语句自占一行,执行语句不得紧跟其后.<strong>不论执行语句有多少都要加{}</strong>.这样可以防止书写失误.</li>
<li>尽可能<strong>定义变量的同时初始化该变量</strong>.</li>
</ul>
<blockquote>
<p><strong>总而言之一句话,不要一行就写完</strong></p>
</blockquote>
<p><strong>示例2-2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在定义变量的同时初始化变量</span></span><br><span class="line"><span class="type">int</span> width = <span class="number">10</span>;<span class="comment">//宽度</span></span><br><span class="line"><span class="type">int</span> height = <span class="number">20</span>;<span class="comment">//高度</span></span><br><span class="line"><span class="type">int</span> depth = <span class="number">30</span>;<span class="comment">//深度</span></span><br><span class="line"><span class="comment">//不要写成int width,height,depth;</span></span><br><span class="line"></span><br><span class="line">x  = a +b;</span><br><span class="line">y = c + d;</span><br><span class="line">z = e - f;</span><br><span class="line"><span class="comment">//不要一行就写完</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (width &lt; height)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dosomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不要写成 if() dosomething</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (initialization;condition;update)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dosomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空行</span></span><br><span class="line"><span class="built_in">other</span>();</span><br></pre></td></tr></table></figure>
<h3 id="代码行内的空格">代码行内的空格</h3>
<ul>
<li>关键字之后要留空格.象const、virtual、inline、case等关键字之后至少要留一个空格(不留空格一般会报错),否则无法辨析关键字.<strong>象if、for、while等关键字之后应留一个空格</strong>再跟左括号‘(’,以突出关键字.</li>
<li><strong>函数名之后不要留空格</strong></li>
<li>‘(’向后紧跟,<strong>‘)’、‘,’、’‘;’向前紧跟</strong>,紧跟处不留空格.</li>
<li>‘,’之后要留空格,如Function(x,y,z).如果‘;’不是一行的结束符号,其后要留空格,如for(initialization; condition; update).</li>
<li>赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符,如“=”、“+=”“&gt;=”、“&lt;=”、“+”、“*”、“%”、“&amp;&amp;”、“‖”、“&lt;”,“Λ”等二元操作符的前后应当加空格.(在VS等编译器会自动格式化,但是也要养成良好的习惯)</li>
<li>一元操作符如“”！“~”、“++”、“–”、“&amp;”(地址运算符)等前后不加空格.</li>
<li>象“[]”、“.”、“-&gt;”这类操作符前后不加空格.</li>
<li>对于表达式比较长的for语句和if语句,为了紧凑起见可以适当地去掉一些空格,如for(i=0;i&lt;10;i++)和if(a&lt;=b)&amp;&amp;(c&lt;=d)</li>
</ul>
<p>也就是说：<strong>在有大量操作符或者是关键字的情况下留空格避免过于紧凑</strong>.对于需要紧凑的符号就不要留空(比如&amp;,this等)</p>
<p><strong>示例</strong> 以下皆为优良代码风格</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funcl</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year &gt;= <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((a&gt;=b) &amp;&amp; (c&lt;=d))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">x = a &lt; b ? a : b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *x = &amp;y;</span><br><span class="line"></span><br><span class="line">array[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">Function</span>();</span><br></pre></td></tr></table></figure>
<h3 id="对齐">对齐</h3>
<p><strong>规则简单来说就是{}单独占一行并且同一级的要对齐</strong>.</p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;will make America great again&quot;</span>&lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="长行拆分">长行拆分</h3>
<ul>
<li>一行最多70-80字</li>
<li>拆分时将操作符放在首位,要缩进排版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((very_longer_variablel &gt;very_longer_variablel2)</span><br><span class="line">	&amp;&amp;(very_longer_variable3 &lt;very_longer_variablel4)</span><br><span class="line">	&amp;(very_longer_variable5 &lt;very_longer_variablel6))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dosomething</span>(first_name,</span><br><span class="line">		    last_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修饰符的位置">修饰符的位置</h3>
<p>主要是解决多个变量定义时的歧义问题</p>
<p>规则:*与&amp;紧靠变量名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> *x,y;<span class="comment">//y不会误解为指针</span></span><br><span class="line"><span class="type">int</span>* x,y;<span class="comment">//y有可能被误解为指针.</span></span><br></pre></td></tr></table></figure>
<h3 id="注释">注释</h3>
<p><strong>规则</strong></p>
<ul>
<li>一行用//,多行用/ * * /</li>
<li>注释不是文档,需要的时候才加上</li>
<li>边写代码边注释,注意更新</li>
<li>注释要写在所解释的代码的上方或者右方</li>
<li>较长的代码要在结尾处指明是谁的结束.</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> ()</span><br><span class="line">	&#125;<span class="comment">//end of while</span></span><br><span class="line">	</span><br><span class="line">&#125;<span class="comment">//end of if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 函数介绍：</span></span><br><span class="line"><span class="comment">* 输入参数：</span></span><br><span class="line"><span class="comment">* 输出参数：</span></span><br><span class="line"><span class="comment">* 返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="类的版式">类的版式</h3>
<p>类的版式主要有关心结构的“以数据为中心”风格和“以行为为中心“风格,这里提倡**“以行为为中心“风格**,毕竟在大部分情况下我们只关心怎样使用,有什么功能,而不会在乎里面是什么.</p>
<p>一句话：<strong>将public类型的函数放在前面,将private的数据放在后面</strong>.</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Funcl</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i,j:</span><br><span class="line">	<span class="type">float</span> x,y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="命名">命名</h2>
<p>在实际工作中以<strong>企业的开发手册</strong>为主</p>
<p><strong>规则</strong></p>
<ul>
<li>不要用拼音,不用写完整英文翻译,也不要用中式英语命名</li>
<li>统一命名风格,要么驼峰命名法,要么匈牙利命名法,不要混着用.这里采用驼峰命名法
<ul>
<li>扩展：驼峰命名法:</li>
<li><strong>变量</strong>一般用<strong>小驼峰法</strong>标识.驼峰法的意思是：除第一个单词之外,其他单词首字母大写</li>
<li>大驼峰法把<strong>第一个单词的首字母也大写</strong>了.常用于类名,函数名,属性,命名空间</li>
</ul>
</li>
<li>少用易混淆的标识符,比如x与X,o与0</li>
<li>变量的名字(&quot;名词“或者”形容词+名词“)</li>
<li>全局函数的名字(“动词“或者&quot;动词+名词”),类中的函数命名(“动词”),因为&quot;自带&quot;名词.</li>
<li>可以用反义词组表示具有相反意义的变量或者函数(如set与get)</li>
<li>避免数字编号;比如num1;</li>
</ul>
<p><strong>Windows命名规则</strong></p>
<ul>
<li>常量全大写,下划线分割单词.如int  MAX_NUM = 100;</li>
<li>静态变量加s_前缀,全局变量加g_前缀,类成员加m_前缀  如int static s_num = 100;</li>
<li>对于不同库的变量可以添加反映库特性的前缀,如openGL,用gl_做前缀</li>
</ul>
<h3 id="表达式和基本语句">表达式和基本语句</h3>
<h3 id="运算符的优先级-复合表达式">运算符的优先级 &amp;&amp; 复合表达式</h3>
<p><strong>规则</strong></p>
<ul>
<li>适当用括号表示运算顺序</li>
<li>不要写复杂、多用途的表达式,除非你是出面试题的考官.比如<code>d = (a=b+c++)+r;</code></li>
</ul>
<h3 id="if语句">if语句</h3>
<p>规则</p>
<ul>
<li>不要将布尔值或者是0,1值直接进行比较. 比如能写<code>if(flag)</code> 就不要写 <code>if(flag == true)</code> 写<code>if(value == 0)</code> 就不要写<code>if(value == false)</code> 虽然false和0值相等,但是类型不同</li>
<li>浮点数不要用<code>==</code> <code>!=</code> 比较.因为浮点数精度问题</li>
<li>指针一般和NULL比较,或者和nullptr(C++11特性)比较</li>
<li>建议比较的时候将确定的数放在 == 之前,防止错写成=而无法发觉.</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">10</span> == a)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a=10&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果你写成=会自动给你报错,防止出事</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">10</span> = a)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环语句的效率">循环语句的效率</h3>
<p>规则</p>
<ul>
<li>建议将最长的循环放在内层,减少CPU跨切循环层的次数</li>
<li>逻辑判断最好在循环外面</li>
</ul>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不用for循环里面每次都判断条件,提高了效率</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">DoOtherthing</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="for循环与switch多分支">for循环与switch多分支</h3>
<p>规则</p>
<ul>
<li>不要轻易在for里面改变循环变量</li>
<li>for循环控制变量取值采用前闭后开的方法.能写<code>for (int i = 0;i &lt; 5;i++)</code>  就不要写`for (int i = 0;i &lt;=4;i++)</li>
<li>每个case都要写break防止case击穿.保留default语句</li>
</ul>
<h3 id="goto">goto</h3>
<ul>
<li>慎用goto,用的好能跳出重重封锁(比如嵌套循环),用不好就万劫不复</li>
</ul>
<h2 id="常量">常量</h2>
<p>使用常量的好处在于<strong>一劳永逸,见文知意</strong></p>
<p>规则</p>
<ul>
<li>用常量表示多次出现的数字或者字符串</li>
<li>建议用const代替#define,方便调试.</li>
<li>公开的常量放在头文件中,不公开的放在定义文件中</li>
<li>常量之间有关联的用常量代替而不是用数字</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100 <span class="comment">/*C语言的宏常量*/</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>; <span class="comment">//C++语言的const常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159</span>; <span class="comment">//C++语言的const常量</span></span><br><span class="line"><span class="type">const</span> string NAME = <span class="string">&quot;Lloyd&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUN = MAX * <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>类中设计常量</strong><br>
不能直接用const,建议使用<strong>枚举</strong></p>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span>&#123;SIZE1=<span class="number">100</span>,SIZE2=<span class="number">200</span>&#125;;<span class="comment">//枚举常量</span></span><br><span class="line">	<span class="type">int</span> array_fir[SIZE1];</span><br><span class="line">	<span class="type">int</span> array_sec[SIZE1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="函数设计">函数设计</h2>
<h3 id="规则">规则</h3>
<p>形参名</p>
<ul>
<li>形参名要写完整不要省,没有就用void</li>
<li>形参的顺序要合理(比如source与destination,除数与被除数)</li>
<li>如果传参是值的话建议用const&amp;,省去复制、构造与析构的过程</li>
<li>形参最好不要超过5个,而且参数最好有确定的类型与数目.</li>
</ul>
<p>返回值</p>
<ul>
<li>任何函数都要有类型,不返回就用void</li>
<li>函数名与返回值在语义方面不要冲突.比如别用getInt这种名字返回char型</li>
<li>对于赋值函数,使用“引用传递”返回对象;对于操作函数,使用“值传递”的方式返回对象.也就是根据实际情况选择<strong>值传递或者引用传递</strong></li>
</ul>
<p>函数</p>
<ul>
<li>函数入口要检查-使用断言assert</li>
<li>函数出口要检查return
<ul>
<li>不能返回指向“栈内存”的“指针”或者“引用”</li>
<li>清楚返回的是什么</li>
<li>如果返回的是对象可以直接写 “创建对象并返回” 如: return Entity(s1);  这在效率上比 Entity temp(s1); return temp;要高得多.</li>
</ul>
</li>
<li>函数功能单一、短小精悍、避免记忆、出错处理要清晰</li>
</ul>
<p><strong>断言</strong></p>
<ul>
<li>一般用于<strong>捕捉非法情况</strong>而不是错误情况</li>
<li>防错设计</li>
</ul>
<p>比较——引用与指针</p>
<ul>
<li>引用是取别名,指针是地址</li>
<li>引用被创建的时候必须初始化(如<code>string&amp; name = m_Name;</code></li>
<li>引用不能为空;并且引用初始化之后不能改变引用的关系.</li>
</ul>
<h2 id="内存管理">内存管理</h2>
<p>规则</p>
<ul>
<li>用malloc或new申请内存之后,应该立即检查指针值是否为NULL.防止使用指针值为NULL的内存.</li>
<li>不要忘记为数组和动态内存赋初值.防止将未被初始化的内存作为右值使用.</li>
<li>避免数组或指针的下标越界,特别要当心发生“多1”或者“少1”操作.</li>
<li>动态内存的申请与释放必须配对,防止内存泄漏.</li>
<li><strong>用free或delete释放了内存之后,立即将指针设置为NULL,防止产生“野指针”</strong>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">	*p = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内容复制与比较">内容复制与比较</h3>
<p>规则</p>
<ul>
<li>数组与字符串等不能轻易用== 判断相等(因为== 只比较值而没有比较地址),除非重载了运算符</li>
<li>当数组作为函数的参数进行传递时,数组自动退化成同类型的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(b, a);<span class="comment">//不能用b = a;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) &#123;&#125;;<span class="comment">// 不能用if(b = a)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *a = &amp;num;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(p, a);</span><br><span class="line"><span class="comment">//不要用p=a;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用if(p = a)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fuction</span><span class="params">(<span class="type">char</span> a[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">//结果是4而不是100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>free 与delete</p>
<ul>
<li>这“两大护法”并没有把指针干掉,而是释放内存,地址还在(&quot;一屋传三代,人走屋还在_(:з」∠)“)</li>
</ul>
<p>指针的问题</p>
<ul>
<li>指针消亡了,并不表示它所指的内存会被自动释放.</li>
<li>内存被释放了,并不表示指针会消亡或者成了NULL指针.</li>
</ul>
<p>C中的malloc/free与C++中的new/delete</p>
<ul>
<li>new和delete会自动调用构造或者析构函数(如果有的话),而malloc与free没有</li>
<li>C语言只有malloc与free.</li>
</ul>
<h3 id="内存耗尽问题">内存耗尽问题</h3>
<p>虽然对于32位及以上的系统很难将内存耗尽,但是也需要做好报错处理(不能因为国力强盛就不修长城)</p>
<p>处理方法</p>
<ul>
<li>如果申请的内存为空,用return或者exit(1)终止</li>
<li>或者自定义处理函数 比如try catch</li>
</ul>
<h3 id="函数讲解">函数讲解</h3>
<p><strong>malloc</strong><br>
函数原型为:<br>
<code>void * malloc(size_t size);</code><br>
讲解</p>
<ul>
<li>void* 是泛指针,如果要调用的时候要将其显示转换</li>
<li>size是内存大小,一般用sizeof求出</li>
</ul>
<p>使用示例<br>
<code>int *p = (int*)malloc(sizeof(int)*length);</code></p>
<p><strong>free</strong><br>
函数原型为<br>
<code>void free(void * memblock)</code></p>
<p><strong>new</strong><br>
new内置了sizeof、类型转换、类型安全检查等功能,建议多使用</p>
<p><strong>delete</strong><br>
不要漏掉[]<br>
举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> []objects;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">delete</span> objects;<span class="comment">//错误,只删除了objects[0],漏掉了其他</span></span><br></pre></td></tr></table></figure>
<p><strong>心得</strong></p>
<blockquote>
<ol>
<li>越是害怕,越是要勇敢面对它(特指指针),战胜恐惧的最好方法就是面对恐惧,加油,奥利给</li>
<li>犯错不可怕,走过万千路,天堑变通途.</li>
</ol>
</blockquote>
<h2 id="C-高级特性">C++高级特性</h2>
<p><strong>重载与覆盖(overload and override)</strong></p>
<p>特征</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>函数名</th>
<th>参数</th>
<th>是否有virtual关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载</td>
<td>在同一个类中</td>
<td>相同</td>
<td>不同</td>
<td>可有可无</td>
</tr>
<tr>
<td>覆盖</td>
<td>在基类与派生类中</td>
<td>相同</td>
<td>相同</td>
<td>必须有</td>
</tr>
</tbody>
</table>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;cout &lt;<span class="string">&quot;Base:f(int)&quot;</span>&lt;&lt;x &lt;endl;<span class="comment">//f被重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">float</span> x)</span></span>&#123;cout &lt;<span class="string">&quot;Base:f(float)&quot;</span>&lt;&lt;x &lt;endl;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123;cout &lt;<span class="string">&quot;Base:g(void)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123;cout &lt;<span class="string">&quot;Derived:g(void)&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//派生类覆盖原来基类的g函数,一旦后面通过派生类调用g函数,统一都是重写后的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误高发区：隐藏</strong><br>
简单来说就是想通过派生类调用基类的函数却发现调用的都是派生类的函数,导致编译失败,在以下情况下会发生</p>
<ul>
<li>派生类的函数与基类的函数同名,但是参数不同</li>
<li>派生类的函数与基类的函数同名,参数相同,但是基类函数没有virtual</li>
</ul>
<p><strong>参数的缺省值</strong><br>
缺省值就是默认值(<strong>default</strong>),中文翻译不准确,尽可能使用英文.</p>
<p>规则</p>
<ul>
<li>参数的default值只能出现在函数的声明中</li>
<li>default值从后往前写</li>
</ul>
<p>运算符重载</p>
<p><strong>函数内联</strong>(inline)<br>
函数内联具有宏效率,又有效解决了宏无法调试和安全性的问题.<strong>建议在C++中使用内联取代宏</strong>(assert除外)</p>
<p><strong>使用说明</strong></p>
<ul>
<li>inline必须必须<strong>和函数定义体放在一起</strong>才能使函数成为内联函数.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x,<span class="type">const</span> <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特别的：虽然在类中定义的函数自动变成内联函数,但是一般不会在类中定义函数,如果需要内联记得在定义处加上inline.</li>
<li>内联是<strong>用空间换时间</strong></li>
</ul>
<h2 id="类的构造函数、析构函数和赋值函数">类的构造函数、析构函数和赋值函数</h2>
<p>简单示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">NULL</span>);<span class="comment">//普通构造函数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String &amp;other);/拷贝构造函数</span><br><span class="line">	~<span class="built_in">String</span> (<span class="type">void</span>);<span class="comment">//析构函数</span></span><br><span class="line">	String &amp; operate =(<span class="type">const</span> String &amp;other);<span class="comment">//赋值函数 其实是重载=</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *m_data;<span class="comment">//用于保存字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类的继承与组合">类的继承与组合</h2>
<p>简单讲解对象(object)、类(class)和实例(instance)的关系<br>
对象就是“房子”,类就是设计房子的“蓝图”,对象是类的一个实例,根据“蓝图”可以盖很多的“房子”.<br>
所谓<strong>面向对象编程</strong>,就是设计“图纸”.</p>
<p><strong>继承的规则</strong></p>
<ul>
<li>不相关的两个类不要继承(“公若不弃,愿拜为义父”doge)</li>
<li>在逻辑上B是A的一种,并且A的所有属性和功能都对A有意义,就允许B继承A.比如虽然鸵鸟是鸟,但是“飞”的功能对鸵鸟是多余的,这种情况下最好不要继承与鸟</li>
</ul>
<p><strong>组合的规则</strong></p>
<ul>
<li>若在逻辑上A是B的“一部分”(a part of),则不允许B从A派生,而是要用A和其它东西组合出B.比如电池、屏幕和芯片是手机的一部分,就用这些类组合起来生成手机类,而不是让手机“<strong>拜电池等为义父</strong>”</li>
</ul>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">charge</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Look</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chip</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">charge</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Look</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Rum</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Cell m_cell;</span><br><span class="line">	Screen m_screen;</span><br><span class="line">	Chip m_chip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编程经验">编程经验</h2>
<h3 id="常用const">常用const</h3>
<p>注意</p>
<ul>
<li>const只能修饰输入参数</li>
<li>对于值传递的参数无需使用const修饰</li>
<li>对于非内部数据类型(就是C|C++标准库之外的类型)的输入参数.可以使用<strong>const 类型&amp;</strong> 的方式在提高效率的同时不改变参数内容.
<ul>
<li>比如int确实没必要使用const int &amp;.,内部数据类型没有构造与析构,复制也很快,不需要多此一举</li>
</ul>
</li>
<li>函数返回值如果是值传递,不需要用const修饰</li>
<li>不修改成员属性的函数都要加const</li>
</ul>
<h1>个人思考</h1>
<p>写代码就像是写作文,理论上只要表达意思正确(也就是程序能运行并达到理想效果),什么首行缩进、分段都不影响文章的质量,但是作文是要修改的(程序要维护),是要给人看的(别人要使用你的程序),此时语句(代码)就是交流的主要工具,语句的逻辑是什么?怎样表达就能让对方理解?怎样吸引读者阅读你的文章?怎样减少语病与错误?这是我们在写作文的时候经常思考的问题,编程也是一样.</p>
<p>接下来就从写好一篇文章开始讲解代码是什么.首先,写作者的名字,这就引出了“<strong>版权和版本</strong>“的声明,表明作品是你写的,作品处于哪个阶段.然后,给人物取名字,一般老师会让学生用什么典雅的古文等方法给人物取名,不过在计算机这里就不适用了,要简洁直白,能叫&quot;many&quot;就不要用&quot;quite a number of&quot;,又不是给英语作文凑字数(doge)</p>
<p>然后就要开始准备工作了,如果我们写的是人物传记,就要交代人物名字及其相关信息(声明及初始化变量),比如“廉颇者,赵之良将也”,声明一个Person类的变量名为“廉颇”,并将“赵国”“良将”作为参数构造了一个Person的实例对象——人.有的还会在正文之前写时间地点等,比如“元丰六年,余左迁……”(出自《琵琶行》)就是定义(define)”今年“为”元丰六年“,以后所有的”今年“都会被”元丰六年“等效代替.</p>
<p>以下以《廉颇蔺相如列传》第一段为例.</p>
<p>接下来我用“保安三问”(<strong>你是谁?你去哪?你干嘛?</strong>)来讲解如何写代码.</p>
<p>“廉颇者,赵之良将也”.首先,<strong>第一问“廉颇是谁?”</strong> ,我们需要给廉颇一个定义,是人是神还是鬼,是符号还是具体的事物?理论上都可以,但是从复用的角度和理解的角度来看,用“人”更加通俗易懂,即定义成“人”类(class)或者是结构体,这里以面向对象为主要编程思想,采用”类“来构造一个”人“. 然后,声明和定义一个“人”类,由于高质量编程的需要,最好将声明与定义放在不同的文件里面,类比图书放在不同的类别,都是为了后续减少维护成本.但是构造类的过程中有一点问题,类里面应该放点什么东西呢?我的建议是,随着”故事“的展开不断更新”人“类,毕竟人是会成长的,想要一开始一劳永逸只会顾此失彼.</p>
<p><strong>第二问“廉颇去哪?”</strong> 一般来说,所有的代码都直接或者间接在main函数里面.这里的“廉颇”也不例外.</p>
<p><strong>第三问”廉颇干嘛?“</strong> 第一句没有交代廉颇的行为,但是交代了廉颇的”特性“(属性),这就提醒”人“类可以”更新“了,比如添加”国籍(nationality)“、”地位(status)“属性并公开(双料特工可以不公开doge),不过又有问题了,这些属性应该是哪一种变量呢?string、int还是class呢?我的建议是,在日常生活中常以文字出现的用字符串(char[] string等),以数字出现的(比如成绩)用整型(比如int)或者浮点型(比如double).不过仅作参考,<strong>合适的才是最好的</strong>.好了,现在我们给“人”类添加了nationality和status属性,但是我们要“构造”一个“廉颇”啊,不能只把“廉颇”的特性给女娲却不告诉她怎样“玩泥巴”吧,也就是<strong>声明并定义有参构造</strong>(教女娲如何用泥巴塑造廉颇),怎样定义呢?“廉颇”要什么,就给女娲什么,廉颇要名字、要身份、要国籍,就给他名字(m_name = name;).现在,“人”类的基本蓝图已经有了,也告诉女娲怎样“捏一个人类“了,接下来就要将廉颇的特性传递给构造函数了.如下,成功创建了”廉颇“.用cout输出一下其特性,完美.</p>
<p>廉颇有了,要<strong>干什么</strong>呢?伐齐！这是一个动作,可以用一个<strong>函数</strong>来表示,那么函数应该是类中的函数还是外面的函数呢(<strong>保安第二问</strong>)?我的建议是,看谁复用性更强,毕竟人都喜欢偷懒,这里用类中的函数,毕竟之后蔺相如”人“也要”攻打“齐国.对于类的定义与实现,也是同理的<strong>保安三问</strong>,是什么?在哪里?干什么?是什么——返回什么类型,要什么参数,名字是什么;在哪里——函数声明与定义在哪里;干什么——实现了什么功能.<strong>不停追问自己,然后不断完善代码</strong>.<strong>伐</strong>字实现了,又到”齐“了,看起来好像是string,又感觉可以是class,用什么比较好呢?我的建议是,从宏观看”齐“的”地位“,即”齐“出现频率高不高,包含的东西多不多,以此配位,从全文来看,”齐“明显是高频词汇,应该重视,string不配修饰”齐“,那就用类(class)吧.同理<strong>保安三问</strong>创建”国家(country)“类.添加防御力(m_defenseValue)和名字(name)属性等.</p>
<p>下一句是“大破之”是结果,但是<strong>过程</strong>是什么呢?也就是结果的“因”是什么呢?这里实现的方法就见仁见智了,可以通过数值的比较,可以是特定的属性触发,甚至可以随机判定输赢,这里就用游戏中常用的“数值”来比较,用判断语句(if)判定.另一个结果是”拜为上卿,以勇气闻於诸侯“,这里强调的属性是”上卿“”闻(出名的意思)“看”人“类中有没有,有一个status,但是没有”出名“的属性,可以添加一个,<strong>根据保安三问定律</strong>,<strong>取</strong>”出名“的属性为int,名字是m_fame,用数值代表出名程度.然后在if中添加结果(将m_fame的值提升,将m_status的值改变),最后根据m_fame的值输出语句.至此,程序完结.</p>
<p><strong>示例如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Person.h中</span></span><br><span class="line"><span class="comment">//定义“人”类.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Country.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_nationality;<span class="comment">//国籍</span></span><br><span class="line">	<span class="type">int</span> m_ability = <span class="number">1</span>;<span class="comment">//能力值 范围1-5 越大能力越强</span></span><br><span class="line">	string m_name;<span class="comment">//名字</span></span><br><span class="line">	string m_status;<span class="comment">//地位</span></span><br><span class="line">	<span class="type">int</span> fame = <span class="number">1</span>;<span class="comment">//名声 范围1-5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有参构造</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string nationality, <span class="type">int</span> ability, string status);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//攻击函数</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Attack</span><span class="params">(Country nation)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">Person</span>(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Person.cpp文件中(也就是实现类中)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(string name, string nationality, <span class="type">int</span> ability,string status)</span><br><span class="line">&#123;</span><br><span class="line">	m_name = name;</span><br><span class="line">	m_nationality = nationality;</span><br><span class="line">	m_ability = ability;</span><br><span class="line">	m_status = status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~<span class="built_in">Person</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Person::Attack</span><span class="params">(Country nation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_ability&gt; nation.m_defenseValue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“赵惠文王十六年”<br>
<code>int to_year = 16;</code></p>
<p>“廉颇为赵将伐齐”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Country.h 文件中</span></span><br><span class="line"><span class="comment">//定义国家类</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_defenseValue = <span class="number">1</span>;<span class="comment">//国家防御力</span></span><br><span class="line">	string m_name;<span class="comment">//国家名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Country</span>(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Country</span>(string name, <span class="type">int</span> defenseValue);</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Country</span>(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Country.cpp</span></span><br><span class="line"><span class="comment">//国家类实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(string name, string nationality, <span class="type">int</span> ability,string status)</span><br><span class="line">&#123;</span><br><span class="line">	m_name = name;</span><br><span class="line">	m_nationality = nationality;</span><br><span class="line">	m_ability = ability;</span><br><span class="line">	m_status = status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~<span class="built_in">Person</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Person::Attack</span><span class="params">(Country nation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_ability&gt; nation.m_defenseValue)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“大破之,取阳晋,拜为上将,以勇气闻於诸侯”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main.cpp文件里面</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Country.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建“廉颇”与“蔺相如”</span></span><br><span class="line">	<span class="function">Person <span class="title">LianPo</span><span class="params">(<span class="string">&quot;廉颇&quot;</span>, <span class="string">&quot;Zhao&quot;</span>, <span class="number">5</span>,<span class="string">&quot;良将&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">LiXiangRu</span><span class="params">(<span class="string">&quot;蔺相如&quot;</span>, <span class="string">&quot;Zhao&quot;</span>, <span class="number">5</span>, <span class="string">&quot;舍人&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//输出“廉颇”的基本信息</span></span><br><span class="line">	cout &lt;&lt; LianPo.m_name &lt;&lt; <span class="string">&quot;者,&quot;</span> &lt;&lt; LianPo.m_nationality &lt;&lt; <span class="string">&quot;之&quot;</span> &lt;&lt; LianPo.m_status &lt;&lt; <span class="string">&quot;也&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建齐国</span></span><br><span class="line">	<span class="function">Country <span class="title">Qi</span><span class="params">(<span class="string">&quot;qi&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="comment">//赵惠王十六年</span></span><br><span class="line">	<span class="type">int</span> to_year = <span class="number">16</span>;</span><br><span class="line">	<span class="comment">//廉颇为赵将伐齐</span></span><br><span class="line">	<span class="type">bool</span> ret = LianPo.<span class="built_in">Attack</span>(Qi);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; LianPo.m_name &lt;&lt; <span class="string">&quot;对&quot;</span> &lt;&lt; Qi.m_name &lt;&lt; <span class="string">&quot;发起攻击&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//判断讨伐是否成功</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;大破之&quot;</span> &lt;&lt; endl;</span><br><span class="line">		LianPo.m_status = <span class="string">&quot;上卿&quot;</span>;</span><br><span class="line">		cout &lt;&lt; LianPo.m_name &lt;&lt; <span class="string">&quot;被拜为&quot;</span> &lt;&lt; LianPo.m_status &lt;&lt; endl;</span><br><span class="line">		LianPo.fame = <span class="number">4</span>;</span><br><span class="line">		<span class="comment">//判断名声等级</span></span><br><span class="line">		<span class="keyword">if</span> (LianPo.fame &gt;= <span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;以勇气闻於诸侯&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里,你会有一个问题,为什么要用写作来形容代码的编写过程呢?对以中文为母语的人可能难以理解,但是对于以英语为母语的人早已习以为常,甚至达到了“美国人刚出生就会写代码”的程度.对他们来说,写代码就是写英语作文,无非是语法更严格,字数变更少,语句更加讲逻辑,对我们来说就是在“写天书”.这里想说的是,将写代码看做是写英语作文,可以<strong>有效提高写代码的逻辑性</strong>,而且,一旦你认为自己写的是一篇作文,要传阅给所有人看,你就会不自觉“美化”你的作文(代码),<strong>在无形之中,你对自己写的作文(代码)提高了要求</strong>。我以写作为例,更多的是想让你感受一下<strong>保安三问定律</strong>在写代码方面的作用和按照一定的规则写代码的好处,毕竟代码就是语句,多行代码构成段落,多个段落构成故事,<strong>故事都有起因经过结果,保安定律就是为了回答这三者究竟是什么，规则限定我们写故事写在哪，怎样写易读性更强</strong>。也许自己的故事有缺陷,也许编程能力有限,但总是能引导我们走向文章的结尾,给老师(编译器)和他人一个满意的答卷.</p>
<ol class="series-items"><li><a href="/2024/06/25/%E3%80%8A%E9%AB%98%E8%B4%A8%E9%87%8FC%E3%80%81C++%E3%80%8B%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" title="《高质量C、C++》笔记整理">《高质量C、C++》笔记整理</a></li><li><a href="/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF/" title="算法系列(一)蓝桥杯">算法系列(一)蓝桥杯</a></li></ol>
<h1>参考资料</h1>
<ul>
<li>《高质量C、C++》 林锐</li>
<li>《C++ Prime Plus(第六版)》</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析工具superset安装和使用(version:0.381)</title>
    <url>/2024/09/16/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7superset/</url>
    <content><![CDATA[<h1>简介</h1>
<p>superset是一个开源的现代数据探索和可视化平台。目前属于Apache孵化器项目，主要用于数据分析师进行数据可视化工作,</p>
<h1>准备工作</h1>
<blockquote>
<p>注意：superset官网<a href="https://superset.apache.ac.cn/docs/intro/">简介 | Superset 中文 (apache.ac.cn)</a> 推荐使用docker安装，而以下教程是手动配置环境，建议不熟悉开发环境的用docker安装(我再也不手动配置了o(╥﹏╥)o)</p>
</blockquote>
<ul>
<li>事先安装centos7(或者有一个服务器)并且安装好mysql</li>
<li>主要参考视频教程和资料
<ul>
<li>【尚硅谷大数据Superset教程（数据仓库项目首选数据可视化平台）】<a href="https://www.bilibili.com/video/BV1SL4y1a7WK?p=10&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">https://www.bilibili.com/video/BV1SL4y1a7WK?p=10&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c</a></li>
<li><a href="https://blog.csdn.net/m0_46914845/article/details/125868049#comments_26566111">数据仓库工具superset安装（完全可用）-CSDN博客</a></li>
</ul>
</li>
</ul>
<h1>基本环境配置</h1>
<ol>
<li>尚硅谷的视频先从P1看到P2，一步步按照视频讲的方法做即可</li>
<li>然后就要开始创建Python环境，注意这里根据我个人实操和网络上帖子的经验，3.7、3.8的环境都有问题，我尝试过3.9，但是在最后启动superset的时候总是无法访问。这里就不要完全照抄视频，而是要根据此博客<a href="https://blog.csdn.net/m0_46914845/article/details/125868049#comments_26566111">数据仓库工具superset安装（完全可用）-CSDN博客</a> ，建议安装3.6版本的Python，按照步骤做到第六步。</li>
<li>然后注意将命令中所有的<code>https://pypi.douban.com/simple/</code> 改成 <code>https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>执行后发现没有安装pip和wheel，查看此<a href="https://blog.csdn.net/qq_15098623/article/details/90905230">centos 如何安装 pip（解决No package python-pip available问题）_no package python37 available-CSDN博客</a> 安装好</li>
<li>在执行第九步的时候输入命令可以加上 <code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code>加快下载速度</li>
<li>在执行第十步的时候发现缺少模块 输入 <code>pip install --upgrade cryptography==3.2 -i https://pypi.tuna.tsinghua.edu.cn/simple</code>  安装</li>
<li>后面基本上就是照着做了，注意–bind：绑定本机地址 ，绑定的是你服务器的IP地址</li>
<li>环境安装好之后就可以看尚硅谷的视频继续学了。</li>
</ol>
<h1>superset使用指南</h1>
<p>待更新……</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>算法系列(一)蓝桥杯</title>
    <url>/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
    <content><![CDATA[<h1>算法刷题与总结</h1>
<blockquote>
<p>以下内容借鉴了参考中的视频和其他部分。当前还在持续更新中</p>
</blockquote>
<h2 id="蓝桥杯系列">蓝桥杯系列</h2>
<h3 id="字符串">字符串</h3>
<blockquote>
<p>提醒：C语言和C++</p>
</blockquote>
<p><strong>字母与数字的映射关系</strong>：比如题目规定出现A代表10，B代表11，就要想到A的ASCII编码是97，B的编码是98,找对应关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字映射为字母 10代表A  11代表B</span></span><br><span class="line"><span class="keyword">if</span>(n&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,n<span class="number">-10</span>+<span class="string">&#x27;A&#x27;</span>);<span class="comment">//这样n为11就打印B，12就打印C，反之同理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字母映射为数字</span></span><br><span class="line"><span class="keyword">if</span>(c&gt;<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字母的大小写转换</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小写转大写</span></span><br><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a+(<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span>));<span class="comment">//大写A比小写a少‘32’，但是不能直接写32或者&#x27;32&#x27;，而是写(&#x27;A&#x27;-&#x27;a&#x27;)</span></span><br><span class="line"><span class="comment">//大写转化为小写同理</span></span><br></pre></td></tr></table></figure>
<p>在C/C++语言中规定，未尾以\0结束的字符型数组称为字符串。这里值得强调的是，只有以<code>\0</code> 结束的才能算是字符串，否则只能算作字符型数组。这在C/C++中算是一种标准。也只有以<code> \0</code>结束的字符数组才能以&quot;%s&quot;的方式用printf输出，否则输出的结果会非常奇怪。自己在char数组上构造一个字符串的时候，忘记在末尾加<code>\0</code>可能会导致访问非法内存的错误。如果使用的是C++的话，可以使用string 类</p>
<p><strong>字符串复制</strong></p>
<p>strcpy 具体看 C/C++参考文档 官网如下<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a></p>
<p><strong>字符串拼接</strong></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> dest, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> src )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串比较</strong></p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *lhs, <span class="type">const</span> <span class="type">char</span> *rhs )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>字符串长度</strong></p>
<p>strlen</p>
<p><strong>例题1</strong>：判断一个数是奇数还是偶数，但是至少10000位_(:з」∠)_ ？</p>
<p>分析：如果这个数<code>%2==0</code> 就是偶数，关键在于这个数<strong>数量级太大</strong>，long long也存不下，这个时候需要将其作为“字符”来看待，可以用string 或者是char[] 数组，观察可知，判断奇偶数的关键其实在于<strong>最后一位的数字，只要其为偶数，那么整个数为偶数</strong>，反之就是奇数.找最后一位就需要用strlen获取字符串的长度了，代码示例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//如果你用的是C就导入stdio.h和string.h C++的导入上述的方库</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">10001</span>]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">if</span>((s[len<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>)%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;是偶数&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;是奇数&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例题2</strong>：反转输出字符串</p>
<p>分析：这个很简单，用C语言实现就是从后往前遍历char[]数组并输出，这里就需要使用<code>strlen()</code>函数获取到字符串的长度.C++string类有reverse函数，可以直接反转字符串。</p>
<p><strong>例题3</strong>：输出最后一个单词的长度</p>
<p>关键在于遍历读取每一个单词直到读取到文件末尾，这里就使用到C语言中的文件读取，而scanf在读取的过程中如果使用的是<code>scanf(&quot;%s&quot;,s)</code> 就会<strong>持续读取直到为空格</strong>，如果<strong>读取到文本末尾会返回EOF的值</strong>，我们就需要使用这个返回值帮助我们读取到最后一个单词。示例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">char</span> s[<span class="number">10001</span>]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s)!=EOF)<span class="comment">//读取到最后一个单词的时候才会退出 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(s));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C/C++<strong>获取字符串</strong></p>
<p>C++:一种方法是用string 类+cin获取，另一种是fgets()函数+输入流的方式</p>
<p><strong>注意</strong>：cin与cout：对于考试而言，<strong>这两个输入输出函数运行时间过长</strong>，有时候会导致运行超时，考试一般建议使用scanf与printf。但是对于C++的容器，有些不能用scanf输入，只能用cin(比如string)，注意。</p>
<p>cin是可以直接将数据放在容器里面的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;str[i];<span class="comment">//将输入的字符串写入到str[i]中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日期">日期</h3>
<p><strong>经典题型1</strong> 找闰年</p>
<p>分析：年份非整百且能被4整除的为闰年和年份能被400整除的是闰年</p>
<p>用C语言表示为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(year % <span class="number">400</span> == <span class="number">0</span>||(year % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; year %<span class="number">4</span> == <span class="number">0</span> ) ) <span class="comment">//这里有个小技巧，先将判断量小的放前面再将判断量大的放后面，优化一定的时间。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>经典题型2</strong>：星期几</p>
<p>分析：经常会遇到别人问你几月几号是星期几的情况，如何不查日历，直接用程序算出来呢？一种最简单的方法是，记住很久以前的<br>
某一天是星期几，比如公元1年1月1日是星期一。然后一天一天模拟，算出日期是星期几。这种方法容易理解，但是实现起来代码可能比较长。除此之外，有一个公式可以快速地根据日期计算这一天是星期几，这被称为<strong>蔡基姆拉尔森计算公式</strong>。</p>
<p>假设星期为w,年份为y，月份为m,日期为d(第几天)，公式为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mn>2</mn><mi>m</mi><mo>+</mo><mn>3</mn><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>5</mn><mo>+</mo><mi>y</mi><mo>+</mo><mi>y</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>−</mo><mi>y</mi><mi mathvariant="normal">/</mi><mn>100</mn><mo>+</mo><mi>y</mi><mi mathvariant="normal">/</mi><mn>400</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">w = (d + 2m + 3(m+1)/5+y+y/4-y/100+y/400)\%7
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">/4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">/100</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">/400</span><span class="mclose">)</span><span class="mord">%7</span></span></span></span></span></p>
<p>然后把计算出来的w加上1就是真正的星期几了,<strong>注意每年的1,2月要当成上一年13,14月计算，上述的除法均为整除</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ComDay</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m+=<span class="number">12</span>;</span><br><span class="line">        y--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (d+<span class="number">2</span>*m+<span class="number">3</span>*(m+<span class="number">1</span>)/<span class="number">5</span>+y+y/<span class="number">4</span>-y/<span class="number">100</span>+y/<span class="number">400</span>)%<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>经典题型3</strong>：计算日期并按格式输出<br>
分析：要考虑到闰年二月时间的变化，不同月份的天数不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> day[<span class="number">13</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> y,m,d,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;y,&amp;m,&amp;d,&amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>;i &lt;=k;i++)&#123;</span><br><span class="line">		<span class="number">1</span>f((y%<span class="number">100</span>!=<span class="number">0</span> &amp;&amp; y%<span class="number">4</span>=<span class="number">0</span>)||y%<span class="number">400</span>=<span class="number">0</span>)&#123;</span><br><span class="line">			day[<span class="number">2</span>]= <span class="number">29</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			day[<span class="number">2</span>]= <span class="number">28</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		d++;</span><br><span class="line">		<span class="keyword">if</span> (d == day[m])&#123;</span><br><span class="line">			d=<span class="number">1</span>;</span><br><span class="line">			m++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">13</span>)&#123;</span><br><span class="line">			m=<span class="number">1</span>;</span><br><span class="line">			y++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d\n&quot;</span>,y,m,d);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>技巧：</p>
<p><strong>判断与穷举、范围、布尔值的转化</strong>：对于每个月份有多少天这种规律比较复杂的一系列数，用if判断显得臃肿，而将其所有情况写在数组里面，用下标代替判断更为有效。对于字符不能是A-Z这种限定条件，不要用穷举而是用范围的方式(比如<code>if(c&gt;='A' &amp;&amp; C&lt;='Z')</code>),这样更加简洁。对于字符串是否相等的问题，有时候不需要flag标志进行判断，而可以用链式方式简化</p>
<h3 id="排序-C-使用sort">排序(C++使用sort)</h3>
<p>sort是一个C++已经为我们实现好的工具，当我们要用它时，需要先引入一个算法的库一&lt;algorithm&gt;。需要说明的是，sort可以排序任何类型的元素，包括我们自己定义的结构体。我们将需要在C++文件的开始位置加上：<code>#include &lt;algorithm&gt;</code></p>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>
//  beg    开始迭代器<br>
//  end    结束迭代器<br>
// _Pred  谓词 <strong>也就是排序方法</strong> 比如greater就是从大到小排序</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="进阶：自定义-Pred参数">进阶：自定义 _Pred参数</h4>
<p>对于一般的容器谓词可以直接用greater,但是如果是类的排序或者是其他具有多个成员变量的对象的排序呢？这个时候就需要自己定义一个谓词，将需要进行比较的对象作为形参，以某种比较方式进行比较，最后要返回布尔值。为真就会被排到容器前面，假就会排在后面。</p>
<p>示例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值必须是bool</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="comment">//这里是比较x与y个位大小，为真返回true，即只要为真的都在前面，为false都在后面。</span></span><br><span class="line">	<span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以<strong>加入多个语句进行多次的排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照成绩排序，如果第一个成绩相同就按第二个成绩排序，如果第二个成绩相同就按第三个成绩排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_score</span><span class="params">(Student x,Student y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x.score[<span class="number">0</span>]!=.score[<span class="number">0</span>])&#123;</span><br><span class="line">		<span class="keyword">return</span> x.score[<span class="number">0</span>]&gt;y.score[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x.score[<span class="number">1</span>]!=.score[<span class="number">1</span>])&#123;</span><br><span class="line">		<span class="keyword">return</span> x.score[<span class="number">1</span>]&gt;y.score[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x.score[<span class="number">2</span>]&gt;y.score[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>初始化列表-C++特性</strong></p>
<blockquote>
<p>常用于构造函数和实例对象创建，主要是起到简便的作用。</p>
</blockquote>
<p>如下代码所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	string name;</span><br><span class="line">    <span class="built_in">Student</span>()&#123;&#125;<span class="comment">//注意不可省略默认构造函数</span></span><br><span class="line">	<span class="built_in">Student</span>(string n,<span class="type">int</span> s):<span class="built_in">name</span>(n),<span class="built_in">score</span>(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化列表的写法是，在构造函数的括号后面加一个冒号，然后按照成员变量（参数）的格式，依次对每一个变量进行初始化，彼此之间用逗号隔开。</p>
<p>注意</p>
<ul>
<li>函数的参数列表绝对不能省略，像<code>Student():name(n),score(s)</code>这样的写法是不允许的。</li>
<li>如果在初始化完成员变量之后，还有别的事情要做，那可以把代码写在大括号里。但是，就算之后什么都不做，也必须写<br>
大括号一大括号不能省略！！！</li>
</ul>
<h3 id="枚举-暴力穷举法">枚举(暴力穷举法)</h3>
<p>枚举就是根据提出的问题，一一列出该问题的所有可能的解，并在逐一列出的过程中，检验每个可能解是否是问题的真正解<br>
如果是就采纳这个解，如果不是就继续判断下一个。<br>
枚举法一般比较直观，容易理解，但由于要检查所有的可能解，因此运行效率较低。</p>
<p>经典枚举题目：求质数、水仙花数等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求质数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = n;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="type">bool</span> is_prime = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;j;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j % i == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				is_prime = fale;</span><br><span class="line">				cout&lt;&lt;j&lt;&lt;<span class="string">&quot;NOT PRIME&quot;</span>&lt;&lt;endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_prime)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;j&lt;&lt;<span class="string">&quot;PRIME&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还有一种方法是遍历到根号下，也就是大概遍历到一半左右就行。</span></span><br></pre></td></tr></table></figure>
<h3 id="C-的STL">C++的STL</h3>
<h4 id="vector">vector</h4>
<p>动态数组</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>               		     //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li>
<li><code>vector&lt;T&gt; v(num);</code>                          //创建一个存储num个类型为T元素的vector</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//通过区间方式进行构造</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v<span class="number">1.</span>begin(), v<span class="number">1.</span>end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">	<span class="comment">// n个elem方式构造</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;  这里是<span class="number">10</span>个<span class="number">100</span></span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用方法(具体可以看<a href="https://www.runoob.com/cplusplus/cpp-vector.html">C++ vector 容器 | 菜鸟教程</a>)</p>
<p><strong>函数原型：</strong></p>
<ul>
<li>
<p><code>push_back(ele);</code>                                         //尾部插入元素ele</p>
</li>
<li>
<p><code>pop_back();</code>                                                //删除最后一个元素</p>
</li>
<li>
<p><code>clear();</code>                                                        //删除容器中所有元素</p>
</li>
<li>
<p><code>size();</code>                                                           //获取vector的长度</p>
</li>
<li>
<p><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</p>
</li>
<li>
<p><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</p>
</li>
<li>
<p><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</p>
</li>
<li>
<p><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</p>
<p><strong>蓝桥杯用的最多的就是前4个</strong>，后面的遇到了再查资料。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">100</span>);<span class="comment">//在指定位置插入100</span></span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="comment">//C++中vector的clear（）只是清空vector,并不会清空开的内存。用一种方法可以清空vector的内存：</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>
vector可以构造二维数组吗？可以，比如vector&lt;vector&lt;int&gt; &gt; 但要注意在int&gt; 与&gt;   之间留一个空格，否则有些老编译器无法通过。</p>
</blockquote>
<h4 id="set">set</h4>
<p>集合</p>
<p>C++中set的实现在一个&lt;set&gt;头文件中，要使用就在代码开头引入这个头文件<code>#include &lt;set&gt;</code>.</p>
<p>C++中直接构造一个set的语句为：set&lt;T&gt;s。这样我们定义了一个名为s的、储存T类型数据的集合，其中T是集合要储存的数据类型。初始的时候s是空集合。比如set&lt;int&gt;aa,set&lt;string&gt;bbb等等。</p>
<hr>
<p><strong>常用的函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert</td>
<td>插入一个元素。C++中用insert（）函数向集合中插入一个新的元素。<strong>注意如果集合中已经存在了某个元素，再次插入不会产生任何效果，集合中是不会出现重复元素的</strong>。</td>
</tr>
<tr>
<td>erase</td>
<td>删除一个元素</td>
</tr>
<tr>
<td>count</td>
<td>统计集合中某个元素的个数。C++中如果你想知道<strong>某个元素是否在集合中出现</strong>，你可以直接用count函数。如果集合中存在我们要查找的元素，返回1,否则会返回0。</td>
</tr>
<tr>
<td>size</td>
<td>获取元素个数</td>
</tr>
<tr>
<td>clear</td>
<td>清空</td>
</tr>
</tbody>
</table>
<h4 id="迭代器">迭代器</h4>
<p>C++通过迭代器可以访问集合中的每个元素，迭代器就好像一根手指指向set中的某个元素(<strong>迭代器不仅仅可以在set上使用，还可以在其他的STL中使用</strong>)<br>
要改变它指向的元素。通过*(这是解引用运算符，不是乘号的意思)操作可以获取迭代器指向的元素。通过<code>+</code>操作让迭代器指向下一个元素，同理-操作让迭代器指向上一个元素。<br>
迭代器的写法比较固定，<code>set&lt;T&gt;::iterator it</code>就定义了一个指向<code>set&lt;T&gt;</code>这种集合的迭代器it,T是任意的数据类型。其中：iterator是固定的写法。begin函数返回容器中起始元素的迭代器，end函数返回容器的尾后迭代器。</p>
<p>用法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 vector 容器并初始化</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历 vector</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载运算符">重载运算符</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp; rhs)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(x == a.x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> y&lt;rhs.y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> x&lt;rhs.x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>operator&lt;</code>表示我们要重载运算符<code>&lt;</code>，可以看成是一个函数名。<code>rhs</code>是“right hand side”的简称，有右操作数的意思，这里我<br>
们定义为一个const引用。因为该运算符重载定义在结构体内部，左操作数就当前调用<code>operator&lt;</code>的对象。<br>
特别要注意，不要漏掉最后的const。const函数表示不能对其数据成员进行修改操作，并且const对象不能调用非const成员<br>
函数，只允许调用const成员函数。<br>
上面重载规定了排序方式为，优先按照<code>×</code>从小到大排序，如果×相同，那么再按照y从小到大排序。经过了<code>&lt;</code>运算符重载的结<br>
构体，我们就可以比较两个Node对象的大小了，因此可以直接储存在set中了。</p>
<h4 id="map">map</h4>
<p>映射：是指两个集合之间的元素的相互对应关系。通俗地说，就是一个元素对应另外一个元素。比如Tom-&gt;1,Mary-&gt;2.我们称其中的姓名集合({“Tom”,“Mary”}为关键字集合key,班级集合({1,2}为值集合(value),在C++中常用的映射有map。</p>
<p><strong>构造一个映射</strong><br>
现在我们来构造一个映射。<br>
在C++中，我们构造一个map的语句为：<code>map&lt;T1,2&gt;m</code>;。这样我们定义了一个名为m的从T1类型到T2类型的映射。初始的时候m是空映射。比如<code>map&lt;string,int&gt;m</code>构建了一个字符串到整数的映射，这样我们可以把一个字符串和一个整数关联起来。</p>
<p><strong>插入一对映射</strong><br>
在C++中通过insert)函数向集合中插入一个新的映射，参数是一个pair。pair是一个标准库类型，定义在头文件utility中。可以看成是有两个成员变量first和second的结构体，并且重载了<code>&lt;</code>运算符(先比较first大小，如果一样再比较second)。当我们创建一个pair时，必须提供两个类型。<br>
我们可以像这样定义一个保存string和int的pair</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;string,<span class="type">int</span>&gt;p;</span><br></pre></td></tr></table></figure>
<p><code>make_pair(v1,v2)</code>函数返回由v1和v2初始化的pair,类型可以从v1和v2的类型推断出来。<br>
我们向映射中加入新映射对的时候就是通过插入pair来实现的。如果插入的key之前已经存在了，将不会用插入的新的value替代原来的value,也就是这次插入是无效的。</p>
<p><strong>访问映射</strong><br>
在C++中访问映射和数组一样，直接用<code>[]</code>就能访问。比如<code>dict[&quot;Tom&quot;]</code>就可以获取&quot;Tom&quot;的班级了。而这里有一个比较神奇的地方，如果没有对&quot;Tom&quot;做过映射的话，此时你访问<code>dict[&quot;Tom&quot;]</code>,系统将会自动为&quot;Tom&quot;生成一个映射，其value为对应类型的默认值(比如int的默认值是0,string的默认值是空字符串)。并且我们可以之后再给映射赋予新的值，比如<code>dict[&quot;Tom&quot;]=3,</code>这样为我们提供了另一种方便的插入手段。实际上，我们常常通过下标访问的方式来插入映射，而不是通过用insert插入一个pair来实现。</p>
<p><strong>判断关键字是否存在</strong></p>
<p>在C++中，如果你想知道某个关键字是否被映射过，你可以直接用<code>count</code>函数。如果关键字存在，返回1，否则会返回0。<strong>示例如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 map 容器，存储员工的姓名和年龄</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; employees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入员工信息</span></span><br><span class="line">    employees[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    employees[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    employees[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找员工是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(employees.<span class="built_in">count</span>(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Alice is a employees&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Alice is not a employees&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里的代码接下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>遍历映射</strong></p>
<p>map的迭代器的定义和set差不多，<code>map&lt;T1,T2&gt;::iterator it</code>就定义了一个迭代器，其中T1、T2分别是key和value的类型。<br>
C++通过迭代器可以访问集合中的每个元素。这里迭代器指向的元素是一个pair,有<strong>first</strong>和<strong>second</strong>两个成员变量，分别代<br>
表一个映射的key和value.我们用<code>-&gt;</code>运算符来获取值，<code>it-&gt;first</code>和<code>(*it).first</code>的效果是一样的，就是获取迭代器it指向的pair里first成员的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的代码接上文</span></span><br><span class="line"><span class="comment">// 遍历 map 并打印员工信息</span></span><br><span class="line">   <span class="keyword">for</span> (std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it = employees.<span class="built_in">begin</span>(); it != employees.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">       std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>注意：C++中遍历map是按照关键字从小到大遍历的</p>
<p>map里面可以套用set或者是map，主要是用于处理键值对重复的问题。</p>
<h4 id="stack">stack</h4>
<p>栈，是一种满足一定约束的线性数据结构。其约束是：只允许在栈的一端插入或删除元素，这一端被称为栈顶；相对地，我们<br>
把另一端称为栈底。</p>
<p>标准库里面的stack在头文件<code>&lt;stack&gt;</code>里面，它的定义和map、set、vector都大同小异，如果你对前面的标准库已经使用得<br>
很熟练了，那么对于stack的使用你也会一目了然。<code>stack&lt;T&gt;s</code>定义了一个储存T类型数据的栈s.标准库的栈除了支持push(),pop()等基本操作以外，还支持top()来获取栈顶元素、empty()判断栈是否为空、size()计算栈中元素的个数。</p>
<p><strong>使用示例</strong> 常用的几乎就在以下示例中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向栈中添加元素</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element is: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出: Top element is: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除栈顶元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After popping, top element is: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl; <span class="comment">// 输出: After popping, top element is: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is not empty.&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出: Stack is not empty.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印栈的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of stack: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 输出: Size of stack: 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续移除元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is empty.&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出: Stack is empty.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归">递归</h2>
<p>递归是计算机编程中应用最广泛的一个技巧，也是比较难理解的一个技巧，所以我们打算花大量的时间来理解递归。所谓递归，就是函数调用函数自身，一个函数在其定义中有直接或者间接调用自身都叫递归。而递归一般都用来解决有重复子问题的问题。我们先来理解直接递归，间接递归非常复杂，用的比较少。下面通过求解！(！代表阶乘)的问题来理解直接递归。我们知道n!=n×(n-1)！，所以我们很容易写下下面的代码。如果仅仅写一个递归式子还是很简单的，但是**递归的一个难点(或者说最难的地方)**就是——<strong>边界条件</strong>。所谓边界条件，就是在什么情况下，函数不应该再继续调用自身。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="comment">//递归边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> n*<span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>经典题型1：</strong> 汉诺塔</p>
<p>汉诺问题看似复杂，其实不管是多少，都可以归纳为三个步骤：1. 把n-1个盘子从A移动到B,此时A上只剩下最下面的一个盘子。2. 直接把最后一个盘子从A移动到C。3.把B上的n-1个盘子移动到C上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; S[<span class="number">3</span>];<span class="comment">//汉诺塔的杆子数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//盘子移动函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = S[x].<span class="built_in">top</span>(); </span><br><span class="line">	S[x].<span class="built_in">pop</span>();</span><br><span class="line">	S[y].<span class="built_in">puish</span>(temp);</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hanoi</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B,<span class="type">int</span> C,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)<span class="comment">//如果A杆只有一个盘子时 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">move</span>(A,C);<span class="comment">//将A杆的盘子直接移动到C </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">hanoi</span>(A,C,B,n<span class="number">-1</span>); <span class="comment">//将A杆盘子经由C移动到B，并减少A杆的盘子数 </span></span><br><span class="line">	<span class="built_in">move</span>(A,C);</span><br><span class="line">	<span class="built_in">hanoi</span>(B,A,C,n<span class="number">-1</span>);<span class="comment">//将剩下B杆的盘子经由A移动到C，直到所有的盘子都移动到C。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; </span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//演示汉诺塔 </span></span><br><span class="line">	&#123;</span><br><span class="line">		S[<span class="number">0</span>].<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">hanoi</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(!S[<span class="number">2</span>].<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;S[<span class="number">2</span>].<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		S[<span class="number">2</span>].<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://www.bilibili.com/video/BV1Lb4y1k7K3/?share_source=copy_web&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">蓝桥杯比赛视频教程（入门学习+算法辅导)</a> 建议看前41节 重点是他讲的知识点，由于他讲题特别快不建议按照他的课刷题，建议自行在蓝桥杯题库中刷题。</li>
<li><a href="https://leetcode.cn/circle/discuss/E3yavq/">力扣刷题攻略</a>  读者可以在这里参考刷题。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构可视化</title>
    <url>/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>本文主要侧重于可视化的介绍和简单的操作，为后续算法相关的博客提供可视化素材。具体细节请读者自行学习。</p>
</blockquote>
<h1>简介</h1>
<p>数据结构对于计算机系的同学们来说无疑是最基础、最重要的一门课程之一，但是在面对抽象的代码、陌生的概念时感到无从下手，对于数据结构的运行步骤没有一个直观的认识，而数据结构可视化可以帮助同学们用具体的图形理解抽象的算法，从而更好掌握数据结构的精髓。</p>
<h1>准备工作</h1>
<h2 id="推荐的可视化网站">推荐的可视化网站</h2>
<ol>
<li><a href="https://pythontutor.com/">Python Tutor - Python Online Compiler with Visual AI Help</a></li>
<li><a href="https://visualgo.net/zh">通过动画可视化数据结构和算法 - VisuAlgo</a> 如果想要动画效果建议使用此网站</li>
</ol>
<h2 id="编程基础">编程基础</h2>
<p>读者至少掌握一门常见的计算机语言(如C++、Python等)的基础语法,否则数据结构可视化无从谈起。</p>
<h1>可视化开发</h1>
<h2 id="Python-tutor">Python tutor</h2>
<p>基础的界面如下，参考图像文字学习</p>
<p><strong>代码展示和调试区</strong></p>
<p><img src="https://s2.loli.net/2024/11/26/XstjOaTp1YBQi6L.png" alt="001_可视化开发基础_01"></p>
<p><strong>调试</strong>：设置断点：点击对应的代码，其颜色会变红，下方会出现红线，如果你点击&lt;prev或者是Next&gt; 会自动跳转到设置有断点的代码行。示例如下</p>
<p><img src="https://s2.loli.net/2024/11/26/I3YJVByXk86wpFK.png" alt="001_可视化开发基础_03"></p>
<blockquote>
<p>注意：执行步数最大为999步</p>
</blockquote>
<p><strong>编辑代码区</strong></p>
<p>编辑完成并确认没有语法错误后点击左下角的<code>visualize execution</code> 将其可视化。</p>
<p><img src="https://s2.loli.net/2024/11/26/SJsid7fGpbMXEI3.png" alt="001_可视化开发基础_02"></p>
<p><strong>案例</strong></p>
<p>可以点击代码区下面的<code>show code examples</code> 感受一下不同例子可视化的效果</p>
<p><strong>小技巧</strong></p>
<ol>
<li>对于Python，可以在编辑代码区可以通过一行<code>#pythontutor_hide: 变量名</code> 将指定的变量在可视化界面中隐藏，读者可以使用此代码隐藏无关变量。对于其他的编译器，可以在可视化执行之后点击<code>Move and hide objects</code> 按照说明将指定的对象隐藏。</li>
<li>可视化执行之后，可以点击左下方的两个按钮生成链接或者是iframe嵌入到markdown文件格式里面，甚至可以执行\(^o^)/~，如下</li>
</ol>
<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Ciostream%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20int*%20x%20%3D%20new%20int%5B3%5D%3B%0A%20%20x%5B1%5D%20%3D%2020%3Bint*%20p%20%3D%20%26x%5B1%5D%3B%20//%20pointer%20into%20middle%0A%20%20const%20char**%20fruit%20%3D%20new%20const%20char*%5B3%5D%3B%0A%20%20fruit%5B1%5D%20%3D%20%22bananas%22%3B%0A%20%20std%3A%3Acout%20%3C%3C%20%22Yum%20%22%20%3C%3C%20*p%20%3C%3C%20%22%20%22%20%3C%3C%20fruit%5B1%5D%3B%0A%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=cpp_g%2B%2B9.3.0&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>
<p><strong>建议以上网址链接用电脑端打开，手机端会有界面溢出的问题</strong></p>
<p><img src="https://s2.loli.net/2024/11/26/cWnDdbAMEBvuUjk.png" alt="001_可视化开发基础_04"></p>
<h2 id="visualgo">visualgo</h2>
<p>这个网站有中文，同时也有教程，这里就不展开教学了，比较适合需要动画效果的代码展示。</p>
<h2 id="gif录制">gif录制</h2>
<p>软件：<a href="https://www.screentogif.com/">ScreenToGif</a> 选择对应的版本下载即可。</p>
<p>参考教程：链接:<a href="https://www.bilibili.com/video/BV1fb411P74h?vd_source=bb8dacb993f11c0e39f8147c98a2894c">screentogif</a></p>
<p>示例如下(gif相当于图片，可以直接在markdown文件里面按照图片的格式插入)</p>
<p><img src="https://s2.loli.net/2024/11/26/eAGhpQafRJqD1PM.gif" alt="动画"></p>
<h1>参考</h1>
<ol>
<li><a href="https://pythontutor.com/">Python Tutor - Python Online Compiler with Visual AI Help</a></li>
<li><a href="https://visualgo.net/zh">通过动画可视化数据结构和算法 - VisuAlgo</a></li>
<li><a href="https://www.screentogif.com/">ScreenToGif</a>：软件下载官方网站</li>
<li><a href="https://www.bilibili.com/video/BV1fb411P74h?vd_source=bb8dacb993f11c0e39f8147c98a2894c">screentogif</a> ：B站教程</li>
</ol>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语(英语兔版)</title>
    <url>/2024/10/13/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD(%E8%8B%B1%E8%AF%AD%E5%85%94%E7%89%88)/</url>
    <content><![CDATA[<h1>英语口语</h1>
<p>💡不要用中文去替代英文中独有的，但是中文中缺失的音。</p>
<h1>三种常用的音标</h1>
<p>国际音标(IPA):</p>
<p>KK音标：主要是美式音标，方便美式英语的注音。</p>
<p>DJ音标：主流音标，口语练习的主要音标。<strong>本文后面不加说明的都是练习的DJ音标(IPA88)</strong></p>
<p>对于非英语专业或者是语言研究的人来说，我们只需要在学习音标的是能认出这是属于哪一类的音标即可，音标终究是用来帮助发音的。</p>
<h1>全部音标发音</h1>
<p>视频如下。</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=552211531&bvid=BV1vi4y1C73C&cid=547518386&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;">
    </iframe>
</div>
<h1>发音讲解</h1>
<p><strong>以元音和辅音分</strong>：</p>
<p>元音：就是在发音时不受阻碍(如嘴唇张开，但还是会受到舌头的影响)发出的音。辅音与元音相反。注意这里的舌位指的是舌头在发音时隆起的最高点，舌头太高，舌位就高。</p>
<p>影响元音三要素：圆唇度(嘴巴”o“的程度)，舌位高低，舌位前后。</p>
<p><strong>以清音和浊音分</strong>：<br>
清音与浊音：声带不振动的音就是清音。反之就是浊音。</p>
<p>示意图如下</p>
<table>
<thead>
<tr>
<th></th>
<th>元音</th>
<th>辅音</th>
</tr>
</thead>
<tbody>
<tr>
<td>浊音</td>
<td>粗略认为所有的元音都是浊元音</td>
<td>浊辅音</td>
</tr>
<tr>
<td>清音</td>
<td>\</td>
<td>清辅音</td>
</tr>
</tbody>
</table>
<h2 id="元音">元音</h2>
<blockquote>
<p>以下都是DJ音标</p>
</blockquote>
<h3 id="单元音">单元音</h3>
<p>注意：后面在音标中的的：不是其正确写法，只是markdown文件难以展现，具体写法还是见参考部分的第一个链接，后面的也是这样。</p>
<ul>
<li><strong>/i:/</strong></li>
</ul>
<p>bee、fee、pea、read、meat、lead</p>
<p>发音时不圆唇，注意舌位更高，嘴角要向两边拉开，带点微笑的感觉。</p>
<ul>
<li><strong>/ɪ/</strong></li>
</ul>
<p>bit、fit、pit、lit、hit、fish</p>
<p>注意舌位更低，舌尖在下齿后方，比/i:/更放松，嘴角没有那么咧开。</p>
<p>注意区分，它<strong>不仅仅是把/i:/的时长缩短</strong>，有些美国人发音舌位会更低。有点像是军训时教官说的“一”。</p>
<ul>
<li><strong>/u:/</strong></li>
</ul>
<p>too、food、loose、prove、moon、soon</p>
<p>/u:/<strong>口型没有那么圆,而是更扁</strong>,嘴角向两边拉伸，发音部位靠口腔后部。(不要误发成yu)</p>
<ul>
<li><strong>/ʊ/</strong></li>
</ul>
<p>book、look、good、took、bush、would</p>
<p>发/ʊ/时,嘴唇没那么撅，更放松时长更短,发音更靠后。/ʊ/并不仅仅是把长音/u:/短着读，/u:/的唇形像两边拉开,而/ʊ/唇形更圆,更放松。</p>
<ul>
<li><strong>/e/</strong></li>
</ul>
<p>bed、get、pet、let、met、set</p>
<p>双唇自然张开，口腔放松。舌尖在下牙齿后方，舌面平放</p>
<ul>
<li><strong>/ɜ:/</strong></li>
</ul>
<p>her、person、learn、bird、word、fur、urgent</p>
<p>嘴自然张开，唇和舌自然放松，要确保发音时间够长，是重读的长音。如果发音不重读，更短就变成了/ə/ ，在单词中的拼写有er、ear、ir、or、ur等。</p>
<p>在<strong>美式</strong>英语中会r化，写作/ɜ:r/，是美式英语最显著的特征之一。</p>
<ul>
<li><strong>/ə/</strong></li>
</ul>
<p>a-about balloon、e-taken problem、i-family pencil、o-memory freedom、u-supply support、y-syringe analysis 这些字母在单词内发音的时候都发/ə/</p>
<p>嘴自然张开,唇和舌都自然放松不要重读,轻轻地让气流冲出声带自然读出重读,变长→/ɜ:/，它是英语中出现频率它是英语最高，最特殊,最重要的schwa(中央元音或中性元音)。让说话者在不需要强调某个音时用它代替，为了在某个音上减少所花时间，<strong>弱化</strong>成一个中性的默认音。有时候/ə/甚至省略不读。</p>
<ul>
<li><strong>/ʌ/</strong></li>
</ul>
<p>but、hut、must、son、ton、done</p>
<p>舌尖在下牙齿后方，舌头平放发音靠口腔中后方，类似于啊但是口型没有那么大,时长更短，英美发音不同。</p>
<p><strong>美音</strong>/ʌ/和中央元音/ə/区别在于，/ʌ/只出现在重读音节中，而/ə/只出现在轻读音节中。两者一般不做舌位上的区分，区别在于是否重读,在美音中的发音不是在口腔中后方，而是在口腔中间，也就说比英音靠前。</p>
<ul>
<li><strong>/ɔ:/</strong></li>
</ul>
<p>caught、bought、law、saw、door、four</p>
<p>嘴唇要撅起来，圆而外凸,肌肉较为紧张，口腔后方发音。</p>
<p><strong>美音</strong>中/ɔ/没有英音那样圆形外凸，更靠近汉语拼音ao而不是o，如果这个音后面跟字母r，美音中往往r化。</p>
<ul>
<li><strong>/æ/</strong></li>
</ul>
<p>bad、fat、pat、lad、mat、sat</p>
<p>最容易读错的音之一，口型一定要张大，饱满，嘴角也要向两边拉伸。舌端在下牙齿后方，同时发出/ɑ:/和/e/这两个音。</p>
<ul>
<li><strong>/ɑ:/</strong></li>
</ul>
<p>father、fast、glass、car、park、mark</p>
<p>/ɑ:/的口型比“啊”更大,发音更靠口腔后部(舌根处)发音，时长要足够长。</p>
<ul>
<li><strong>/ɒ/</strong></li>
</ul>
<p>top、hot、lot、box、stop、wash</p>
<p>/ɒ/和普通话的凹(ao)相似,但并不相同发/ɒ/时,嘴型更小,时间更短,凹有口型变化，/ɒ/没有。</p>
<p>在<strong>美音</strong>中一般读作/ɑ:/，也是英式英语和美式英语主要区别之一。</p>
<h3 id="双元音">双元音</h3>
<ul>
<li><strong>/eɪ/</strong></li>
</ul>
<p>make、date、cake、safe、play、plane</p>
<p>/e/和/ɪ/一前一后快速紧密发出，或者理解为从/e/向/ɪ/平滑发音。发这个音口腔是有变化的。</p>
<ul>
<li><strong>/ɔɪ/</strong></li>
</ul>
<p>boy、toy、soy、voice、noise、moist</p>
<p>/ɔ:/变短后和/ɪ/一前一后快速紧密发出，或者理解为从/ɔ:/向/ɪ/发音，发这个音口腔是有变化。</p>
<ul>
<li><strong>/aɪ/</strong></li>
</ul>
<p>bike、nice、time、lick、site、life</p>
<p>/a/和/ɪ/一前一后快速紧密发出，或者理解为从/a/向/ɪ/发音，发这个音口腔是有变化的，口型更加饱满。</p>
<ul>
<li><strong>/aʊ/</strong></li>
</ul>
<p>how、cow、allow、house、loud、mouse</p>
<p>/a/和/ʊ/一前一后快速紧密发出，发这个音口腔是有变化的，口型更饱满更长。</p>
<ul>
<li><strong>/əʊ/</strong></li>
</ul>
<p>open、hope、post、coat、boat、soap</p>
<p>/ə/和/ʊ/一前一后快速紧密发出，发这个音口腔是有变化的，嘴唇有收缩的，英音的起始音位比**美音/oʊ/**更靠前。</p>
<ul>
<li><strong>/ʊə/</strong></li>
</ul>
<p>tour、poor、moor、pure、cure、lure</p>
<p>/ʊ/和/ə/一前一后快速紧密发出，发音一定要连贯。读音在英音中包含/ʊə/的词基本上都包含字母r，在<strong>美音</strong>中会r化。</p>
<ul>
<li><strong>/eə/</strong></li>
</ul>
<p>hair、pair、chair、fare、care、dare</p>
<p>/e/和/ə/一前一后快速紧密发出，发音一定要连贯，注意这个/ə/可不等于/r/.</p>
<ul>
<li><strong>/ɪə/</strong></li>
</ul>
<p>area、idea、beer、dear、fear、here</p>
<p>/ɪ/和/ə/一前一后快速紧密发出，发音一定要连贯。请注意,如果是读英音，单词拼写即使出现字母r，单词内部也不会r化，如果是读<strong>美音</strong>，只有单词内部出现r，才有可能r化。美音中如出现r，则对应读音为/ɪr/如不出现r，则一样。如果单词内部没有r，则英音美音都是/ɪə/，比如idea。</p>
<h2 id="辅音">辅音</h2>
<p>概念解读(辅音三阶段)：成阻：气流被阻塞；持阻：气流持续往外冲，但仍被阻塞；除阻：阻塞被去除，气流冲出；</p>
<p>辅音三要素：清浊，调音部位、调音方式</p>
<blockquote>
<p>很多中式发音就是因为喜欢在字母后面加上其他的音，比如s后面加i变成”子“please读成普利子</p>
</blockquote>
<ul>
<li><strong>/p/ /b/</strong></li>
</ul>
<p>peak beak、pet bed、pig big、rapid rabbit、lap lab、speak beak</p>
<ol>
<li>如果p后有元音，比如: peak就是<strong>送气音</strong></li>
<li>如果p紧跟s，比如: speak就是<strong>不送气音</strong></li>
<li>如果p后紧跟某些辅音，往往嘴巴闭上就基本完成发音国际音标:[p ]，<strong>几乎听不出这个音</strong>，比如: trapdoor, help me, leap year，<strong>无声除阻音</strong> (也称不完全爆破音)</li>
</ol>
<p><strong>/ b/<strong>是</strong>浊辅音</strong>，声带振动。</p>
<ul>
<li><strong>/t/ /d/</strong></li>
</ul>
<p>tip dip、tea deep、test desk、tap dab、bat bad、bet bed</p>
<ol>
<li>如果t后有元音，比如:top就是送气音</li>
<li>如果t紧跟s，比如: stop就是<strong>不送气音</strong></li>
<li>如果t后紧跟某些辅音，嘴巴闭上就基本完成发音国际音标: [t ]比如: setback, forget me，<strong>无声除阻音</strong>。</li>
</ol>
<p>如果想要知道音标的音位变体，见参考“英语兔”视频部分</p>
<ol>
<li>在<strong>美式英语</strong>中，元音之间的字母t(尤其是非重读音节中)，读作<strong>闪音</strong>，国际音标:[ɾ]，舌尖在上牙齿上方硬腭处，阻挡气流,轻轻—弹比如: water, better, little，听起来很像发出了/d/ 的声音。在标准英音中仍读作正常t: water, better, little。</li>
<li>在<strong>美式英语</strong>中，鼻音/n/之前的t往往读作<strong>喉塞音</strong>，国际音标:[ʔ]，声门阻住气流，像是把声音&quot;卡在喉咙&quot;里一样比如: certain, important, button，在标准英音中仍读作正常t : certain, important, button</li>
<li>在<strong>美式英语</strong>中，鼻音/n/之后的t往往基本听不见，比如: winter≈winner， interview≈innerview，甚至有的词中, t前后都有鼻音，比如: mountain，在标准英音中仍读作正常t: winter, interview, mountain</li>
<li>/ d/是浊辅音，声带振动。在美音中，/d /和/t/一样会有<strong>闪音</strong>的读法: metal约等于medal，鼻音也会影响/d/的读音: abandon.</li>
</ol>
<ul>
<li><strong>/k/ /g/</strong></li>
</ul>
<p>kit git、kate gate、cup gut、anchor anger、pick pig、peck keg</p>
<ol>
<li>如果k后有元音比如:kite，就是送气音</li>
<li>如果k紧跟s比如: sky，不送气音普通话&quot;该&quot;的声母</li>
<li>如果k后紧跟某些辅音嘴巴闭上就基本完成发音国际音标: [k ]，比如: dogtor, backdoor, make dinner，<strong>无声除阻音</strong>。</li>
</ol>
<ul>
<li><strong>/m/ /n/ /ŋ/</strong></li>
</ul>
<p>map nap、met net、meet neat、room noon、tom run、lime line、sin sing、on long、sun sung</p>
<ol>
<li>/m/在元音之前，和普通话&quot;妈&quot;的声母(汉语拼音m)相似。在元音之后，发音方式相似，但只是双唇闭拢发鼻音。</li>
<li>/n/在元音之前，和普通话&quot;拿&quot;的声母(汉语拼音n)相似/n/要比/m/的舌位高，尤其是舌端部分。在元音之后,发音方式相似，轻微通过鼻子出气。</li>
<li>/ŋ/和/n/相似,但舌后端抵住软腭，而不像/n/一样舌前端抵住上齿龈。</li>
</ol>
<p>普通话中的后鼻音往往没有英语中那么清晰明显</p>
<ul>
<li><strong>/f/ /v/</strong></li>
</ul>
<p>fat valley、fit visit、ferry very、fest vest、life drive、leaf leave</p>
<p>/f/和普通话&quot;夫&quot;的声母，基本一样/v/是&quot;声带振动版&quot;的/f/</p>
<ul>
<li><strong>/s/ /z/</strong></li>
</ul>
<p>sip zip、soon zoom、soup zoo、lesson reason、once lose、peace please</p>
<p>英语的/s/，/z/都属于所谓<strong>摩擦音</strong>，不同于爆破音，/s/和普通话&quot;斯&quot;的声母(汉语拼音s)一样，/z/和/s/很像，区别就在于/z/发音时<strong>声带振动</strong>。</p>
<ul>
<li><strong>/θ/ /ð/</strong></li>
</ul>
<p>three there、thin that、thank those、thigh the、bath bathe、breath breathe</p>
<p>和/s//z/一样，属于摩擦音，不同在于舌尖不在上下牙齿后方，而是在上下齿之间，被轻轻咬住，/θ/ /ð/区别在于/ð/需要<strong>声带振动</strong>。</p>
<ul>
<li><strong>/ʃ/ /ʒ/</strong></li>
</ul>
<p>mesh measure、fresh pleasure、leash decision、attention occasion、shall usual、shame regime</p>
<p>/ʃ/ /ʒ/属于摩擦音，/ʃ/ /ʒ/区别在于/ʒ/需要声带振动。</p>
<ul>
<li><strong>/tʃ/ /dʒ/</strong></li>
</ul>
<p>chuck jug、chop job、choke joke、cheap jeep、catch page、pitch college</p>
<p>/tʃ/可以理解为由/t/和/ʃ/构成,爆破音/t/和摩擦音/ʃ/同时发出，声带不振动。</p>
<p>/dʒ/可以理解为由/d /和/ʒ/构成,爆破音/d/和摩擦音/ʒ/同时发出，声带振动，所以也被称作破擦音。</p>
<ul>
<li><strong>/h/</strong></li>
</ul>
<p>hat、hot、high、home、house、him</p>
<p>舌面后部抬起接近软腭，形成缝隙,让气流向外通过,声带不振动。</p>
<ul>
<li><strong>/w/</strong></li>
</ul>
<p>was、why、wide、wet、we、wood</p>
<p>双唇圈起，向外凸出，气流冲出发音，声带震动，/w/往往听上去像元音/u:/或/ʊ/,所以又被称作半元音，英语w开头的单词基本都是/w/开始。</p>
<ul>
<li><strong>/r/</strong></li>
</ul>
<p>rat、red、read、rice、right、room、car、her、ear、bore、tour、pure</p>
<ol>
<li>英音中，当字母r出现在元音<strong>之前</strong>，双唇突出并<strong>圆唇</strong>,舌尖上扬，气流从舌面上方滑出,声带振动。发英语/r/的音时，舌尖指向上齿龈。</li>
<li>英音中，当字母r出现在元音<strong>之后</strong>，—般不发音或读作中央元音/ə/</li>
<li>如果r出现在单词<strong>末尾</strong>，而下一个单词以元音开头,则连读时一般读出，比如:bear it、fear us、gear up</li>
<li>美音和英音的区别在于:当字母r出现在元音之后，字母r往往会让<strong>元音r化</strong>，而在英音中则一般不发音或读作中央元音/ə/</li>
</ol>
<ul>
<li><strong>/j/</strong></li>
</ul>
<p>yes、yard、yellow、young、yoga、use</p>
<p>舌端往上抬向硬腭，与元音/i:/的舌位相似，但是更高一些。气流从舌面和硬腭之间通过，产生摩擦出声，声带振动。/j/往往听上去像元音/i:/或/ɪ/，所以又被称作半元音。但是/j/的舌端和硬腭靠得更近，有摩擦的感觉。</p>
<ol>
<li><strong>/j/的省略：<strong>在</strong>美式英语</strong>中,有些辅音(如/t/，/d/，/n/)后的/j/经常被<strong>省略</strong>，这个被称作yod-dropping(yod就是/j/)</li>
<li><strong>/j/的融合</strong>：和之前的辅音经常&quot;合在一起读&quot;,这个被称作yod-coalescence，在口语中(尤其是英音口语中)常见, &quot;标准&quot;英语一般尽量避免。有的词中,yod-coalescence已成为标准音，如: educate /'edʒukeɪt/、issue / 'ɪʃu:/ 、azure /'æʒə/</li>
<li>yod-coalescence也适用于单词之间，比如:Nice to meet you! Would you do it?</li>
</ol>
<ul>
<li><strong>/l/</strong></li>
</ul>
<p>清晰L：lack lake like look lose leak、模糊L：help mile all girl school full</p>
<ol>
<li>如果l后有元音：舌尖抵住上牙齿后方，让气流从舌两边(两侧)滑出，同时舌尖离开上牙齿后，声带振动，所以/l/被叫做&quot;舌边音&quot;或&quot;舌侧音&quot;（清晰舌边音）</li>
<li>如果l后没有元音：舌位和元音前的/l/一致，但是舌尖不离开上牙齿，声带振动（模糊舌边音）模糊L要发到位，否则导致连读时不顺畅，或者没法连读。</li>
<li>字母|还有一个版本:不发音，英语中不少单词中的l都是不发音的，比如:calm、palm、salmon、colonel、folk</li>
<li>英音美音发音区别:有的包含l的词在英式英语和<strong>美式英语</strong>中发音不同，比如:英音: million, billion, value美音: million, billion, value</li>
</ol>
<ul>
<li><strong>/ts/ /dz/</strong></li>
</ul>
<p>bats bands、dates deeds、kites kids、fights friends、hats hands、lots leads</p>
<ol>
<li>/ts/可以理解为由/t/和/s/构成。爆破音/t/和摩擦音/s/同时发出，声带不振动。</li>
<li>/dz/可以理解为由/d/和/z/构成，爆破音/d/和摩擦音/z/同时发出，声带振动。</li>
</ol>
<p>所以这两个音被归类为所谓破擦音(爆破＋摩擦)</p>
<ul>
<li><strong>/tr/ /dr/</strong></li>
</ul>
<p>trip drip、true drew、tree dream、try dry、country laundry、pantry hundred</p>
<ol>
<li>/tr/可以理解为由/t/和/r/构成。爆破音/t/和摩擦音/r/同时发出，声带不振动。</li>
<li>/dr/可以理解为由/d/和/r/构成。爆破音/d/和摩擦音/r/同时发出，声带振动。</li>
</ol>
<p>所以这两个音被归类为所谓破擦音(爆破＋摩擦)</p>
<h1>英语发音技巧</h1>
<blockquote>
<p>这些发音技巧能够让你的发音更加地道，同时也能很大程度上提升你的英语听力</p>
</blockquote>
<h2 id="连音">连音</h2>
<p>单词(辅音结尾)+单词(元音开头)如：not at all.(“闹太套”),中文不习惯连读，我们读“我爱天安门”不会像外国人那样连读成“外天门”。这就是英语听不准确的重要口语习惯和原因。也就是说，<strong>辅音单词结尾的辅音要发到位，不加上不存在的元音</strong>，然后自然读下一个单词就能“连读”。</p>
<p>💡连读不是创造一个音，而是两个音结合产生的结果。试着平滑地读I am，你就会感受到/j/的发音，这就是<strong>连音的本质</strong>。如果<strong>你的发音不标准，就不会自然而然地读出连音</strong>。</p>
<p><strong>加音规则</strong></p>
<p>注意是先有加音现象，再总结出规律。</p>
<ol>
<li>元音+元音：元音与元音连读容易糊，加上一个之前不存在的“过渡音”使得加音连贯。
<ul>
<li>/u:/, <strong>/ʊ/</strong>,<strong>/aʊ/</strong>, <strong>/əʊ/</strong>+元音:+/w/。如：just do it.</li>
<li>/i:/,<strong>/ɪ/</strong>,<strong>/eɪ/</strong>,<strong>/aɪ/</strong>,<strong>/ɔɪ/</strong>+元音:+/j/。如： I am.</li>
<li><strong>/ə/</strong>,<strong>/ɑ:/</strong>,<strong>/ɔ:/</strong>+元音:+/r/。主要是英式英语用，美式英语很少。如 the idea of；美式英语主要是字母r+元音，如bear it.连读但是不加音。</li>
</ul>
</li>
<li>辅音+元音(词尾辅音 + 词首元音）： travel agency</li>
</ol>
<h2 id="同化">同化</h2>
<ol>
<li>逆行同化(前面的音受到后一个音的影响)
<ol>
<li>无声除阻(不完全爆破)：/k/ /t/ /d/+辅音，爆破音不发音 如:look back</li>
<li>浊音变清音：如 have to :直接变成/f/+/t/,这样比原来的浊音更好发音。</li>
<li>双唇化：如in person.受到p这个要闭唇的音印象，读起来变成了 im person。</li>
</ol>
</li>
<li>顺行同化(后面音受到前面影响)
<ol>
<li>复数词尾：如books 一般会读成ks而不是kz。</li>
</ol>
</li>
<li>互相同化：
<ol>
<li>融合发音:/s/+/j/ = <strong>/ʃ/</strong>;例如:God bless you;/z/+/j/ =  <strong>/ʒ/</strong>;例如as you wish;/t/+/j/ = <strong>/tʃ/</strong> ;例如Nice to me you;/d/+/j/ = <strong>/dʒ/</strong>;例如Did you do it?</li>
<li>辅音延长：当前面一个音和后面一个音是同一个音时。只发一个音(这里的音是指<strong>音标</strong>不是字母)，但是要延长：如fish shop.这里前后都是sh</li>
</ol>
</li>
<li>完全失爆（词尾爆破音( p b t d k g)+ 词首爆破音( p b t d k g)：
<ol>
<li>good question</li>
</ol>
</li>
</ol>
<h2 id="异化">异化</h2>
<p>常见于/s/+/t/、/s/+/k/、/s/+/p/的组合。<strong>严格来说不是浊化</strong>，而是将这些音变成不送气的音，但是只是发音的话就是不用考虑这些</p>
<ol>
<li>r使前面的元音r化：如door 使前一个r消失，如surprise变成su®prise.</li>
<li>具体例子sp+元音：
<ol>
<li>How do you spend your leisure time?</li>
<li>sk+元音：i’m so scared</li>
<li>st + 元音：Stand up and study hard.</li>
<li>str+ 元音:  He struck me with a stick</li>
</ol>
</li>
</ol>
<h2 id="省音">省音</h2>
<ol>
<li>偷懒不读某一个或者是一些音：如interesting,这类往往可省可不省，省多少看个人说话习惯。</li>
<li>必须省音。如debt\subtle\know\knee\write\wrong……这些词中b\k\w都是省略不读的。</li>
<li>词与词之间省略：比如last year就只读las year.t直接省略。</li>
<li>还有/t/、/d/等(词尾)爆破音也经常省略。如：have 的/h/(这被称为<strong>h击穿</strong>)。ing中的/g/，比如 Are you listenin’?这里打‘就说明省去了g</li>
</ol>
<h2 id="缩读">缩读</h2>
<p>缩写表示可以缩读：如 I am=I’m,I have=I’ve 这些词往往在英语听力的时候读的很快不容易听到或者是听完整。比如wanna=want to, going to=gonna,because='cause还有许多缩写形式的单词或者短语都是这种形式。还有很多类似的都是，比如don’t know=dunno、give me=gimme、would have would’ve/would’a、you and I=you 'n’l、come on =c’mon</p>
<h2 id="弱读">弱读</h2>
<p>弱读非常重要，是中国人听不清英语的关键。<br>
弱读不是声音变小，而是将元音改变了,这样能够让语句发音更轻松自然，不至于像中文那样“字正腔圆”导致读起来上气不接下气。</p>
<p>例句：What <strong>do</strong> you want <strong>to do</strong>?<strong>From</strong> <strong>what</strong> I <strong>can</strong> tell,you <strong>must</strong> be tired <strong>of</strong> it,<strong>but</strong> I’m not,so <strong>would</strong> you like me <strong>to do</strong> it <strong>for</strong> you?<br>
/d<strong>ə</strong> t<strong>ə</strong> fr<strong>ə</strong>m w<strong>ə</strong>t k<strong>ə</strong>n m<strong>ə</strong>st <strong>ə</strong>v b<strong>ə</strong>t w<strong>ə</strong>d f<strong>ə</strong>/</p>
<blockquote>
<p>弱读时，单词的中间的元音一般会变成中央元音/<strong>ə/</strong></p>
</blockquote>
<h2 id="节奏">节奏</h2>
<p>💡英语是重音等时语言</p>
<p><strong>英语语句中重读音节之间的时长基本相等</strong>，也就是说英语句中词语所花时间是由重读音节数量决定的。举例：Rabbits | eat | carrots.\A rabbit is | eating some | carrots.\The <strong>rabbit</strong> has been | <strong>eating</strong> some of the | <strong>carrots</strong>.分成三个音节，加粗部分为重读音节<br>
也就是说，这是三个音节之间时长相等，根据之间的单词个数决定要不要快速读或者是连读，这样其实也体现了中央元音/ə/的重要性，就是为了和重读音节相对应的。</p>
<p>总而言之记住一句话：英语句子中的非重读音节数量远远大于重读音节数量。</p>
<h2 id="语调">语调</h2>
<p>💡语调基于节奏</p>
<p>语调就是英语句子声调在哪里升高哪里降低。但是不是中文的四声或者五度标记法。<br>
语调就是表达说话人的情感，不需要死记(不一定升调就是提问，降调就是丧气)，多听多说就能理解。</p>
<h3 id="升调">升调</h3>
<p>这里用☑表示升调，放在哪个单词后哪个单词就升调，一般用来表达态度/情感/陈述/疑问/强调等</p>
<p>举例</p>
<ol>
<li>一般疑问句：Are you kidding me☑ ？</li>
<li>陈述形式的提问：Rabbits eat carrot☑ ?</li>
<li>反义疑问词中的附加问句：you are right,are not you☑ ?</li>
<li>列举中最后一个元素之前的元素：Are rabbits red☑，yellow☑，blue☑，green☑,or white?</li>
<li>礼貌请求:Tell me,please☑</li>
<li>句子中未完成的部分：The rabbit ate a carrot☑ and then slept.</li>
</ol>
<h3 id="降调">降调</h3>
<p>用[\]表示降调</p>
<ol>
<li>特殊疑问句(非yes/no问题)：what is your name[\]?</li>
<li>陈述事实或者回答问题： I see a white rabbit[\].</li>
<li>感叹：what a beautiful leaf[\]!</li>
<li>命令：put the girl down[\]!</li>
<li>列举中最后一个元素：反义疑问句前一部分：Rabbits like to eat,play,sleep and run[\].</li>
<li>反义疑问句前面一部分：Rabbit eat carrots[\],don’t they?</li>
<li>作为回答/附和/确认的问句形式：The rabbit ate all the carrots. Did it[\]?</li>
<li>已经知道提问的答案：can you call me at 6[\].</li>
<li>问句形式表礼貌，并非真的在问问题：Would you pass me the salt[\]?</li>
<li>不满、愤怒：Is that what you think[\]?</li>
</ol>
<p>参考音节</p>
<p>TU表示重读，tu表示弱读。同样适用于句子和词组。</p>
<ol>
<li>单音节 TU：如two!two?</li>
<li>双音节 TU tu： 如rabbit!rabbit?</li>
<li>双音节 tu TU：如sit down!sit down?</li>
<li>三音节 TU tu tu：如possible!possible?</li>
<li>三音节 tu TU tu：如computer!computer?</li>
<li>三音节 tu tu TU：如engineer!engineer?</li>
</ol>
<h1>自然拼读(Phonics)</h1>
<p>就是看字母，<strong>猜读音</strong>。这部分内容属于技巧向，对英语口语与听力有帮助。</p>
<p>以下内容主要讨论一般情况，特殊情况请参考词典。</p>
<h2 id="开音节与闭音节">开音节与闭音节</h2>
<p><strong>概念解析</strong>：</p>
<p>音节：由音素组合成的<strong>最小</strong>最自然的语音单位，比如rabbit的音节分别是rab和bit。</p>
<p>闭音节：以辅音结尾的音节。比如baby中的by音节。注意这里的辅音不是指字母而是指音标。</p>
<p>开音节：以元音结尾的音节。比如baby中的ba音节。</p>
<p>重读音节：被强调的音节就是重读音节，往往声音更大，元音也被拉长。比如rabbit.其音标为/‘ræbɪt/ 这里的’就是用来标记重读音节的，所以rab音量较大，元音也延长。ˌ为次重读音节，在重读与非重读之间。比如accidental，其音标为/ˌ æksɪ’dentl/</p>
<p>非重读音节：与重读音节相反。</p>
<p>相对开音节：以不发音的元音字母e结尾的闭音节。</p>
<h2 id="单个字母">单个字母</h2>
<blockquote>
<p>以下图都是从英语兔公众号下载而来</p>
</blockquote>
<p>辅音字母</p>
<p><img src="https://s2.loli.net/2024/11/26/s6PErIDYCQJL4Z5.png" alt="001_字母发音_01.png"></p>
<p>元音字母</p>
<p><strong>单个元音字母在重读开音节里读元音字母本身的读音</strong></p>
<p><img src="https://s2.loli.net/2024/11/26/ohsaKvIrCBfPZdx.png" alt="001_字母发音_02.png"></p>
<p><strong>单个元音字母在相对开音节里读元音字母本身的读音</strong> 比如bate</p>
<h2 id="字母组合">字母组合</h2>
<p>辅音组合</p>
<p><img src="https://s2.loli.net/2024/11/26/iCemwkp4ySY6Hjb.png" alt="001_字母发音_03.png"></p>
<p>元音组合</p>
<p><img src="https://s2.loli.net/2024/11/26/3BkEcelpLydK2sO.png" alt="001_字母发音_04.png"></p>
<p>以上这些只是技巧向，真正要学好英语口语还是要大量的输入与输出。</p>
<h1>参考</h1>
<ol>
<li><a href="https://www.jiwake.com/yinbiaofayin/">英语音标发音表-英语48个音标在线读 (jiwake.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/457728471">【笔记】英语兔的DJ音标整理 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1iV411z7Nj?p=28&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">【全网最适合中国人的免费音标课(纯干货, 超详细!)】</a></li>
<li><a href="https://www.bilibili.com/video/BV1SZ4y1K7Lr?p=7&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">【你必须知道的英语发音技巧(让你的口语更纯正, 更地道!)】</a></li>
<li><a href="https://www.bilibili.com/video/BV14841117gz?p=4&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">英语自然拼读极简教程（免费、简洁、高效 | 半小时内打牢基础</a></li>
</ol>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法(英语兔版)</title>
    <url>/2024/10/11/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1>英语语法综述</h1>
<p>💡语法的目的在于造句，而英语句子的核心在于动词</p>
<p>英语中所有的句子都可以视为是简单句的组合，而简单句基本上都服从一个模板：<strong>什么+怎么样</strong>。</p>
<p>这两个代表不同的句子成分(clause elements)，前者代表主语(subject),后者代表谓语(predicate)，即主语+谓语</p>
<p>而谓语代表的是广义的动作/发生了什么事,谓语的核心在于谓语<strong>动词</strong>。提醒：谓语≠谓语动词,谓语是除主语之外的，而谓语动词只是一个动词。</p>
<p><strong>所以要学好语法先从动词开始</strong>。</p>
<hr>
<h1>动词(verbs)</h1>
<h2 id="动词的三大本领">动词的三大本领</h2>
<ol>
<li>表示动作的时间</li>
<li>表示动作的状态</li>
<li>表示动作的假设，情感等</li>
</ol>
<p><strong>动词在五大句型中的作用</strong></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以独立完成的动作(主语+不及物动词)</td>
<td>主语+不及物动词</td>
<td>I sleep</td>
</tr>
<tr>
<td>有一个动作的承受者</td>
<td>主语+单及物动词(monotransitive verbs)+宾语(object)</td>
<td>I like you</td>
</tr>
<tr>
<td>有两个动作承受者</td>
<td>主+双及物动词(ditransitive verbs)+间接宾语+直接宾语</td>
<td>I will teach you English.这里的<strong>you</strong>是间接宾语，<strong>English</strong>是直接宾语</td>
</tr>
<tr>
<td>只有一个动作承受者,但是需要补充</td>
<td>主语+复杂及物动词+宾语+补语(complement)</td>
<td>I think you smart</td>
</tr>
<tr>
<td>非动作</td>
<td>主语+系动词(link verbs)+(主语)补语/表语</td>
<td>he looks smart.将smart赋予给主语，再加上系动词的部分意义。</td>
</tr>
</tbody>
</table>
<p>💡五大句型区分关键在于动词之后需要几个对象才能表达完整意思</p>
<p><strong>动词分类</strong></p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">一般分类</button><button type="button" class="tab">按动作承受者分类</button><button type="button" class="tab">按状态动作分类</button></div><div class="tab-contents"><div class="tab-item-content active"><table>
<thead>
<tr>
<th>词性</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>实义动词</td>
<td>eat</td>
</tr>
<tr>
<td>系动词</td>
<td>be</td>
</tr>
<tr>
<td>助动词 辅助构成谓语动词</td>
<td>have</td>
</tr>
<tr>
<td>情态动词</td>
<td>must</td>
</tr>
<tr>
<td>非谓语动词)不定式、过去分词、现在分词、动名词)</td>
<td>running</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>及物动词</td>
<td>eat vt.吃</td>
</tr>
<tr>
<td>不及物动词</td>
<td>run vi.跑</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>动作动词</td>
<td>eat</td>
</tr>
<tr>
<td>状态动词</td>
<td>feel v.感觉 并没有明显的动作</td>
</tr>
</tbody>
</table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="动词时态">动词时态</h2>
<p><strong>时态：时间+状态</strong>。前者表明动作发生的时间(过去，现在，将来和过去将来),后者表明动作发生的状态(进行时、完成时、完成进行时、一般时)。<br>
四种动词时间与四种时态排列组合就会产生16种时态。</p>
<p>完成状态的<strong>理解在于强调“影响”</strong>，比如<code>I have eaten breakfast.</code> 暗示在过去的某个时间到现在(have的时间)我已经吃了早饭，暗示我还不饿。</p>
<h3 id="现在类">现在类</h3>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">一般现在</button><button type="button" class="tab">现在进行</button><button type="button" class="tab">现在完成</button><button type="button" class="tab">现在完成进行</button></div><div class="tab-contents"><div class="tab-item-content active"><blockquote>
<p>这里的一般现在严格来说是现在一般时，只是顺序颠倒了一下，后面同理。</p>
</blockquote>
<p><strong>含义：表达事实|表达习惯|表达预计发生的事</strong></p>
<table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>+动词原形</td>
<td>I eat carrots.</td>
</tr>
<tr>
<td>+动词原形+第三人称单数</td>
<td>she eats carrots.</td>
</tr>
<tr>
<td>事实陈述</td>
<td>The sun rise in the east 习惯:I play basketball我打篮球(隐含我有打篮球的习惯) 预计发生的事: The bus leaves at 8 PM tonight.</td>
</tr>
</tbody>
</table>
<p>误区：一般现在不代表现在正在做，I eat carrots. 意思是我吃胡萝卜.<em>一般代表的是一种默认，或者是未指明</em></p></div><div class="tab-item-content"><p><strong>助动词be的变位+动词现在分词</strong></p>
<table>
<thead>
<tr>
<th>词性</th>
<th>形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>助动词</td>
<td>1. 系动词 am,is,are…… 2. 作助动词，构成时态</td>
</tr>
<tr>
<td>动词现在分词</td>
<td>1. 通常：+ing 2. 特殊：变化+ing→不规则变化很多都是为了发音而妥协的。I am lying != I am lieing</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><p><strong>助动词have的变位+动词过去分词</strong></p>
<table>
<thead>
<tr>
<th>词性</th>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Have</td>
<td>1. 实义动词：有 2. 助动词构成时态</td>
<td>2. The rabbit has eaten a carrot.</td>
</tr>
<tr>
<td>动词过去分词</td>
<td>1. 通常：+ed 2. 特殊：变化+ed/不规则变化</td>
<td>look-&gt;looked/eat-&gt;ate</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><p><strong>现在完成+进行时==have的变位+been+动词现在分词.意思是已经做了，而且还要继续做  。</strong> 例子：I have been eating carrot.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>💡时态都是在现在类基础上将时间往前(或后)推移，对应时间更改谓语动词即可。</p>
<hr>
<h3 id="过去类">过去类</h3>
<p>💡本质就是现在类的助动词(或者情态动词、动词等)变换时间(比如have变成had,is变成was,may变成might)</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">一般过去</button><button type="button" class="tab">过去进行</button><button type="button" class="tab">过去完成</button><button type="button" class="tab">过去完成进行</button></div><div class="tab-contents"><div class="tab-item-content active"><table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>过去式(规则的一般+ed)</td>
<td>look-&gt;looked</td>
</tr>
<tr>
<td>不规则变化(不用刻意记，用来写的并不多)</td>
<td>come-&gt;came</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><p><strong>助动词be的变位+动词现在分词</strong></p>
<table>
<thead>
<tr>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>注意be的变位不再是现在时态的只变人称，还要变为相应的时态。<em>即be变成对应的人称过去式</em></td>
<td>she was watching TV</td>
</tr>
<tr>
<td>区别：现在完成vs一般过去 前者强调的是动作完成了吗，后者强调的是动作有没有发生。</td>
<td>前者的例句I have gone to Beijing.(我已经去了北京(暗示没回来))，后者的例句I went to Beijing.(我去过北京)暗示回来了))</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><p><strong>同理，见现在完成部分，是助动词have的变位(只有had)+动词过去分词</strong></p></div><div class="tab-item-content"><p><strong>had+been+动词的现在分词</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>不规则动词列表：在 本电脑根目录下obsidian内附件集/英语/文档/不规则变化.pdf。读者可以点击此链接<a href="https://www.yingyutu.com/">英语兔 (yingyutu.com)</a> 在英语兔公众号下载对应笔记。</p>
<hr>
<h3 id="将来类">将来类</h3>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">一般将来</button><button type="button" class="tab">将来进行</button><button type="button" class="tab">将来完成</button><button type="button" class="tab">将来完成进行时</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>一般用于非常确定会发生的事</strong></p>
<table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>will(或者是shall)+动词原形</td>
<td>I will eat a carrot.</td>
</tr>
<tr>
<td>助动词be的变位+going+to+动词原形</td>
<td>1. 原样：I am going to take a shower. 2. 省去going：you are to eat a carrot 3. 用about代替going：I am about to chat with him.</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><p><strong>will+be+动词的现在分词)在将来的某一个时间段，某个动作正在进行)</strong>  例如：I will be eating a carrot for lunch tomorrow from 1 PM to 3 PM</p></div><div class="tab-item-content"><p><strong>will+have+动词的过去分词</strong> 例子(以下用<strong>ex</strong>表示)：If suddenly you forget me. Do not look for me,for I shall already have forgotten you.</p></div><div class="tab-item-content"><p><strong>will+have+been+动词的现在分词</strong> ex:I will have been eating carrots for 2 hours by 3 PM tomorrow.这里要表达的意思就是：我确定明天下午三点钟时，我不但已经吃了俩钟头胡萝卜(也就是从明天下午1点开始吃)而且还要继续吃.</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<hr>
<h3 id="过去将来类">过去将来类</h3>
<p><em>过去将来可能是现在的过去，也可能是现在的未来。</em></p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">过去将来一般</button><button type="button" class="tab">过去将来进行</button><button type="button" class="tab">过去将来完成</button><button type="button" class="tab">过去将来完成进行</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>would+动词原形|或者是助动词be的变位+going to。</strong></p>
<table>
<thead>
<tr>
<th>would形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Will的过去式</td>
<td>I would eat a carrot.</td>
</tr>
<tr>
<td>虚拟语气，表达和事实相反。</td>
<td>I said I would eat a carrot for lunch. 我之前就说过我会午饭吃胡萝卜，而午饭时间对于之前我说那句话的时间来说是在将来，但至于现在午饭时间有没有到，不得而知</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><p><strong>同理，在将来进行时前面+would</strong></p></div><div class="tab-item-content"><p><strong>同理，在将来完成时前面+would</strong></p></div><div class="tab-item-content"><p><strong>同理，在将来完成进行前面+would。</strong></p>
<p>中文举例：在这之前，张三说下个月的某一天，你一定会看到我犯完罪，而且还会一直犯下去 在这之前表示过去，说下个月的某一天表明是将来，结合就是过去将来(时间),而犯完罪而且犯下去表明动作已经完成，而且会继续执行，表明动作的状态是完成进行，前后结合，就是过去将来完成进行时态。ex:l said I would have been eating lunch for 2 hours by 1 PM tomorrow/yesterday.我)之前)说我明天/昨天下午1点前会已经吃了俩钟头中饭(我之前说我会明天/昨天下午1点时在吃中饭这个过程中,之前吃了2小时,之后还会继续吃)</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<hr>
<h2 id="动词语气-mood">动词语气(mood)</h2>
<p>概念：表示动作的假设，情感等。</p>
<p>难点：虚拟语气。</p>
<p><strong>语气分类</strong></p>
<ol>
<li>陈述语气：描述现实 <code>ex:The rabbit ate a carrot.</code></li>
<li>祈使语气：命令/请求
<ol>
<li>用第二人称(”你”)和一般现在时态 如：<code>ex:(please)eat the carrot.</code></li>
<li>去掉“你”，并保持动词原形 如：<code>ex:you don't eat it=&gt;Don't eat it.</code></li>
</ol>
</li>
<li>虚拟语气：
<ol>
<li>理解：人主观的意愿，往往与现实事实相反.比如“如果我知道他是这样的人，我就不会和他在一起了。”言下之意就是我不知道他是这样的人(<strong>现实事实</strong>),而假设了我知道他是这样的人(<strong>主观意愿</strong>)我会做什么。</li>
<li>第一大用法：虚拟语气表“不可能”假设</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>时间</th>
<th>条件句</th>
<th>主句</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr>
<td>与现实相悖的想象，主观意愿</td>
<td>过去式)如果是be，一律改为were，不管什么人称)</td>
<td>Would+动词原形)注意，would可以用should、could、might替代，它们分别是shall、can、may的过去式)</td>
<td>If I were you,I would give this video a thumbs-up。                        if句是条件句，后面的句子就是主句)造成的结果)。</td>
</tr>
<tr>
<td>和过去事实相反</td>
<td>had+动词过去分词</td>
<td>Would have+动词过去分词</td>
<td>If I had watched this video before,I would have aced my test.</td>
</tr>
<tr>
<td>和将来事实相反(可能性很小)</td>
<td>should+动词原形(should其实是shall的过去式，也可以用were to +动词原形取代)</td>
<td>Would+动词原形</td>
<td>if I should meet thee after  long years,how should I greet thee?</td>
</tr>
</tbody>
</table>
<p>分析可得，无论是哪一种虚拟语气，他们都要使用<strong>过去式(即所在的时间前移)</strong> -如对现在假设变成过去式，对过去假设变成过去完成时。  这种过去式可能是谓语动词的过去式，也可能是will，shall和have的过去式，由此提醒：<strong>不要看见过去式就认为动作发生在过去</strong>，也有可能是虚拟的，实际并未发生的。</p>
<p>严格来说，should做shall的过去式时没有“应该”的含义，做情态动词的时候才有，只不过为了翻译流畅才添加含义，本来是无实际含义的。</p>
<ol start="3">
<li>第二大用法：虚拟语气表达愿望、请求、建议、命令等(希望某个动作|事情发生)。</li>
<li>Wish <code>ex: I wish that I were a rabbit.</code> Would rather同理</li>
<li><strong>特例</strong>：demand、suggest、insist、order用虚拟语气是should+动词原形。
<ol>
<li>suggest insist order <code>ex:I demand that you)should)give me a carrot</code></li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>时间</th>
<th>句子结构</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr>
<td>对现在的愿望</td>
<td>Wish+动词过去式</td>
<td>I wish that I were a rabbit.</td>
</tr>
<tr>
<td>对过去的希望</td>
<td>Wish+had/would have+动词过去分词</td>
<td>I wish (that)I had eaten the carrot.(我希望你过去吃了那个胡萝卜，言下之意就是在过去你没吃)</td>
</tr>
<tr>
<td>对将来的希望</td>
<td>Wish+should/might/could/would+动词原形</td>
<td>I wish (that)I could eat the carrot.</td>
</tr>
</tbody>
</table>
<p>再次强调，<strong>虚拟语气</strong>是和陈述语气并列的，所以不同于陈述语气的客观事实描述，虚拟语气描述的是非事实的，主观的，所以不能使用一般时，在翻译和写作时尤其要注意这点。</p>
<h2 id="非谓语动词-non-finite-verbs">非谓语动词(non-finite verbs)</h2>
<p>定义：谓语动词有另外的名字：限定性动词)也就是被三单、时态等限制了形式)，与之相对的就是非限定动词，也就是非谓语动词。</p>
<p><code>ex:I am a talking student.</code>这里的talking不被时态、人称所限制，没有动词的本领，也就是变成了非谓语动词</p>
<hr>
<p>💡谓语动词是句子的核心，也就是说，在一个简单句子中谓语动词只能有一个(在有<strong>并列关系</strong>的时候可以有多个谓语动词)，但是非谓语动词不限个数。</p>
<p><strong>非谓语动词分类</strong></p>
<h3 id="动词不定式">动词不定式</h3>
<p><strong>to+动词原形。表示将要发生的动作</strong></p>
<table>
<thead>
<tr>
<th>主要类型(形式)</th>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 特殊情况to可以省略：make\help\let……一感二听三让四看半帮助。</td>
<td>不定式作主语</td>
<td>To eat a carrot every day is good for the rabbit.</td>
</tr>
<tr>
<td></td>
<td>不定式作直接宾语</td>
<td>The rabbit likes to eat carrots.</td>
</tr>
<tr>
<td></td>
<td>不定式作间接宾语</td>
<td>The rabbit expected the wolf to eat a carrot.强调动作已经发生(全过程)</td>
</tr>
<tr>
<td></td>
<td>不定式作宾补</td>
<td>The rabbit has a lot of carrots to eat.这里的to eat修饰的是carrots。</td>
</tr>
<tr>
<td></td>
<td>不定式作宾语</td>
<td>1. 表原因：<code>I was surprised to get a thumbs-up.</code> 2. 表目的：<code>I will do anything to get a thumbs-up.</code> 3. 表结果：<code>I got enough thumbs-up to make another video.</code></td>
</tr>
<tr>
<td>2. 高级不定式:to+动词原形(”状态”)</td>
<td>\</td>
<td>To be eating a carrot\To have been eating a carrot</td>
</tr>
</tbody>
</table>
<h3 id="动名词">动名词</h3>
<p><strong>动词原形+ing，本质是名词–主动、进行</strong></p>
<table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>作主语</td>
<td>Eating carrots is healthy for the rabbit</td>
</tr>
<tr>
<td>作宾语</td>
<td>the rabbit likes eating carrots.</td>
</tr>
<tr>
<td>作表语</td>
<td>The rabbit’s hobby is growing carrots.</td>
</tr>
<tr>
<td>作定语</td>
<td>a sleeping pill 表示名词的性质、功能或者用途.等价于 a pill for sleeping</td>
</tr>
</tbody>
</table>
<p>需要注意的是，虽然理论上任何动词不定式和动名词可以充当另一个动词的宾语，但是实际上不是，如enjoy不能用不定式充当宾语等。同样，也有些动词不能直接接动名词，而是要借助介词，比如  <code>ex:The rabbit is looking forward to eating carrots</code> 这里的to是介词而不是不定式的to。</p>
<h3 id="固定搭配">固定搭配</h3>
<p><strong>不定式与动名词的使用范围</strong></p>
<ol>
<li>如stop to do/doing,forget to do/doing,remenber to do/doing……，前者指怎样(停止、记得……)去做某事)还没做)，后者指怎样去做某事)已经做了)</li>
<li>感到用ed，令人ing.如interested与interesting</li>
</ol>
<h3 id="现在分词">现在分词</h3>
<p><strong>本质是形容词–主动、进行</strong></p>
<table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>作表语</td>
<td>the rabbit is charming  很多的形容词实际上就是现在分词</td>
</tr>
<tr>
<td>作宾补</td>
<td>The wolf saw the rabbit eating a carrot.强调动作进行的状态。即狼看到兔子正在吃</td>
</tr>
<tr>
<td>作状语</td>
<td>Not knowing what to eat,the rabbit skipped lunch. 可以表示原因、时间、伴随等关系</td>
</tr>
<tr>
<td>作定语</td>
<td>a sleeping rabbit. 表明兔子的状态是睡觉，但是不同于动名词作定语。</td>
</tr>
</tbody>
</table>
<h3 id="过去分词">过去分词</h3>
<p><strong>暗含被动关系，不表示过去时间</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">作<strong>后置定语</strong></td>
<td>The carrot cake eaten by the rabbit is delicious</td>
</tr>
<tr>
<td style="text-align:left">作表语</td>
<td>The rabbit is interested in growing carrots.</td>
</tr>
<tr>
<td style="text-align:left">作宾补</td>
<td>The rabbit found his carrot stolen.</td>
</tr>
<tr>
<td style="text-align:left">作状语</td>
<td>1. 表地点：Seen from the hill,the carrot field looks beautiful.  2. 表原因：Born in a rabbit family,the rabbit has been growing carrots all his life. 3. 表条件：Given another chance,the rabbit would go to the wolf’s party.`</td>
</tr>
</tbody>
</table>
<p>判断谓语使用现在分词还是过去分词，看主语是主动还是被动完成动作。<code>ex:seen from the hill,the carrot field looks beautiful</code> 田地是“被看&quot;，所以使用过去分词</p>
<hr>
<p>特例：独立主格：ex:The work finished,the rabbit went home.这里went是谓语动词，finished是非谓语动词(过去分词)，修饰work.</p>
<hr>
<h3 id="扩展：独立主格">扩展：独立主格</h3>
<p>我们来看下这个句子<code>because he was invited by the wolf,the rabbit decided to go to the party.</code> 如果用过去分词来表示(因为这里表原因而且是被动)，则变为<code>Invited by the wolf,the rabbit decided to go to the party</code>。</p>
<p>但如果是主动关系呢？</p>
<p>我们来看一下这个句子<code>because the wolf invited him,the rabbit decided to go to the party.</code> 这是一个完整的句子，如果我们要将前面的句子简化。则改为<code>The wolf inviting him,the rabbit decided to go to the party.</code><br>
The rabbit句子是句子的主干，前面句子表示原因，invite这个动作由the wolf发出，所以是主动关系-使用现在分词。The wolf是前面句子的逻辑主语，也就是独立主语后面不能用动词原形。</p>
<p>独立主格的结构：名词|代词+be动词的现在分词being，然后再把being省掉。<br>
例如：<code>The rabbit came in,carrot (being) in hand</code><br>
特殊独立主格：with+宾语+宾语补足语<br>
<code>With the work finished,the rabbit went home.</code> ⇒ the work finished,the rabbit went home.</p>
<p>由此可得，<u>独立主格是和非谓语结构紧密相连的，更像是非谓语动词省去be的简化形式</u>，不过省略的前提是存在逻辑主格。</p>
<h2 id="助动词">助动词</h2>
<p>定义：辅助动词构成谓语但是本身“不能“作谓语动词的词就是助动词。</p>
<blockquote>
<p>这里的“不能”不是说助动词不能作动词，助动词作实义动词时可以作谓语动词，比如do，be等.</p>
</blockquote>
<p><code>ex:the rabbit will eat a rabbit.</code> 谓语动词本身无法表达“将来”的时间，所以需要借助will来构成“将来时”。</p>
<p>在很多语法书中将情态动词与助动词单独分类，但实际上<strong>情态动词也是起辅助作用，“不能”单独做谓语动词</strong>，所以本质上情态动词还是助动词。这里我就将两者作为一类</p>
<h3 id="助动词分类">助动词分类</h3>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">1.基本</button><button type="button" class="tab">2.情态动词</button><button type="button" class="tab">3.半助动词</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>be、do、have</strong></p></div><div class="tab-item-content"><ol>
<li>
<p>can/could：</p>
<ol>
<li>
<p>前者是有能力，后者是过去有能力，现在有没有不知道 <code>ex:I can  kill a wolf</code></p>
</li>
<li>
<p>前后都可以表示请求、许可，后者更加委婉。 <code>ex:Could i borrow your book?</code></p>
</li>
<li>
<p>前后都表示可能性，后者表示对过去的推测/现在的可能性  <code>ex:Angthing can happen.</code></p>
</li>
</ol>
</li>
<li>
<p>may/might：</p>
<ol>
<li>表示请求或者许可，后者更礼貌  <code>ex:May I borrow your book?</code></li>
<li>表示可能性，后者的可能性更小 <code>ex:He may be at home.</code></li>
<li>表示祝愿 <code>ex:May you succeed!</code> 这种情况不使用might</li>
</ol>
</li>
<li>
<p>must</p>
<ol>
<li>表示必须  <code>ex:you must do your homework.</code></li>
<li>表示禁止must not 意思是必须不、绝对不，否定的意思更强烈  <code>ex:you must not smoke here</code></li>
<li>表示推测，而且是肯定的推测  <code>ex:The light is on.The rabbit must be at home.</code></li>
</ol>
</li>
<li>
<p>will/would：</p>
<ol>
<li>构成将来时 <code>ex:I will have breakfast.</code></li>
<li>表示请求，后者更加委婉 <code>ex:Would you give me a cup of coffee?</code></li>
<li>表推测，假设，后者的不确定性更大建议 <code>ex:Ask him,He will konw.</code></li>
</ol>
</li>
<li>
<p>shall/should：</p>
<ol>
<li>shall可以构成将来时  <code>ex:I shall be there at 9AM.</code></li>
<li>shall表示请求或者征求意见  <code>ex:Shall we go to the movie?</code></li>
<li>表示警告，命令  <code>ex:You shall not pass!</code></li>
<li>should表示应当</li>
<li>should表示有一定根据的推测  <code>ex:It should rain tomorrow.</code></li>
<li>should表示“竟然”   <code>ex:It's surprising that he should be late.</code></li>
<li>虚拟语气  <code>ex:If it should rain tomorrow,I wouldn't go.</code></li>
</ol>
</li>
<li>
<p>ought to：应该，语气比should更强烈  <code>ex:We ought to finish it first.</code></p>
</li>
<li>
<p>dare/dared ：</p>
<ol>
<li>实意动词：敢，冒险</li>
<li>情态动词：敢   <code>ex:How dare you.</code></li>
</ol>
</li>
<li>
<p>need：</p>
<ol>
<li>需要</li>
<li>既可以作实义动词，也可以作情态动词 <code>ex:Students need study.</code> == <code>ex:Student need to study.</code>  前面的need是情态动词，后面的是实义动词</li>
</ol>
</li>
<li>
<p>used to：表过去的动作，往往是习惯或者是重复的动作，</p>
</li>
</ol></div><div class="tab-item-content"><table>
<thead>
<tr>
<th>形式</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>be able to</td>
<td>表示能力，可以表示将来的能力|特别注意的是，was/were able to 表示成功做成</td>
<td>I’ll be able to reach school on time|I was able to reach school on time because I left home early.</td>
</tr>
<tr>
<td>be going to|be about to|be to</td>
<td>表示将要做某事，第一个表示计划做某事，第二个是马上做某事，第三个是被命令做某事</td>
<td>I am going to eat dinner at 6 PM today.</td>
</tr>
<tr>
<td>had better</td>
<td>最好做，缩写是’d better</td>
<td>you’d better listen to me.</td>
</tr>
</tbody>
</table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="系动词">系动词</h2>
<p>定义：相当于C语言中的赋值符号=，将后者赋予前者</p>
<p>如：I am a rabbit 就是将rabbit赋予给我，即我=rabbit。某某起来的系动词(<code>ex:he looks handsome</code>)与此相同，只不过在翻译的时候增加了系动词的意思。</p>
<h2 id="使役动词">使役动词</h2>
<p>定义：意思是使、让、令的词语，语法结构：使役动词+宾语+宾语补足语</p>
<p><strong>常见的使役动词</strong></p>
<ol>
<li>make：
<ol>
<li>make+动词原形(其实是省去 to的不定式)： <code>ex:Employer make his employee work once again.</code></li>
<li>形容词 如：<code>the cattot made the wolf full</code></li>
</ol>
</li>
<li>let：允许某人做某事(不绝对)let+动词原形(其实是省去 to的不定式) <code>ex:I'll let the wolf eat some chocolate.</code> |副词  <code>ex:let me out.</code></li>
<li>have：have +动词原形(给某人、物/责任做) 如：<code>I will have the wolf wash the dishes</code>  | have + 动词过去分词 表示让某人做某事</li>
<li>get：get +不定式(说服/鼓励……做……)  <code>I'll get the wolf to clean the kitchen.</code>|get +过去分词    <code>ex:I got my nails done.</code></li>
</ol>
<h1>从句</h1>
<p>举个例子，我看见兔子吃了胡萝卜，这里主语是“我”，谓语动词是”看见“，那宾语是什么？是”兔子吃了胡萝卜“这件事，这件事本身单独看是完整的句子，<strong>这种充当句子成分的句子就叫做从句</strong>。英语为 <code>ex:I saw that the rabbit ate a carrot.</code> 这里I saw 为主句，that及其之后的是从句。</p>
<p>句子分类</p>
<ol>
<li>简单句：不可再拆</li>
<li>复合句：不分主次，也就是并列。</li>
<li>复杂句：主句+从句</li>
</ol>
<p>在句子中，每一个句子成分都可以由句子充当，比如主语被句子充当就变成主句从句。分成三大类就是名词从句、形容词从句、副词从句。</p>
<p><strong>如何理解中式造句与英式造句之间的差异？<strong>比如这句话“一根我买来的胡萝卜”，在中文中用形容词(定语)+名词的方式，无论定语有多长，而在英语中是在在被修饰的词之后(<strong>先行词)</strong>+与他有关系的词(<strong>关系词</strong>)+句子补充说明，这里就是 <code>ex:a carrot that I bought.</code>  即</strong>中文中定语都是前置的，而英语中定语大部分都是后置的</strong>。也就是说，在用英语造句的时候，可以先将对应的中文拆句，比如“一只几个月前开始在B站上传视频专门教英语的讨人喜爱的兔子”，核心主干是“<strong>一只兔子</strong>”，而“几个月前”“开始在B站上传视频”“专门教英语的”“讨人喜爱的”全都是定语，可以将其放在关系词后面，再按照一定的顺序进行调整。</p>
<h2 id="关系词">关系词</h2>
<h3 id="分类">分类</h3>
<ol>
<li>关系代词：代指前面的部分 <code>ex:The rabbit is eating a carrot that I bought.</code> 可以看到，后面的句子作陈述句的时候是<code>ex:I bought a carrot.</code>,然后用that 代指 a carrot ,再将关系代词提前，则变为<code>ex:that I bought.</code> 常见的还有who\whom\which\whose .
<ol>
<li>that与which的区别:  当先行词是唯一的时候使用that，而先行词多选一的时候使用which. <code>ex:the only rabbit that ate a carrot.</code>  <code>ex:The rabbit ate a carrot which I bought.</code> 言下之意就是这里有多个胡萝卜，但这个兔子只吃了我买的那个。</li>
</ol>
</li>
<li>关系副词: 前面的部分在从句中充当副词 <code>ex:This was the place where the rabbit ate the carrot.</code> 当然也可以用关系代词替代，<code>ex:This was the place at which the rabbit ate the carrot.</code> 由此可得，关系副词=介词+which</li>
</ol>
<h2 id="形容词性从句">形容词性从句</h2>
<h3 id="限定性形容词从句与非限定形容词从句">限定性形容词从句与非限定形容词从句</h3>
<p><code>ex:The rabbit is eating a carrot that I bought.</code> 这里that句限定了carrot的范围/性质 而<code>ex:The rabbit ate the carrot,which was on the table.</code> 这里的which更多起到代词的作用，并没有限定的作用。</p>
<h3 id="分类-2">分类</h3>
<ol>
<li>非限定性形容词从句作插入语  <code>ex:My head,which is big,is useful when it rains.</code></li>
<li>非限定性形容词从句指代整句话  <code>ex:The rabbit ate the carrot,which was not surprising.</code> 这里的which指代The rabbit ate the carrot.</li>
</ol>
<h2 id="名词性从句">名词性从句</h2>
<h3 id="1-主语从句">1. 主语从句</h3>
<p>主语由从句充当 <code>ex:That the rabbit ate a carrot is obvious.</code> 引导词还可以用who/where/when/how/what等<strong>主语从句要以引导词作为开头</strong>。</p>
<ul>
<li>
<p>形式主语</p>
<p><code>ex:It is obvious that the rabbit ate a carrot.</code> 这里It作为形式主语，而真正的主语是that句。</p>
</li>
</ul>
<h3 id="2-宾语从句">2. 宾语从句</h3>
<ol>
<li>确定信息与不确定信息 <code>ex:I saw that the rabbit ate a carrot.</code> <code>ex:I saw whether the rabbit ate the carrot.</code></li>
<li>that省略：<code>ex:I know (that)the rabbit ate a carrot.</code>  如果that省略之后有歧义则不能省略。</li>
<li>某些词后的宾语从句的否定：否定加在谓语动词前，而非从句中。<code>ex:I don't think (that) the rabbit is smart.</code> 而不是isn’t</li>
<li><strong>主从时态一致</strong>：<code>ex:I don't think (that)you're right.</code> 除非是不变的客观现象(比如the sun rises in the east.)</li>
<li>特殊：be+形容词+that. <code>ex:I am sure that there's a carrot on the table.</code></li>
</ol>
<h3 id="3-表语从句">3. 表语从句</h3>
<ol>
<li>系动词为be ：<code>ex:The problem is that the rabbit is hungry.</code></li>
<li>系动词为非be动词：<code>ex:It seems that the rabbit is hungry.</code></li>
</ol>
<h3 id="4-同位语从句">4. 同位语从句</h3>
<p>同位语简单来说就是名词的另一种说法。<code>ex:My teacher,Papa Rabbit,likes carrots.</code> 这里的Papa Rabbit实际上指的还是My teacher.</p>
<p><code>ex:The fact that the rabbit ate the carrot did not surprise me.</code></p>
<h3 id="5-宾语补语从句">5. 宾语补语从句</h3>
<p><code>ex:My education made me who I am today.</code></p>
<h2 id="副词从句">副词从句</h2>
<p>副词从句充当句子中状语的部分，所以也成为状语从句</p>
<h3 id="分类-3">分类</h3>
<ol>
<li>
<p>表时间</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>引导词</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>在…前</td>
<td>before</td>
<td>The rabbit ate a carrot at home before the wolf stopped by. The到before之前是主句，the wolf到by是从句。如果要将从句提前需要断句Before the wolf stopped by,the rabbit ate a carrot at home.</td>
</tr>
<tr>
<td>在……时</td>
<td>when\while\as。when表示突然，while表示时间段，as表示同时</td>
<td>I ate a carrot as I made the video.</td>
</tr>
<tr>
<td>在……之后</td>
<td>after</td>
<td>The rabbit ate a carrot after the wolf stopped by.</td>
</tr>
<tr>
<td>从之前某一段时间点开始算</td>
<td>since</td>
<td>The rabbit has shared three carrots since the wolf stopped by.</td>
</tr>
<tr>
<td>直到之后的某一时间点</td>
<td>until</td>
<td>The student waited until the bus came.</td>
</tr>
<tr>
<td>一……就……</td>
<td>as soon as</td>
<td>The rabbit will eat a carrot as soon as the wolf leaves.</td>
</tr>
<tr>
<td>下次</td>
<td>the next time</td>
<td>The rabbit will share the biggest carrot the next time the wolf stops by.</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>表地点(如：在…地方) 引导词：where+“强调形式”(wherever,anywhere……) <code>ex:The rabbit will go wherever he can find a carrot.</code></p>
</li>
<li>
<p>表条件(如：如果…) <code>ex:If the rabbit sees a carrot,he will eat it.</code> 遵循“主将从现” ，从句(if引导的句子)的假设是不确定的，不能用will，所以用一般现在时态，而一旦假设成立，那么一定某件事发生，这种确定的发生用一般将来时态。<strong>即条件句比主句落后一个时间段</strong>。其他的引导词如unless,provided,as long as,in case 等</p>
</li>
<li>
<p>表让步(如：虽然…但是…) <code>ex:Even if I see a carrot,I will not eat it.</code> 同样的还是有thought\although\no matter</p>
</li>
<li>
<p>表方式(如：就好像…)  <code>ex:I feel good as if I had just eaten a carrot.</code></p>
</li>
<li>
<p>表比较(如：比…) <code>ex:He is smarter than I (am).</code> 其实就等效于口语化的 <code>ex:He is smarter than me.</code> 同样比较的词有as……as,the more…… the more.</p>
</li>
<li>
<p>表原因(如：因为所以…) <code>ex:The rabbit ate the carrot because he was hungry.</code> 不能用because和so搭配是因为because用来构成复杂句，so用来构成复合句，两者混用会导致句子结构混乱，同理还有though和but.同样的词还有since\as，不过这两个词构成的副词从句一般放在主句前。</p>
</li>
<li>
<p>表目的)如：为了…) <code>ex:In order that I could finish the video in time,I pulled an all-nighter.</code> 同样的词还有so that。so that既能表示目的也能表示结果，在翻译的时候要注意这一点。</p>
</li>
<li>
<p>表结果(如：所以…)  <code>ex:I ate a lot of carrots for lunch so that I wasn't hungry at all in the afternoon.</code> 同样的词还有so,such that,such后面要接名词。</p>
</li>
</ol>
<h1>非动词</h1>
<h2 id="冠词">冠词</h2>
<p>分类如下</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">1.不定冠词</button><button type="button" class="tab">2.定冠词</button><button type="button" class="tab">3.零冠词</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>使用范围：判断音素(即首音标而不是字母)发音是元音还是辅音 如 a university/an hour</strong></p>
<p><strong>意思分类如下</strong></p>
<table>
<thead>
<tr>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>泛指</td>
<td>I saw a rabbit.(我看到只兔子-指某一只)</td>
</tr>
<tr>
<td>某一类)看语境去理解)</td>
<td>最好是用相关名词的复数 A rabbit is smarter than a wolf. 这里的意思是兔子比狼聪明</td>
</tr>
<tr>
<td>表示数字1</td>
<td>I gave you a hundred carrots.</td>
</tr>
<tr>
<td>表示每</td>
<td>I give you a hundred carrots a day.</td>
</tr>
<tr>
<td>主谓一致</td>
<td>a teacher and video creator.这里老师和创作者都是指同一个人。如果是a teacher and a video creator. 这里指的是两个人。</td>
</tr>
<tr>
<td>固定搭配</td>
<td>as a result\have a good time……</td>
</tr>
</tbody>
</table></div><div class="tab-item-content"><p><em><strong>The</strong></em></p>
<ol>
<li>
<p>发音</p>
<ol>
<li>两个发音：在辅音音素前读[ðə]比如：the book 那书，the desk 那桌子，the table 那桌子。</li>
<li>在元音音素前读[ði]。比如：the apple 那苹果，the ant 那蚂蚁，the elephant 那大象。</li>
</ol>
</li>
<li>
<p>意思</p>
<table>
<thead>
<tr>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>特指</strong></td>
<td>The school</td>
</tr>
<tr>
<td>再次提到的人或者事物</td>
<td>I saw a rabbit.The rabbit ran fast.</td>
</tr>
<tr>
<td>用在序数词和形容词的最高级前(某种意义上也是特指)</td>
<td>The first rabbit.</td>
</tr>
<tr>
<td>独一无二的名词</td>
<td>The sun,the Great Wall.</td>
</tr>
<tr>
<td>泛指</td>
<td>play the piano. 如果这里the用a则侧重强调弹钢琴的动作。</td>
</tr>
<tr>
<td>固定表达</td>
<td>all the time.</td>
</tr>
<tr>
<td>The +adj表示一类人</td>
<td>the rich should help the poor.</td>
</tr>
</tbody>
</table>
</li>
</ol></div><div class="tab-item-content"><ol>
<li>复数泛指  <code>ex:Rabbits are smart.</code> 这样更好体现某一类事物</li>
<li>表示概念  <code>ex:Summer is hot.Winter is cold.</code> 这里表达的是“夏季”这一季节概念</li>
<li>专有名词 <code>ex:Washington DC.</code></li>
<li>固定表达：如play +球类/棋类/非西洋乐器 play+the+西洋乐器</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<hr>
<h2 id="介词">介词</h2>
<p><strong>概念</strong>：本意是前置词prepositon ,补充信息的作用。</p>
<h3 id="常见介词分类">常见介词分类</h3>
<ol>
<li>简单介词：in\on\with…… 分别具有<strong>多重含义</strong>，所以翻译会与中文不同，所以<u>不要想着找到所有意思的中文与之对应，最好在语境中去理解与记忆。</u></li>
<li>短语介词：According to……</li>
<li>合成介词：into……</li>
<li>分词介词：provided\including……</li>
</ol>
<h3 id="介词的本源与引申">介词的本源与引申</h3>
<ol>
<li>About——on the outside of 在 的外面——引申为关于、大约、针对、具有某种特性、到处。<code>ex:There are about 2 carrots.</code></li>
<li>on——在 之上：有一面确定，所以是较小的范围)“相对的”)<code>ex:Dinner is on me.</code></li>
<li>beyond——在 之外：<code>ex:It's beyond me.</code></li>
<li>in——在 之内：一般是在一堆东西之间，大范围  <code>ex:dressed in white.In English.</code></li>
<li>At:在一个“点”上.<code>ex:At the corner.At shop.</code></li>
<li>区别：从in到at范围(可以是时间也可以是空间)逐渐变小，<u>但这个范围是相对的</u></li>
</ol>
<table>
<thead>
<tr>
<th>区别</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>in一般表示在某某之中，也就是说明在一个大范围之内/但morning比day小为什么能用in？因为这里morning表达的是时间段，相对的”大范围“，所以使用in。</td>
<td>in a year\month\week。</td>
</tr>
<tr>
<td>on表示在……之上，有一面确定，所以是较小的范围</td>
<td>on that day</td>
</tr>
<tr>
<td>at在一个“点”上,这个点是抽象的点，可以是时间的点也可以是地点的点。</td>
<td>at 8 o’clock</td>
</tr>
<tr>
<td>应用含义不同。</td>
<td>Walking in the street.表达在整条街道上移动。Some trash on the street表达街道表面有垃圾。I am at C street and B street. 表达在两条街道的交界带。</td>
</tr>
</tbody>
</table>
<h3 id="常见介词的用法">常见介词的用法</h3>
<ol>
<li>in：在内部 <code>ex:In the country.</code> 以……方式</li>
<li>on：在上面、与物体有接触 <code>ex:on the table.</code>   <code>ex:we talked on the phone.</code></li>
<li>at：在某处  <code>ex:at bus station.</code></li>
<li>over:在……上方(可以接触，可以不接触)、覆盖、越过上空|有动态   <code>ex:The plane flew over the mountain.</code></li>
<li>above：在……上方(高于平面)</li>
</ol>
<h3 id="常用其他介词">常用其他介词</h3>
<table>
<thead>
<tr>
<th>形式</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>under</td>
<td>在……下方，与over相对，一般在正下方</td>
<td>under the tree</td>
</tr>
<tr>
<td>below</td>
<td>与above相对</td>
<td>The rabbit dived below the surface of the water.</td>
</tr>
<tr>
<td>near</td>
<td>在……周边</td>
<td>The school is near the hospital</td>
</tr>
<tr>
<td>by/beside</td>
<td>在……旁边：——引申为不超过 边界/不迟于 前</td>
<td>There is a hotel by/beside the river.</td>
</tr>
<tr>
<td>next to</td>
<td>靠近，紧挨着</td>
<td>The rabbit sat next to the wolf.</td>
</tr>
<tr>
<td>across</td>
<td>(从表面)穿过</td>
<td>Walk across the sidewalk</td>
</tr>
<tr>
<td>through</td>
<td>(从内部)穿过/通过某种方式</td>
<td>go through the tunnel.</td>
</tr>
<tr>
<td>past</td>
<td>经过，路过</td>
<td>Passing through a small area</td>
</tr>
<tr>
<td>in front of/in the front of</td>
<td>在……的前面，后者是在内部的前面</td>
<td>The driver is at the front of the car</td>
</tr>
<tr>
<td>before</td>
<td>在……之前</td>
<td>Someone has been here before me</td>
</tr>
<tr>
<td>between……and</td>
<td>两者之间</td>
<td>Between the father and the mother are their children</td>
</tr>
<tr>
<td>among</td>
<td>三者之间或三者以上</td>
<td>He divided the country among his sons</td>
</tr>
<tr>
<td>round/around</td>
<td>环绕</td>
<td>trees around the field.</td>
</tr>
<tr>
<td>along</td>
<td>沿着</td>
<td>we walk along the beach</td>
</tr>
<tr>
<td>to</td>
<td>朝着</td>
<td>we are going to town on the bus,okay?</td>
</tr>
<tr>
<td>toward/towards</td>
<td>朝着……的方向</td>
<td>walk toward home.</td>
</tr>
<tr>
<td>onto</td>
<td>到……上面</td>
<td>the rabbit jumped onto the table.</td>
</tr>
<tr>
<td>into</td>
<td>到……里面</td>
<td>let’s go into the garden</td>
</tr>
<tr>
<td>out of</td>
<td>从里面出来</td>
<td>an apple rolled out of the bag</td>
</tr>
<tr>
<td>opposite</td>
<td>在……对面</td>
<td>our school is opposite my house.</td>
</tr>
<tr>
<td>against</td>
<td>与……相反；倚靠</td>
<td>The rabbit was leaning against the tree.</td>
</tr>
<tr>
<td>up</td>
<td>沿……向上</td>
<td>put those books up on the top shelf</td>
</tr>
<tr>
<td>down</td>
<td>沿……向下</td>
<td>Is this lift going down</td>
</tr>
<tr>
<td>off</td>
<td>离……有一定距离</td>
<td>New Zealand lies off the eastern coast of Australia.</td>
</tr>
<tr>
<td>until</td>
<td>直到</td>
<td>we did not eat until past midnight</td>
</tr>
<tr>
<td>during</td>
<td>持续；在……期间</td>
<td>during the past 2 days.</td>
</tr>
<tr>
<td>for</td>
<td>因为 ；因 持续；以 价钱</td>
<td>I bought these books for 100 Yuan.</td>
</tr>
<tr>
<td>since</td>
<td>自从</td>
<td>I’ve long since forgotten anything I ever learned</td>
</tr>
<tr>
<td>from to</td>
<td>从……到……</td>
<td>from 9:00 to 10:00.</td>
</tr>
<tr>
<td>by</td>
<td>通过/后接度量标准</td>
<td>I go to school by car. /They get paid by the hour.</td>
</tr>
<tr>
<td>with</td>
<td>用 ；和 一起；……的原因是</td>
<td>The rabbit is shaking with cold.</td>
</tr>
<tr>
<td>because/because of</td>
<td>前接从句后接名词/同样后接名词的还有Due to/owing to/on account of</td>
<td>The rabbit didn’t go out because of the rain.</td>
</tr>
<tr>
<td>of</td>
<td>此外的、附加的</td>
<td>He thought of something important.</td>
</tr>
<tr>
<td>besides</td>
<td>除了……还</td>
<td>I like many things besides carrots.</td>
</tr>
<tr>
<td>except</td>
<td>除了</td>
<td>Everyone went to the party except the rabbit.</td>
</tr>
<tr>
<td>except for</td>
<td>往往用来对之间的内容进行反驳</td>
<td>The party is great except for the loud music.</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
<p>💡尽可能由本源引申扩展义，在具体的语境中理解和记忆，不需要死记。</p>
<h3 id="介词短语">介词短语</h3>
<p>由介词+宾语组成的短语，可以充当句子成分</p>
<ol>
<li>Between 10 and 11 is a good time for me. 作主语</li>
<li>The meeting is at 2 o’clock.作表语</li>
<li>This is the key to the house.作定语</li>
<li>……</li>
</ol>
<h3 id="短语动词">短语动词</h3>
<p>由动词+介词构成一个新的动词。比如check out ,make out……。大多数是固定搭配需要记忆。</p>
<hr>
<h2 id="名词">名词</h2>
<h3 id="名词的分类">名词的分类</h3>
<ol>
<li>普通名词与专有名词(首字母大写)：如人名Mike，国家China</li>
<li>由单数和复数分：可数名词与不可数名词
<ol>
<li>如集合名词：team,可以作单数也可以作复数，不过意思分别为团队、队伍，也就是集合名词的含义会随着单复数而变化。</li>
<li>抽象概念不可数：比如和平peace，诚实honesty</li>
<li>数不清的名词：water 大多数情况下为不可数名词，但是也有例外，如 two waters 意思是两片水域。</li>
<li>专有名词的复数：如Mikes,有时候代表几个加Mike的的人，或者是指Mike一家。</li>
</ol>
</li>
</ol>
<p>💡<strong>名词的单复数不在于名词本身，而是在于名词在不同的语境中要表达什么意思</strong>，然后选择是单数还是复数。如 a glass of water 可数的是杯子而不是水，所以表达复数是two glasses of water.</p>
<h3 id="名词的所有格">名词的所有格</h3>
<ol>
<li>‘s:表示从属关系，如Mike’s hand 。如果其主格是复数就打’即可。比如parents’ kids.
<ol>
<li>表示修饰、特性：</li>
<li>并列<strong>共有</strong>的情况下最后一个加所有格：Tom and Jerry’s room</li>
</ol>
</li>
<li>of:a room of school⇒the school’s room</li>
<li>双重所有格：I am a friend of Mike’s.用Mike’s修饰friend.即Mike的朋友有很多，我只是他其中的一个。</li>
</ol>
<h2 id="代词">代词</h2>
<p>定义：就是用一个词代替之前说过的词，更多是用于简化和避免重复。</p>
<h3 id="分类-4">分类</h3>
<ol>
<li>人称代词：
<ol>
<li>人称代词的“格”：主格或者宾格，即代词在不同的格会有不同的变化。注意 <code>ex:you and I.</code>等<strong>一般习惯把对方放前面，“我”放在后面</strong></li>
<li>人称代词的表格搜一下就能找到，不过比较简单。</li>
<li>物主代词： my(形容词性物主代词) mine(名词性物主代词)<code>ex:It is my carrot.The carrot is mine.</code> 形容词性物主代词充当了形容词，而名词性物主代词充当了名词。</li>
<li>反身代词：<code>ex:I saw myself.</code></li>
<li>强调代词：the rabbit washed the carrots himself(himself作状语)</li>
</ol>
</li>
<li>相互代词：<code>ex:we should help each other.</code>(扩：one another 三者之间|三者以上之间)</li>
<li>指示代词：this these……这，这些——指代离说话人较近的事物|that those……那、那些——指代离说话人较远的事物</li>
<li>不定代词：
<table>
<thead>
<tr>
<th>不定代词</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>Many\much</td>
<td>前者修饰可数名词，后者修饰不可数名词</td>
</tr>
<tr>
<td>A few\few\a little\little</td>
<td>few接可数名词，little接不可数名词；不加a 表示很少，有否定意义.</td>
</tr>
<tr>
<td>Some\any</td>
<td>前者常用于肯定句，后者常用于否定句；any表示任意一个可以用在肯定句中.Does the rabbit need any carrots?</td>
</tr>
<tr>
<td>Each\every</td>
<td>前者可以单独做主语；each用于两个、两个以上，every用于三个、三个以上.each carrot\every carrot There are many carrots on each side of the street.</td>
</tr>
<tr>
<td>Either\neither</td>
<td>谓语动词用单数 Either of books is OK.</td>
</tr>
<tr>
<td>Both\all</td>
<td>前者是两者都，后者是三者及以上都  All of the rabbits are cute.</td>
</tr>
<tr>
<td>Other\the other\another</td>
<td>第一个表示另外的(+名词)，第二个特指两者中的另外一个，another表示三个或以上另一个.This carrot is bigger than the other carrot.\The rabbit doesn’t like this carrot.\Give him another carrot.</td>
</tr>
<tr>
<td>One\it</td>
<td>One指同一类事物，it指上下文“同一个事物”</td>
</tr>
</tbody>
</table>
</li>
<li>复合不定代词：every-，some-，any-，no-.形容词在修饰复合不定代词时后置。<code>ex:The rabbit has something important to do.</code></li>
<li>疑问代词：whom who…… <code>ex:Who killed him?</code></li>
<li>连接代词：whom,whichever,what whatever,whoever……在从句中就变成连接代词  <code>ex:From whom did the rabbit get the carrots?</code> <code>ex:What he said isn't true.</code></li>
<li>关系代词：who\whom\whose\which\that\as:<code>ex:The rabbit whose ears are long ate a carrot.</code></li>
</ol>
<hr>
<h2 id="数词">数词</h2>
<p>分为基数词和序数词</p>
<h3 id="基数">基数</h3>
<ol>
<li>1-10：不解释，已经刻在DNA里面了 11-eleven 12-twelve 13-thirteen 14: +teen(后缀) 20、30……: twen +ty(后缀)</li>
<li>几十+几：twenty-one</li>
<li>百：two hundred ,余数用and连接：three hunred and five(305)</li>
<li>千、万、亿：two thousand|three thousand five hunred and twenty-one(3521)</li>
<li>扩展：三位数划分法：1，000,000,000中间的空格分别是十亿、百万、千(billion million thousand)，西方人按照这样的顺序读数字  <code>ex:four hundred and seventy-eight billion eight hundred and seventy-three million four hundred and sixty-seven thousand eight hundred and twenty-three</code> 478,873,467,823。</li>
<li>用法：
<ol>
<li>固定搭配：hundreds\thousands\millions of 成……上…… 本意都是<strong>特别多</strong></li>
<li>充当句子成分：<code>ex:It costs fifty.</code> 充当宾语；<code>ex:you two.</code> two为同位语。</li>
</ol>
</li>
</ol>
<h3 id="序数词">序数词</h3>
<p>一般的基数词+th 20----90(整十数)：基数词把y改写为ie+th。如thirtieth<br>
缩写：阿拉伯数字+st|nd|rd.<br>
对于任意一个序数词，整十整百位基数词，个位变序数词，如<code>ex:twenty-second.</code> 如果序数词充当句子成分，一般要在前面+the。</p>
<ol>
<li>
<p>分数：One third 三分之一 a quarter 四分之一 two and one third 2的三分之一次方</p>
</li>
<li>
<p>小数：one point three four 1.34，加了point就是小数,左边就是实数部分，右边就是小数部分。</p>
</li>
<li>
<p>百分数：……+percent  <code>ex:two point five percent.</code></p>
</li>
<li>
<p>倍数：</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>倍数+the+计量+of</td>
<td>This carrot is half/twice/three times the size of that one.</td>
</tr>
<tr>
<td>倍数+as……as……</td>
<td>I have half/twice/three times as many carrots as he has.</td>
</tr>
<tr>
<td>倍数+比较级+than</td>
<td>I can eat three times faster than he can.</td>
</tr>
<tr>
<td>by+倍数</td>
<td>I have increased my income by three times.</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>算术：2 plus 2 is 4:加法|4 minus 2 is 2:减法|2 multiplied by/times 3 is 6：乘法|8 divided by 4 is 2：除法|squared：平方|cubed:立方|more than：大于</p>
</li>
<li>
<p>单位：时间：<code>ex:at seven(7:00) a quarter past seven(7:15) half past seven(7:30) ten to eight(7:50).</code></p>
</li>
<li>
<p>年份：美式：月|日|年    <code>ex:December 12th,2020.</code>  BC 公元前  <code>ex:500 B.C.</code>  AD公元 2020’s|2020s 二十一世纪20年代</p>
</li>
<li>
<p>度量表示：</p>
<ol>
<li>基数词+单位词(复数)+形容词(长宽高):<code>ex:The river is 1000 meters long.</code></li>
<li>基数词+单位词(复数)+in+(长宽高)名词:  <code>ex:The river is 1000 meters in length.</code></li>
<li>面积和体积：<code>ex:This room is 700 square meters.</code> 这个房间有700平方米。</li>
<li>……</li>
</ol>
</li>
</ol>
<hr>
<h2 id="形容词">形容词</h2>
<h3 id="定语用法">定语用法</h3>
<ol>
<li>前置定语：<code>a hungry rabbit</code>形容词的顺序：限定词(冠词，物主代词等) +(主观)特征+尺寸+形状+新旧+颜色+来源+材料+用途 如：<code>a beautiful big round new black Chinese wooden table</code> 口诀是 <strong>美小圆旧黄，中国木书房</strong></li>
<li>后置定语：常用于修饰复合不定代词：<code>everything possible</code></li>
<li>形容词短语作定语：<code>the rabbit eager to eat carrots</code></li>
<li>表语：<code>ex:The rabbit is hungry.</code> 有些只能作表语，如asleep,alive……</li>
<li>Alive|asleep|alone等以a开头的形容词:一般只做表语，<code>The rabbit is alive/asleep/alone</code></li>
<li>表示身体状况的形容词一般如ill、will一般只能作表语而不作前置定语 如<code>The rabbit is ill/well.</code></li>
<li>补语：如make+宾语+宾补 <code>ex:carrots make rabbits happy.</code></li>
<li>状语：<code>The rabbit came home,tired and hungry.</code></li>
</ol>
<table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置定语</td>
<td>a hungry rabbit形容词的顺序：限定词(冠词，物主代词等) +(主观)特征+尺寸+形状+新旧+颜色+来源+材料+用途 如：a beautiful big round new black Chinese wooden table <em>美小圆旧黄，中国木书房</em></td>
</tr>
<tr>
<td>后置定语，常用于修饰复合不定代词</td>
<td>everything possible</td>
</tr>
<tr>
<td>形容词短语作定语</td>
<td>the rabbit eager to eat carrots</td>
</tr>
<tr>
<td>表语</td>
<td>The rabbit is hungry. 有些只能作表语，如asleep,alive……</td>
</tr>
<tr>
<td>Alive\asleep\alone等以a开头的形容词一般只做表语</td>
<td>The rabbit is alive/asleep/alone</td>
</tr>
<tr>
<td>表示身体状况的形容词一般如ill、will一般只能作表语而不作前置定语</td>
<td>The rabbit is ill/well.</td>
</tr>
<tr>
<td>补语：如make+宾语+宾补</td>
<td>carrots make rabbits happy.</td>
</tr>
<tr>
<td>状语</td>
<td>The rabbit came home,tired and hungry.</td>
</tr>
</tbody>
</table>
<h3 id="形容词的构成">形容词的构成</h3>
<p>很多中间带有“-”往往就是这样的合成词，这样的合成词大多构成形容词。个人感觉能用从句就不用这种合成构词，避免犯错。</p>
<ol>
<li>形容词+形容词/现在分词/过去分词：<code>a red-hot coal</code></li>
<li>副词+形容词/现在分词/过去分词:<code>hard-working</code></li>
<li>形容词/数词+名词:<code>kind-hearted</code> 等效于<code>ex:a man whose heart is kind.</code></li>
<li>名词+形容词/现在分词/过去分词:<code>a snow-white rabbit</code></li>
</ol>
<h3 id="比较级与最高级">比较级与最高级</h3>
<table>
<thead>
<tr>
<th>含义</th>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>一般类</td>
<td>单词末尾+er|+est，有些特殊的要改写y为i再+er\est.</td>
<td></td>
</tr>
<tr>
<td>特殊类</td>
<td>重读闭音节：双写辅音字母+er\est.多音节和部分双音节词前面加上more\most；不规则变化：记！</td>
<td>bigger\more beautiful</td>
</tr>
<tr>
<td>比……更</td>
<td>(倍数)+比较级+than</td>
<td>This carrot is three times bigger than that one.three times 表示的是倍数，后面的比较级+than才是主要结构。</td>
</tr>
<tr>
<td>和……一样</td>
<td>as ……as</td>
<td>This carrot is three times as big as that one.</td>
</tr>
<tr>
<td>越来越</td>
<td>比较级+and+比较级</td>
<td>faster and faster. \more and more beautiful.</td>
</tr>
<tr>
<td>越……，就越……</td>
<td>the+比较级(原因)+补充内容，the+比较级(结果)+补充内容</td>
<td>The more carrots the rabbit eats,the smarter he will become.</td>
</tr>
<tr>
<td>最高级</td>
<td>最高级一般前面+the</td>
<td>Magic mirror on the wall,who is the fairest one of all?</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="副词">副词</h2>
<p>adj+adv：pretty|fast   大多数副词都是在形容词后面+ly，少部分去e+ly。注意有些词变为副词后词义改变较大。如largely.</p>
<h3 id="副词的修饰作用">副词的修饰作用</h3>
<ol>
<li>副词修饰动词：<code>ex:this rabbit runs fast</code></li>
<li>副词修饰形容词和副词：<code>ex:this rabbit runs very fast;I am doning very well</code></li>
<li>副词修饰名词：<code>ex:this rabbit here runs very fast.</code></li>
<li>副词修饰句子：<code>ex:Obviously,this rabbit here runs very fast.</code></li>
<li>特殊：有些副词既可以当形容词也可以当副词，形容词变为副词是一般+ly(当然有不规则变化)</li>
</ol>
<h3 id="副词的作用">副词的作用</h3>
<ol>
<li>状语：<code>ex:This is a very fast rabbit.</code></li>
<li>表语：一般只在be后面. <code>ex:the wolf is abroad.</code></li>
<li>宾补：<code>let me out</code></li>
</ol>
<h3 id="副词的分类">副词的分类</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>方式副词</td>
<td>一般可以放在任意位置</td>
<td>Suddenly,the driver turned left.</td>
</tr>
<tr>
<td>程度副词</td>
<td>一般谓语修饰的形容词或者副词之前</td>
<td>He speaks very well</td>
</tr>
<tr>
<td>地点副词</td>
<td>一般在句尾,表强调的时候可以位于句首</td>
<td>The rabbit eats carrots indoors/outdoors.</td>
</tr>
<tr>
<td>时间副词</td>
<td>任意</td>
<td>The rabbit is eating some carrots now.</td>
</tr>
<tr>
<td>频率副词</td>
<td>大多位于行为动词之前，be动词/助动词/情态动词之后</td>
<td>The rabbit usually eats carrots.</td>
</tr>
<tr>
<td>疑问副词</td>
<td>差不多是疑问词</td>
<td>How does the rabbit eat carrots.</td>
</tr>
<tr>
<td>连接副词</td>
<td>起到连接句子的作用</td>
<td>I do not know where the rabbit eats carrots.</td>
</tr>
<tr>
<td>关系副词</td>
<td>和从句有关</td>
<td>That was the day when the rabbit ate the carrot for the first time.</td>
</tr>
<tr>
<td>句子副词</td>
<td>修饰整个句子</td>
<td>Obviously,this rabbit here runs very fast</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="连词">连词</h2>
<h3 id="并列连词">并列连词</h3>
<p>并列连词：前后单词)或者短语或者句子)关系是平等的</p>
<p>如：<code>and</code> <code>ex:The rabbit not only teaches English but also makes videos</code> <code>ex:Neither the rabbit nor the wolf likes apples.</code> 遵循就近原则</p>
<ol>
<li>选择关系：<code>What does the rabbit like?Apples or carrots? | Hurry up,or/or else/otherwise you'll be late.</code></li>
<li>转折关系：虽然但是 but yet  <code>The rabbit cooked some carrots,yet he didn't eat any.</code></li>
<li>因果关系：<code>The rabbit is busy,so he won't go to the party tonight.</code>还有for、therefore等</li>
</ol>
<h3 id="从属连词">从属连词</h3>
<ol>
<li>引导名词性从句:<code>That the rabbit ate the carrot was obvious.</code></li>
<li>引导状语从句：when|while|as|before|after|until|since……具体示例看从句部分</li>
</ol>
<hr>
<h2 id="叹词与限定词">叹词与限定词</h2>
<p>负责表达情感的声音、单词、词组。</p>
<p>这一部分主要用于日常口语，对书面语影响不大。oh oh my God等就已经足够用了。</p>
<p>限定词：就是用于限定的词，这个属于词性定义，对语法影响不大。</p>
<p><strong>按位置划分</strong></p>
<ol>
<li>前位限定词：某些不定代词；倍数词；分数词…</li>
<li>中位限定词：冠词；物主代词；某些不定代词…</li>
<li>后位限定词：基数词；序数词；量词…</li>
</ol>
<p><code>ex:half(前位) my(中位) carrots.</code></p>
<hr>
<h1>构词法(重点)</h1>
<h2 id="派生">派生</h2>
<p>前缀+词根(核心、主要意思)+词缀(可改变词性)=单词(当然也可以三者排列组合)<br>
注意：<strong>不是所有的词都和这三种成分有关，有些词根等表示的意思与通常的意思无关</strong>。用构词快速背记单词和认出单词，但还是要背，只是通过此规律能够减少压力。</p>
<ul>
<li>常见词根
<ol>
<li>vis、aud、ed：分别代表视觉、听觉、吃，代表词有visible\audible\edible,这些词根实际上是“外来词汇”.</li>
<li>hydr：表示水   <code>ex:hydrated</code></li>
</ol>
</li>
<li>常见前缀
<ol>
<li>In-：
<ol>
<li>不 (否定义)<code>ex:invisible.</code> 是visible的反义，即不能看见的。</li>
<li>向里面：<code>ex:inward.</code> 向里面的。</li>
</ol>
</li>
<li>En-：使的   <code>ex:enlarge.</code> 使……变大。</li>
<li>Pre-：前面的</li>
<li>Suf-：后面的，在……之下。</li>
<li>Im-|Un-|il-|ir|mis-|dis-|de-|non-|:含否定意</li>
</ol>
</li>
<li>常见后缀
<ol>
<li>ible：能被  <code>ex:credible.</code></li>
<li>able：能被 <code>ex:countable.</code></li>
</ol>
</li>
<li>字母变化： 变化是为了发音
<ol>
<li>省略元音：struct+ure+al = structural</li>
<li>添加元音：pent+gon = pentagon</li>
<li>其他</li>
</ol>
</li>
</ul>
<h2 id="合成">合成</h2>
<p>比较常见于日耳曼词汇</p>
<p>如water→ waterfall waterproof underwater</p>
<p>还有一种是-合成。比如high-class</p>
<h2 id="混合">混合</h2>
<p>就是将词根、词缀分别只取一部分然后拼在一起。</p>
<p><code>ex:smoke+fog=smog</code></p>
<h2 id="截断">截断</h2>
<p>就是从单词上截取一部分当单词，一般和源单词意思相近。<code>ex：examination→exam</code> application→app</p>
<h2 id="缩写">缩写</h2>
<p>常用于专有名词(行业术语、网络流行词等)  ,一般将所有单词首字母大写然后拼起来。<code>ex:VIP(very important person)、BBC(British Broadcast Company)</code></p>
<h2 id="转换">转换</h2>
<p>即一个单词具有不同的词性，比如fall和education。</p>
<hr>
<h1>语法现象</h1>
<h2 id="被动">被动</h2>
<p>这里涉及到语态，即主动语态和被动语态，前者强调动作的执行者，后者强调动作的承受者。</p>
<p><strong>分类</strong></p>
<table>
<thead>
<tr>
<th>形式</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>主+谓+宾</td>
<td>变被动为be+动词过去分词</td>
<td>The rabbit eat a carrot.=&gt;The carrot is eaten by the rabbit.  一般被动后面by+动作执行者，可加可不加。</td>
</tr>
<tr>
<td>主+谓+宾(直接宾语)+宾(简介宾语)</td>
<td>\</td>
<td>The carrot was given to the wolf by the rabbit.=The wolf was given the carrot by the rabbit.  原句为The rabbit gave the wolf the carrot.</td>
</tr>
<tr>
<td>主+谓+宾+宾补</td>
<td>对于如make这样的动词，主动改为被动时必须加to</td>
<td>The rabbit was invited to the party by the wolf./The rabbit made the wolf (to) laugh.=&gt;The wolf was made to laugh by the rabbit.</td>
</tr>
<tr>
<td>主+系+表</td>
<td>一般不能被动</td>
<td>I am smart</td>
</tr>
<tr>
<td>对于谓语是不及物动词</td>
<td>不存在动作的承受者，所以没有被动一说</td>
<td>the rabbit sleeps</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="倒装">倒装</h2>
<p>倒装，即将谓语动词提前。主要分为完全倒装(谓语动词完全在主语前)和部分倒装(仅助动词提前)</p>
<p>也就是说，如果要写倒装句，<strong>最好是先写主动句然后再倒装</strong>。分类如下</p>
<h3 id="完全倒装：谓语动词完全在主语前">完全倒装：谓语动词完全在主语前</h3>
<ol>
<li>副词\介词短语在句首的倒装
<ol>
<li>地点副词在句首：<code>ex:There goes the last bus=The last bus goes.</code> 这样强调谓语动词</li>
<li>时间副词在句首的倒装：<code>ex:Now comes the wolf's turn!</code> 以now和then用的居多。</li>
<li>表运动方向的副词在句首的倒装：<code>ex:Up went the carrots into the air.</code> 原句为<code>ex:The carrots went into the air.</code>.类似的词还有in\out\down\away……。</li>
<li>介词短语在句首的倒装：<code>ex:At the table sat a rabbit</code></li>
</ol>
</li>
<li>主语补语表语的倒装：将作表语的形容词、分词、介词短语、such置于句首时需要完全倒装。<code>ex:Seated on the ground is a group of rabbits.</code></li>
</ol>
<h3 id="部分倒装：仅助动词提前">部分倒装：仅助动词提前</h3>
<ol>
<li>句首有否定意义词时的倒装 ：<code>ex:Never before have I eaten such a delicious carrot.</code></li>
<li>句首有&quot;only&quot;时的倒装 ：<code>ex:Only in this way can we grow delicious carrots.注；only句首如果修饰主语不用倒装。</code></li>
<li>&quot;if…should.构成虚拟语气的倒装 ：<code>ex:Should I win the lottery, I would buy a huge pile of carrots。</code>= <code>ex:If I should win the lottery,I would buy a huge pile of carrots.</code></li>
<li>固定句型中的倒装：<code>ex:Rabbits love eating carrots;so do wolves.</code></li>
</ol>
<h3 id="形式倒装：谓语动词不提前，仅将强调内容放置句首。">形式倒装：谓语动词不提前，仅将强调内容放置句首。</h3>
<ol>
<li>感叹句中的倒装 ：<code>ex:What a delicious carrot it is!</code></li>
<li>比较级句型中的倒装(如&quot;the more.,the more.&quot;) ：<code>ex:The more carrots you eat,the healthier you become.</code></li>
<li>“however’”;&quot;whatever’&quot;引导让步状语从句时的倒装 ：<code>ex:However long this video is,you should watch it till the end.</code></li>
<li>“as”,&quot;though&quot;引导让步状语从句时的倒装：<code>ex:Much as he likes the carrot,he doesn't want to eat it.</code></li>
</ol>
<hr>
<h2 id="强调">强调</h2>
<p>口语强调：重读即可; 语气词强调：见前面的叹词部分。书面强调：黑体字，大小写。</p>
<p><strong>常见的强调</strong></p>
<table>
<thead>
<tr>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>really、very、just、ever……用附加词突出强调</td>
<td>Rabbits really like carrots.</td>
</tr>
<tr>
<td>重复说某一个词</td>
<td>listen to me,listen to me,very very carefully.</td>
</tr>
<tr>
<td>助动词</td>
<td>Rabbits do like carrots!</td>
</tr>
<tr>
<td>强调代词</td>
<td>I can do it myself!这里的myself是强调作用，去掉它原句意思不变</td>
</tr>
<tr>
<td>倒装</td>
<td>Not a single carrot did I eat yesterday</td>
</tr>
<tr>
<td>感叹句</td>
<td>How big the carrot is!</td>
</tr>
<tr>
<td>固定句式</td>
<td>it +be+that……句式:It is the rabbit who/that will eat the carrot.要强调的东西放在it is和that 之间 判断强调句也是看去掉it’s who\that 是否构成完整的句子。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="省略">省略</h2>
<h3 id="省略冠词">省略冠词</h3>
<ol>
<li>独一无二的名词前面，如<code>ex:chairman/president/head</code> <code>ex:The rabbit was appointed (the) chairman of the Carrotown Committee.</code></li>
<li>并列关系：<code>ex:Both the rabbit and (the) wolf will be invited to the party.</code>表示并列的词，第二个冠词可以去掉。注意如果去掉冠词之后意思改变就不能去掉冠词如：<code>ex:a teacher and video creator!=a teacher and a video creator</code></li>
<li>某些独立主格结构:<code>ex:The rabbit came in,carrot in hand.</code>省略了with</li>
</ol>
<h3 id="省略介词">省略介词</h3>
<ol>
<li>时间介词：<code>ex:I worked 60 hours last week.</code>在60前面省略了for</li>
<li>作某事：<code>ex:I am busy (in) making videos.</code></li>
</ol>
<h3 id="省略动词不定式">省略动词不定式</h3>
<ol>
<li>并列关系：<code>ex:He wanted to stay here and(to) read.</code></li>
<li>不定式中的裸不定式：<code>ex:The wolf made me (to) watch the video.</code></li>
<li>省略从句引导词：<code>ex:This is the rabbit (that) we met yesterday.</code>仅限于限定性定语从句</li>
</ol>
<h3 id="句法省略">句法省略</h3>
<ol>
<li>祈使句：<code>ex:open the door ,please.</code>省略了主语you</li>
<li>感叹句省略：<code>ex:What a smart rabbit!</code>省略了he is</li>
<li>口语：<code>ex:what did you eat? (I ate)a carrot,</code>还有很多，看实际</li>
<li>并列句:<code>ex:The rabbit went home after work,and (the rabbit) ate a carrot.</code></li>
<li>复杂句：<code>ex:The rabbit will eat the carrot,but I don't know when (he will eat it).\(I am) sorry to hear that</code> 还有than\if possible等这样的词所在句子也有省略。</li>
</ol>
<hr>
<h2 id="主谓一致">主谓一致</h2>
<p>看这个句子<code>you were late.</code> 主语you和were共同传递了“第二人称，一般/过去“这个信息，即主语和谓语动词传递的信息是一致的。主谓一致分为三类</p>
<h3 id="语法一致">语法一致</h3>
<ol>
<li>谓语动词单复数和主语单复数一致：如<code>ex:time is money。</code>注意不定式主语和动名词主语谓语动词用单数。<code>ex:To eat a carrit every day is good for the rabbit.</code></li>
<li>特殊-假象主语：如<code>ex:as well as\except\but</code> <code>ex:The rabbit as well as other animals gets a carrot.</code>一般遵循就远原则。其本质就是这里的短语看起来像有两个主语实际上只有一个。</li>
<li>不定代词作主语：如everyone\each of 接单数:<code>ex:Each of them gets a carrot.</code>，both of\some of接复数:<code>ex:Both of them like carrots.</code>   none of\neither of 接单复数都行  <code>ex:None of them get/gets a carrot.</code></li>
</ol>
<h3 id="意义一致">意义一致</h3>
<ol>
<li>同一个主语多重身份：<code>ex:The teacher and video creator is a rabbit.</code>这位老师兼视频创作者是只兔子。这个例子也提醒我们<strong>不要看到and就用复数</strong></li>
<li>复数名词的单数意义：<code>ex:Ten years is a long time.</code>十年是一个时间段，<strong>看它是否表达的是整体而非个体的概念</strong>。<code>ex:A knife and fork is needed for eating the carrot.</code> 这里的意思可不是一把刀和一副叉子，而是整体意义“一副刀叉”.</li>
<li>不定代词的单复数意义：all are quiet)大家都很安静) all is quiet(一切都很安静)也就是看不定代词到底表示什么意思。</li>
<li>名词的形和意：主要看意思，意思是复数谓语动词就用复数。</li>
<li>特殊：单复数同形名词<code>ex:A sheep is eating grass.\\The sheep are eating grass.</code> 第一个句子指的是一只绵羊，第二个句子指的是一群绵羊。集合名词：理论上用单复数都行。如：deer fish team……也是主要看意思，意思是复数谓语动词就用复数。</li>
</ol>
<h3 id="就近一致">就近一致</h3>
<p>谓语动词的单复数由最近的主语决定。</p>
<ol>
<li>Or|either or……|not only……but also|not but|neither nor：<code>ex:Not only the rabbit but also many other animals like carrots.</code></li>
<li>There be：<code>ex:There is a carrot and two apples on the table.</code></li>
</ol>
<hr>
<h2 id="英语标点">英语标点</h2>
<p>本段主要侧重于书面语的书写规范。分类如下</p>
<h3 id="逗号：断句">逗号：断句</h3>
<ol>
<li>断句：<code>ex:Let's eat,the wolf.</code></li>
<li>列举：<code>ex:Let's eat carrots,apples and bananas.</code> 提醒，如果有定语修饰，但是只修饰一个的话也需要用逗号隔开。<code>ex:Let's eat carrots,red apples ,and bananas.</code>这里强调的是红色的苹果和普通的香蕉，如果不在and前面加逗号就变成了红色的苹果和香蕉。</li>
<li>同位语：<code>ex:I love my parents,the rabbit and the wolf.</code>我爱父母，(它们分别是)兔子和狼。如果不想表达同位语，同样在and前面加上逗号。</li>
<li>引语：<code>ex:The wolf said to the rabbit,&quot;Let'seat,rabbit.&quot;&quot;Well,yes,let's eat,my dear wolf,&quot;said the rabbit.</code> 第一句逗号之后的引语开头大写，而如果引语在前，则末尾要使用逗号。</li>
<li>插入语：<code>ex:&quot;Well,yes,&quot;said the rabbit,&quot;let's eat,my dear wolf.&quot;</code>中间的一句就是插入语</li>
<li>并列句、复杂句：<code>ex:The rabbit ate some carrots,but he was still hungry</code></li>
<li>附加疑问句：<code>ex:This is a tasty carrot,isn't it?</code> 个人感觉更像反问语句。</li>
<li>时间地点数字格式：<code>Dec 1st,2021|Chengdu,Sichuan,China.</code>记住英语中时间和地点的表示方法。</li>
</ol>
<h3 id="句号">句号</h3>
<p>注意：英文的句号是一个实心的点”.”，不要写成中文的“。”。</p>
<p>句子说完就加句号</p>
<h3 id="分号：并列，有关">分号：并列，有关</h3>
<p><code>ex:The rabbit likes carrots;the wolf likes apples.</code></p>
<h3 id="冒号：">冒号：</h3>
<ol>
<li>列举： <code>ex:We have two lunch options:carrots,apples</code></li>
<li>引语：<code>ex:The rabbit: I want to eat carrots.</code> 原句是  <code>The rabbit said,&quot;I want to eat carrots.&quot;</code></li>
<li>主标题，副标题： <code>ex:Carrots:Rabbits'Favorite Food</code>  <code>ex:Sakiro:Shadows Die Twice.</code></li>
<li>时间表达：<code>ex:at 8:00</code></li>
</ol>
<h3 id="引号：和中文用法基本一致">引号：和中文用法基本一致</h3>
<p><code>Please don't be a &quot;freeloader&quot;</code> 可以表强调。</p>
<p>注意英文中没有书名号，一般都是用引号表示的<code>ex:Have you read &quot;The Little Prince&quot;</code> 或者用斜体。<em>The Little Prince</em></p>
<h3 id="破折号">破折号</h3>
<p>和中文用法一样，比中文短：<code>ex:You've met my best friend-the wolf.</code>或者表示句子中断</p>
<h3 id="问号和感叹号">问号和感叹号</h3>
<p>不多解释，问号用于问句，感叹号用于感叹句</p>
<h3 id="连字符，撇号">连字符，撇号</h3>
<p>前者是构词，后者用于所有格或者省略 <code>ex:Hard-working</code> <code>ex:The rabbit's carrots\you'd better finish it first.</code></p>
<h3 id="省略号">省略号</h3>
<p>英文的省略号只有三个点，而且居下 <code>ex:To be continued...</code></p>
<h1>参考</h1>
<ol>
<li>【英语语法精讲合集 (全面, 通俗, 有趣 | 从零打造系统语法体系)】<a href="https://www.bilibili.com/video/BV1XY411J7aG?p=29&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c">https://www.bilibili.com/video/BV1XY411J7aG?p=29&amp;vd_source=bb8dacb993f11c0e39f8147c98a2894c</a></li>
<li><a href="https://excalidraw.com/#:~:text=Excalidraw%20is%20a%20virtual%20collaborative%20whiteboard%20tool%20that">Excalidraw绘图网站</a></li>
<li><a href="https://www.yingyutu.com/">英语兔 (yingyutu.com)</a> 其实是微信公众号不是网站</li>
<li><a href="https://dictionary.cambridge.org/zhs/%E8%AF%8D%E5%85%B8/">免费的剑桥英语词典和同义词词典 (cambridge.org)</a></li>
</ol>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
</search>
