<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法系列(三)蓝桥杯_算法高阶(三) | Lloyd的个人博客</title><meta name="author" content="Lloyd,kai9827@outlook.com"><meta name="copyright" content="Lloyd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="总结了C&#x2F;C++赛道蓝桥杯常见的题型以及背后的算法原理,为读者提供一个刷题和总结的参考。">
<meta property="og:type" content="article">
<meta property="og:title" content="算法系列(三)蓝桥杯_算法高阶(三)">
<meta property="og:url" content="http://lloyd-kai.github.io/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/index.html">
<meta property="og:site_name" content="Lloyd的个人博客">
<meta property="og:description" content="总结了C&#x2F;C++赛道蓝桥杯常见的题型以及背后的算法原理,为读者提供一个刷题和总结的参考。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg">
<meta property="article:published_time" content="2025-02-20T00:07:57.000Z">
<meta property="article:modified_time" content="2025-02-23T12:07:12.430Z">
<meta property="article:author" content="Lloyd">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法系列(三)蓝桥杯_算法高阶(三)",
  "url": "http://lloyd-kai.github.io/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/",
  "image": "https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg",
  "datePublished": "2025-02-20T00:07:57.000Z",
  "dateModified": "2025-02-23T12:07:12.430Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lloyd",
      "url": "https://github.com/lloyd-kai/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lloyd-kai.github.io/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="vNvK4ziqUShGY5vf9FoDHK_aV9gyXHz7LwfeSygAmVI"/><meta name="msvalidate.01" content="DF281BDECF95EB0C20BC890873302353"/><link rel="stylesheet" href="/css/index.css?v=5.3.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Lloyd","link":"链接: ","source":"来源: Lloyd的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法系列(三)蓝桥杯_算法高阶(三)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://s2.loli.net/2024/10/22/K3EUTFgQsdqV9j4.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://s2.loli.net/2024/10/21/WXqzA7jMSxHo6fO.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/computer/"><i class="fa-fw fa fa-television"></i><span> 计算机</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/draw/"><i class="fa-fw fa fa-paint-brush"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/galgame/"><i class="fa-fw fa fa-gamepad"></i><span> 视觉小说</span></a></li><li><a class="site-page child" href="/privacy/"><i class="fa-fw fa fa-exclamation-circle"></i><span> 隐私政策</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Lloyd的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">算法系列(三)蓝桥杯_算法高阶(三)</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/computer/"><i class="fa-fw fa fa-television"></i><span> 计算机</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/draw/"><i class="fa-fw fa fa-paint-brush"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/galgame/"><i class="fa-fw fa fa-gamepad"></i><span> 视觉小说</span></a></li><li><a class="site-page child" href="/privacy/"><i class="fa-fw fa fa-exclamation-circle"></i><span> 隐私政策</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法系列(三)蓝桥杯_算法高阶(三)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-20T00:07:57.000Z" title="发表于 2025-02-20 08:07:57">2025-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-23T12:07:12.430Z" title="更新于 2025-02-23 20:07:12">2025-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/algorithm/">algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:730,&quot;messagePrev&quot;:&quot;自从上次更新以来已经过去了&quot;,&quot;messageNext&quot;:&quot;天,这篇文章(主要是技术性博客)的内容可能已经过期&quot;,&quot;postUpdate&quot;:&quot;2025-02-23 20:07:12&quot;}" hidden></div><h1>算法高阶</h1>
<blockquote>
<p>本部分算法难度较高，建议读者充分掌握算法基础之后再来学习。</p>
<p>目前以视频的方法为主，等蓝桥杯考完之后按照labuladong或者是考研的方法写代码。</p>
</blockquote>
<h2 id="我的仓库使用指南">我的仓库使用指南</h2>
<p>我的仓库链接格式如下：<code>https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/1_20</code> 其中1_20表示的是日期(一般是2025)，里面的文件就包含对应题目的解答(均通过对应题目的测试)或者是算法实现，其中文件名<code>lanqiao</code>表示 是<strong>蓝桥杯官网上的题目</strong>，<code>_</code> 后面的数字是蓝桥杯的<strong>题目编号</strong>，可以找到对应的蓝桥杯的题目，比如题目链接是<code>https://www.lanqiao.cn/problems/498/learning/?page=1&amp;first_category_id=1&amp;problem_id=498</code>    <code>problems</code>斜杠后面的数字<strong>498</strong> 就是对应的题目编号，你就在我指定链接下面的文件夹下按照<code>lanqiao_题目编号.cpp</code> 这样的格式找对应文件，就可以看到对应题目的解答代码。</p>
<p><img src="https://s2.loli.net/2025/02/06/n4dH1aOXoCc35Sy.png" alt="001_demo.png"></p>
<hr>
<h2 id="数据结构">数据结构</h2>
<h3 id="基础数据结构">基础数据结构</h3>
<h4 id="RMQ问题">RMQ问题</h4>
<p>【概念】：RMQ(Range Minimum/Maximum Query)问题是指对于数组，<strong>每次给一个区间[l,r],要求返回区间内的最大值或最小值</strong>（的下标）也就是说，RMQ就是<strong>求区间最值的问题</strong>。对于RMQ问题，容易想到一种O(n)的方法，就是用i直接遍历区间，找出不断比较a[i]与max的大小关系，然后不断更新max,最后得出的就是最大值。但是如果要进行多次的查询，这个算法将会变得非常慢。于是，我们可以利用倍增和动态规划的思想，利用“ST表”这个数据结构来帮助解决。</p>
<p><strong>ST表</strong></p>
<p>ST表是一种可以“静态求区间最值”的数据结构，本质上是一种dp.假设我们要求区间最大值（最小值类似），设状态<code>st[i][j]</code>表示从开始，大小为2^ j的长度的区间的最大值，即区间[i,i+2^j-1]的最大值。状态转移方程为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">st[i][j]=max(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">))]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mpunct">;</span></span></span></span>注意状态转移的方向和保证区间合法。</p>
<p><strong>区间查询</strong>：为了查询区间[[l,r]的最大值，它可以分解为两个小区间的最大值，例如要求[2,7]的最大值，可以分解为[2,2+2 ^ 2-1],[7-2 ^ 2+1,7]的最大值，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mn>7</mn><mo>−</mo><mn>4</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(st[2][2],st[7-4][2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">])</span></span></span></span>,拓展一下，[l,r]区间，需要找出一个k,使得2^ k&lt;=r-1+1,k&lt;=log2(r-l+1),可以分解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>r</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(st[l][k],st[r-2^k+1][k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">])</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(r-l<span class="number">+1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][k],st[r-(l&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/1205/learning/?page=1&amp;first_category_id=1&amp;problem_id=1205">1.区间最大值 - 蓝桥云课</a></li>
</ul>
<p>直接按照st表模板套就行</p>
<h4 id="并查集">并查集</h4>
<p>【概念】：并查集是一种图形数据结构，用于存储图中结点的连通关系。每个结点有一个父亲，可以理解为“一只伸出去的手”，会指向另外一个点，初始时指向自己。个点的根节点是该点的父亲的父亲的…的父亲，直到某个点的父亲是自己（根）当两个点的根相同时，我们就说他们是属于同一类，或者说是连通的。比如：3、6的根都是3，所以他们是连通的，2、4是连通的，而2、6不连通，因为他们的根不同。</p>
<p>【实现】：找根函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果根是自己就返回</span></span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根不是自己就返回父节点的根</span></span><br><span class="line">    <span class="comment">//pre数组是存储父节点的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">root</span>(pre[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>合并操作</strong>：在并查集中，所有的操作都在根上，假如我要使得x和y两个点合并，只需要将root(x)指向root(y),或使得root(y)指向root(x)。即</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre[<span class="built_in">root</span>(x)] = <span class="built_in">root</span>(y);</span><br></pre></td></tr></table></figure>
<p><strong>路径压缩</strong>：找根函数的复杂度最坏情况下会达到O(n),如果查询次数较多的话效率将会非常低下。我们可以在找根的过程中，将父亲直接指向根，从而实现路径压缩，这样可以使得找根的总体时间,复杂度接近O(1)。如下图，执行一次root(7)之后，沿途的点都会直接指向根3。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[x] = (pre[x] == x?x:<span class="built_in">root</span>(pre[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/1135/learning/?page=1&amp;first_category_id=1&amp;problem_id=1135">1.蓝桥幼儿园 - 蓝桥云课</a></li>
</ul>
<p>直接用并查集就行了</p>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_20">点击此处</a></p>
<hr>
<p><strong>带权并查集</strong></p>
<p>【例子引入】：某个镇上的几个居民家族怀着重建家谱的愿望，以便能够追溯自己的家族历史。由于时间的流逝，这些家族只能依靠现存的资料来确定镇上曾经存在过的家族关系。根据现有的资料，我们能够获知镇上居民之间的父子关系，从而描绘出一个家族谱系。基于上述情况，我们需要进行一系列的查询，以确定每个现存居民属于哪个家族，并且<strong>找出最早祖先的名字，并且查询是第几代人</strong>。这个过程将帮助我们重新构建这些家族的历史，从而理清各个家族之间的关系。此时就是<strong>带权并查集</strong>了，<strong>特殊的每个边权值为1</strong>。简而言之，就是带权值的并查集。</p>
<p>【实现】：带权并查集和普通的并查集不一样，需要维护某一个节点到其根节点的路径长度(权值和)，首先我们需要定义一个dis数组：dis[],fa[],由于我们还需要维护路径长度，所以需要改写两个操作函数：1. 因为路径压缩会改变点与点的连接关系，路径压缩后，点的父节点变为了根节点，所以需要更新Dis数组 2.集合的代表元（根节点）是没有父结点的，所以Dis数组中也没有值。但是合并集合后其中一个根节点变为了另一个集合根节点的子节点，所以需要赋值。</p>
<p><strong>Find函数：</strong><br>
递推找到该节点的祖先节点，在回归过程中实现路径压缩。路径压缩可以理解成将该节点直接连到祖先节点上，当它儿子节点，同时权值dis也更新成与祖先节点的关系。路径上的每一个节点先更新该节点的父亲节点father(=fa[x])与祖先节点的关系（递归），然后该节点和祖先节点的关系就可以表示为dis[x]+dis[father];示例代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果节点的父节点是他本身</span></span><br><span class="line">    <span class="keyword">if</span>(f[x] == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则递归找到其父节点</span></span><br><span class="line">    <span class="type">int</span> fa = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    dis[x] += dis[f[x]];</span><br><span class="line">    <span class="keyword">return</span> f[x] = fa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>merge函数</strong>：合并两个没有联系的独立集合。两个集合本来没有联系，每个集合内部的点存在联系，通过联系两个不同集合中独立的两个点使得两个集合建立关系。合并两个集合，<strong>实质就是建立两个集合中祖先节点之间的关系</strong>。合并后集合内部的点之间的关系通过各自和祖先节点之间的关系得到。示例代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：先通过find实现路径压缩，将x和y节点直接连在各自祖先节点上，得出和祖先节点的关系dis[x],dis[y],合并祖先节点fx,fy,并通过向量得到fx和fy关系。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="comment">//如果两个节点的父节点相同</span></span><br><span class="line">    <span class="keyword">if</span>(fx == fy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[fx] = fy;</span><br><span class="line">    dis[fx]+=c+dis[y]-dis[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dist函数</strong>：判断两个节点是否存在关系，以及什么关系的函数。先find找各自祖先，如果重合，那么就是有关系，如果不重合，则无关，<br>
返回-1.重合的情况下，二者已通过find路径压缩得到与共同祖先的关系，分别是dis[x],dis[y}。那么x和y之间的关系通过向量的关系可以得到dis[x]-dis[y]</p>
<p><strong>可撤销并查集</strong></p>
<p>后续补上，目前性价比较低。</p>
<h4 id="堆">堆</h4>
<p>【概念】：在语法基础课中其实有讲过优先队列，其实优先队列就是一个堆，它可以维护一个集合的最大值（或最小值）。</p>
<p>在做算法题的时候强调过会使用优先级队列就行了，如果想要深入理解数据结构，还需要<strong>手动实现堆这种数据结构</strong>。</p>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/3433/learning/?page=1&amp;first_category_id=1&amp;problem_id=3433">1.一道简单的取模问题 - 蓝桥云课</a></li>
</ul>
<p>优先级队列的经典应用，做题基本上达到这种程度就可以了，接下来就要讲解堆的实现。</p>
<hr>
<p><strong>堆是一种二叉树</strong>，对于每个结点满足：儿子的权值都比自己的权值小。这个性质不断向上传递直到根，就可以保证：<strong>根的权值是整棵树中最大的</strong>。例如左图是一个<strong>大根堆(或者叫大顶堆)</strong>，而右图却不是。</p>
<p>手写堆比较繁琐(<strong>学过数据结构的同学应该深有体会</strong>)，实际做题中几乎不用，但是对于我们理解堆这种数据结构尤为重要，手写堆需要实现以下几个函数：</p>
<ol>
<li>
<p>pushup()将某个点向上更新，一般是将最后一个点向上更新</p>
</li>
<li>
<p>pushdown()将某个点向下更新，一般将根向下更新</p>
</li>
<li>
<p>push()插入一个点到堆内</p>
</li>
<li>
<p>pop()将根结点删除</p>
</li>
</ol>
<p>我们采用数组的方式来存储数据，利用二叉树的性质：<strong>2x表示x的左儿子编号，2x+1表示x的右儿子编号。用sz表示结点数量，a[x]表示结点x的权值。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pushup函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">1</span>) <span class="comment">//只要不是根节点，就一直和父节点比较并更新</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x]&gt;a[x&gt;&gt;<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果节点到了某个位置停下了，就跳出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pushdown函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果没有子节点</span></span><br><span class="line">    <span class="keyword">if</span>((x&lt;&lt;<span class="number">1</span>)&gt;sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有左子节点</span></span><br><span class="line">    <span class="keyword">if</span>((x&lt;&lt;<span class="number">1</span> | <span class="number">1</span>)&gt;sz )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x&lt;&lt;<span class="number">1</span>]&gt;a[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushdown</span>(x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//左右子节点都有</span></span><br><span class="line">        <span class="keyword">if</span>(a[x] == <span class="built_in">max</span>(&#123;a[x],a[x&lt;&lt;<span class="number">1</span>],a[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]&#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a[x&lt;&lt;<span class="number">1</span>]&gt;a[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushdown</span>(x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushdown</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//push函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++sz] = x;</span><br><span class="line">    <span class="built_in">pushup</span>(sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = a[sz--];</span><br><span class="line">    <span class="built_in">pushdown</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_21">点击此处</a></p>
<h4 id="链表、栈、队列">链表、栈、队列</h4>
<blockquote>
<p>用数组的方式实现</p>
</blockquote>
<p>【概念】：这一部分很多都是数据结构上讲到的东西，读者完全可以翻书查看，这里就不讲解其概念了(<strong>其实用C语言实现更加底层，更能理解其数据结构</strong>)，读者完全可以只看数据结构中是如何实现的，这里主要讲一些例题，并且用相对底层的方法解答。</p>
<ul>
<li>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/3255/learning/?page=1&amp;first_category_id=1&amp;problem_id=3255">1.重新排队 - 蓝桥云课</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/2490/learning/?page=1&amp;first_category_id=1&amp;problem_id=2490">1.小蓝的括号串1 - 蓝桥云课</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/511/learning/?page=1&amp;first_category_id=1&amp;problem_id=511">1.机器翻译 - 蓝桥云课</a></p>
</li>
</ul>
<hr>
<p><strong>单调栈与单调队列</strong></p>
<p>【概念】：单调栈是一个时刻保证内部元素具有单调性质的栈，是一种线性结构。其单调特性使得处理一些问题变得高效，例如求某个点左侧或右侧第一个比它大的点的位置。单调栈的核心思想是：在<strong>入栈时逐个删除所有“更差的点”</strong>，保持单调性。单调栈一般可分为单调递减栈、单调递增栈、单调不减栈、单调不增栈，需要根据题意来确定。同时，<strong>用数组实现的单调栈会比用STL实现的更灵活</strong>，可以在里面进行二分，LIS的O(logn)算法就需要用到单调栈+二分。</p>
<p>【概念】：单调队列和单调栈思想类似，是一种基于“双端队列”的数据结构。单调队列内元素具有单调性质，<strong>但是大多时候我们会将“下标”作为队列中的元素，而不是“元素值”</strong>。一般来说，单调队列的队头是“最优的元素”，后面的是候选元素，每次入队时会将“没有价值的元素”直接删除。</p>
<p>【例题】</p>
<ul>
<li>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/1142/learning/?page=1&amp;first_category_id=1&amp;problem_id=1142">1.百亿富翁 - 蓝桥云课</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/3707/learning/?page=1&amp;first_category_id=1&amp;problem_id=3707">1.买蛋糕 - 蓝桥云课</a></p>
</li>
</ul>
<p>用单调队列分别处理出固定长度区间的最大值和最小值，然后用遍历区间[k,n],计算有多少个区间的最值之差&lt;=x,总区间个数为n-k+1,再结合逆元计算即可。</p>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_21">点击此处</a></p>
<h2 id="树">树</h2>
<blockquote>
<p>同前面的部分，不对数据结构中已经详细介绍的重复介绍，而主要讲解在解题上的应用。</p>
</blockquote>
<h3 id="DFS序">DFS序</h3>
<p>【概念】：DFS序是指对一棵树进行DFS时，每个节点被访问到的顺序。DFS序分成两部分：进入该节点的顺序和退出该节点的顺序。</p>
<p>【实现】：</p>
<p>对于DFS中当前节点</p>
<ol>
<li>计数+</li>
<li>进入当前节点的顺序等于当前计数</li>
<li>向所有子节点继续搜索</li>
<li>推出当前节点的顺序等于当前计数</li>
</ol>
<p>示例代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> f)</span><span class="comment">//t表示当前节点编号，f表示父节点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in[t] = ++cnt;<span class="comment">//in数组存放的是进入改节点的顺序，cnt用来计时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[t];i;i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].n!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(edge[i].n,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out[t] = cnt;<span class="comment">//out表示退出该节点的顺序，也就是dfs递归完回退部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相关重要性质</strong></p>
<ul>
<li>某些连续的入序对应树中的节点是一条链；</li>
<li>某节点入序和出序之间对应的节点一定在其子树中。</li>
</ul>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/3549/learning/?page=1&amp;first_category_id=1&amp;problem_id=3549">1.异或和 - 蓝桥云课</a></li>
</ul>
<p>基本上是在原有dfs的基础上加上dfs序的模板就可以解决</p>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_22">点击此处</a></p>
<h3 id="LCA">LCA</h3>
<p>【概念】：LCA(Least Common Ancestors),即最近公共祖先，是指在有根树中，找出某两个结点x和y最近的公共祖先。</p>
<p>【实现】：一种朴素的球阀就是枚举，不断向上找父亲直到两者的父亲相同，但是时间复杂度较高，而我们这里实现的方法是<strong>倍增法</strong>，</p>
<p>倍增法求LCA本质上是一个dp,类似于之前讲过的ST表。<code>fa[i][j]</code>表示i号节点，往上走2 ^ j所到的结点，当dep[i]-2^j&gt;=1时<code>fa[i][j]</code>有效（假设根节点深度为1)这个fa数组同样用dfs可以求出来，示例代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前节点为x,父亲为p</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[p]<span class="number">+1</span>;<span class="comment">//更新dep</span></span><br><span class="line">    fa[x][<span class="number">0</span>] = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)<span class="comment">//循环更新fa</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下搜索</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果y是父亲就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(y == p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倍增LCA中还用到了贪心的思想，在具体进行查询LCA(x,y)时，同样是假设x深度更深，然后从大到小枚举j,当<code>fa[x][j]</code>的深度不超过y的深度时，x才能往上跳。也就是说要让<strong>x往上跳，但是不能超过y,又要尽可能接近y</strong>.跳完之后必然有dep[x]=dep[y],此时如果x=y直接返回，否则再按照同样的方法<strong>同时往上跳，保持x!=y,最后一定会停留在LCA(x,y)的下方</strong>，返回<code>fa[x][0]</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果x深度比y小，就交换x,y，使得x深度更深</span></span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//贪心的思想，i从大到小</span></span><br><span class="line">    <span class="comment">//x向上跳的过程中,保持dep[x]&gt;=dep[y]，深度不能超过y</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y])</span><br><span class="line">        &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳跃过程中，保持x!=y</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/4385/learning/?page=1&amp;first_category_id=1&amp;problem_id=4385">1.最近公共祖先LCA查询 - 蓝桥云课</a></li>
</ul>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_22">点击此处</a></p>
<h3 id="树的直径与重心">树的直径与重心</h3>
<p>【概念】：<strong>树的直径是树上最长的一条链</strong>，当然这条链<strong>不唯一</strong>，所以一棵树可能有多条直径。直径由两个顶点u,V决定，若有一条直径u,v,则满足以下性质：1. u,v的度数均为1   2. 在以任意一个点为根的树上，<strong>u,v中必然存在一个点作为最深的叶子结点。深度就是点距离根节点的距离</strong></p>
<p>【实现】</p>
<p>树的直径有两种求法，第一种方法是“跑两遍fs”，第二种方法是树形dp。我们先讲解第一种方法“跑两遍dfs”。<br>
由于直径端点u,v必然存在一个是深度最深的点，那么我们可以在<strong>以任意节点为根的树上跑一次dfs求所有点的深度，选取深度最大的点</strong>（可能有多个，任取一个）作为u,然后以u为根再跑一次dfs,此时深度最大的点(可能有多个，任取一个)就是v.于是就可以得到两个端点u,v,从而确定树的直径，<strong>其长度就是路径上点的个数</strong>，也就等于以u为根的树中的dep[v]。</p>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/3029/learning/?page=1&amp;first_category_id=1&amp;problem_id=3029">1.卖树 - 蓝桥云课</a></li>
</ul>
<p>首先，如果k&lt;=C,那么肯定不能进行移动，因为每移动一次，都会付出C的代价，但是最多使得最深的点深度+1，换来k的收益，这是不划算的。当k&gt;C时，随意画一棵树，可以将树划分为三部分。我们认为根的深度为0.换句话说，最优的位置一定是不经过直径的最深的叶子(图中的8或15)，或者v.他们两个的盈利分别是：dep[u]* k+maxdep * (k-c); dpeU[v] * k-dep[v] * c，其中dep[x]表示的是以1为根的树中x的深度，depU[x]表示的以U为根的数中x的深度。</p>
<p><strong>树的重心</strong></p>
<p>【概念】：树的重心是指对于某个点，<strong>将其删除后，可以使得剩余联通块的大小的点</strong>。也就<strong>等价于以某个点为根的树，将根删除后，剩余</strong><br>
<strong>的若干棵子树的大小最小</strong>。我们先学习重心的若干性质，然后学习其求法（很简单）我们用mss[x]表示x点的所有子树大小的最大值。注意，此时我们认为除去x及其子树剩余的部分也是x的子树。</p>
<p>相关性质</p>
<ul>
<li>性质一：<strong>重心的若干棵子树的大小一定&lt;=n</strong>(n为总节点个数),除了重心以外的所有其他点，都必然存在一棵节点个数&gt;n的子树。</li>
<li>性质二：一棵树至多两个重心，如果存在两个重心，则必然相邻，将连接两个重心的边删除后，一定划分为两棵大小相等的树。</li>
<li>性质三：树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。</li>
<li>性质四：把两棵树通过一条边相连得到一棵新的树，则新的重心在较大的一棵树一侧的连接点与原重心之间的简单路径上。如果两棵树大小一样，则重心就是两个连接点。</li>
</ul>
<p>【实现】：非常简单，跑一遍dfs，如果mss[x]&lt;=n/2,则x是重心，反之不是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>,mss[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sz[x]+=sz[y];</span><br><span class="line">        mss[x] = <span class="built_in">max</span>(mss[x],sz[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    mss[x] = <span class="built_in">max</span>(mss[x],n-sz[x]);</span><br><span class="line">    <span class="keyword">if</span>(mss[x]&lt;=n/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_22">点击此处</a></p>
<h3 id="树链剖分">树链剖分</h3>
<p>【概念】：树链剖分（树剖）用于将树分割成若干条链的形式，以维护树上路径的信息。</p>
<p><strong>重链剖分</strong>：重链剖分优先使用重儿子延续当前链，轻儿子则另开新链。重儿子指某节点的所有儿子中，<strong>子树大小最大的儿子</strong>，其他儿子均为轻儿子。</p>
<p>示例的数据结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ord;<span class="comment">//DFS序计数</span></span><br><span class="line"><span class="type">int</span> rnk[MAXN];<span class="comment">//rnk[i]代表入序为i的节点编号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fa;<span class="comment">//当前节点的父节点</span></span><br><span class="line">    <span class="type">int</span> in;<span class="comment">//当前节点的DFS入序</span></span><br><span class="line">    <span class="type">int</span> out;<span class="comment">//当前节点的DFS出序</span></span><br><span class="line">    <span class="type">int</span> son;<span class="comment">//当前节点的重儿子编号</span></span><br><span class="line">    <span class="type">int</span> top;<span class="comment">//当前节点所需链的首节点编号</span></span><br><span class="line">    <span class="type">int</span> deep;<span class="comment">//当前节点在树中的深度</span></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//当前节点的子树大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【实现】：一般是通过两次dfs实现的，第一次预处理出每个节点的基本信息：深度、子树大小、父节点、重儿子,第二次利用前边预处理出的信息对树进行剖分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次的dfs</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node[t].size = <span class="number">1</span>;</span><br><span class="line">	node[t].fa = fa;</span><br><span class="line">	node[t].deep = node[fa].deep<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">for</span>(itn i = head[t];i;i = edge[i].next) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(edge[i].n!=fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(edge[i].n,t);</span><br><span class="line">			node[t].<span class="built_in">size</span>() += node[edge[i].n].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span>(node[edge[i].n].size&gt; node[node[t].son].size)</span><br><span class="line">			&#123;</span><br><span class="line">				node[t].son = edge[i].n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二次dfs</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> fa,<span class="type">int</span> top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[t].top = top;</span><br><span class="line">    node[t].in = ++ord;</span><br><span class="line">    rnk[ord] = t;</span><br><span class="line">    <span class="keyword">if</span>(node[t].son)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(node[t].son,t,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[t];i;i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].n != fa &amp;&amp; edge[i].n != node[t].son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(edge[i].n,t,edge[i].n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node[t].out = ord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相关的性质</strong>:每一条链子的dfs序都是连续的</p>
<p>相关的操作</p>
<p>查询两节点的最近公共祖先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node[x].top!=node[y].top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[node[x].top].deep&lt;node[node[y].top].deep)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        x = node[node[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node[x].deep&gt;node[y].deep?y:x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改两个节点之间的路径信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node[x].top!=node[y].top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[node[x].top].deep&lt;node[node[y].top].deep)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update_v</span>(<span class="number">1</span>,<span class="number">1</span>,ord,node[node[x].top].in,node[x].in,k);</span><br><span class="line">        x = node[node[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node[x].deep&lt;node[y].deep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update_v</span>(<span class="number">1</span>,<span class="number">1</span>,ord,node[y].in,node[x].in,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树上差分">树上差分</h3>
<p>【例题引入】：树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。这就是树上差分的基本操作。树上差分，就是利用差分的性质，对路径上的重要节点进行修改而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs遍历求出差分数组的前缀和，就可以达到降低复杂度的目的。需要注意的是<strong>树上差分需要求LCA</strong>，</p>
<p>【例题】：</p>
<ul>
<li>现在有一棵树，给定条路径，每条路径给定两个端点，两个端点之间的路径所覆盖的点进行染色，问每一个点被染色了多少次。</li>
</ul>
<p>本问题的实现代码在文件名为<code>TreeDiff.cpp</code>文件中</p>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_23">点击此处</a></p>
<h3 id="主席树">主席树</h3>
<p>【概念】：主席树，全称可持久化权值线段树。所谓可持久化，就是对于每次操作，都保留其历史版本(有点像是git(❁´◡`❁))</p>
<p>【实现】：以下主要讲解其数据结构</p>
<ol>
<li>建树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//v表示该节点的值,ls与rs表示该节点的左右子节点编号</span></span><br><span class="line">    <span class="type">int</span> v,ls,rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//cnt记录节点的数量</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//root[i]表示第i个版本的根节点</span></span><br><span class="line">    <span class="type">int</span> root[MAXN&lt;&lt;<span class="number">5</span>];</span><br><span class="line">    NODE node[MAXN&lt;&lt;<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>更新：一、如果当前节点未创建，则创建该节点，复制原节点信息。二、如果左儿子需要更新，则将原来的右儿子作为当前节点的右儿子；如果右儿子需要更新，则将原来的左儿子作为当前节点的左儿子；三、最终进入下一层递归，未创建的儿子节点将在下一层创建</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_t表示原节点编号 t表示当前新节点编号 l,r表示当前节点的区间 pos表示待更新的位置，k为更新的目标值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SETGTREE::update</span><span class="params">(<span class="type">int</span> <span class="type">_t</span>,<span class="type">int</span> &amp;t,<span class="type">int</span> l.<span class="type">int</span> r.<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">    &#123;</span><br><span class="line">        t = cnt++;</span><br><span class="line">        node[t].v = node[<span class="type">_t</span>].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[t].v+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">        node[t].rs = node[<span class="type">_t</span>].rs;</span><br><span class="line">        <span class="built_in">update</span>(node[<span class="type">_t</span>].ls,node[t].ls,l,mid,pos,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        node[t].ls = node[<span class="type">_t</span>].ls;</span><br><span class="line">        <span class="built_in">update</span>(node[<span class="type">_t</span>].rs,node[t].rs,mid<span class="number">+1</span>,r,pos,k);</span><br><span class="line">    &#125;</span><br><span class="line">    node[t].v = node[node[t].ls].v+node[node[t].rs].v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查询：如果当前节点未创建，则返回0；如果已经找到目标区间，返回该区间的值；如果未找到目标区间，则进入下一层递归。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t为当前节点的编号,_l,_r表示当前节点的区间,l,r表示待查询的区间。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SEGTREE::getV</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> _l,<span class="type">int</span> _r,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == _l &amp;&amp; r == _r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node[t].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (_l+_r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getV</span>(node[t].ls,_l,mid,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getV</span>(node[t].rs,mid<span class="number">+1</span>,_r,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getV</span>(node[t].ls,_l,mid,l,mid)+<span class="built_in">getV</span>(node[t].rs,mid<span class="number">+1</span>,_r,mid<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lanqiao.cn/problems/1132/learning/?page=1&amp;first_category_id=1&amp;name=%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F">1.区间第k小 - 蓝桥云课</a></li>
</ul>
<p>本部分算法实现与例题解决实现代码链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/cpp-lanqiaocup/tree/main/2_23">点击此处</a></p>
<h3 id="伸展树">伸展树</h3>
<blockquote>
<p>考的比较少，后续补上，就是平衡二叉查找树的pro max版本，相关操作也基本上是平衡二叉树的。</p>
</blockquote>
<h2 id="参考">参考</h2>
<ol>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode.cn/circle/discuss/E3yavq/">力扣刷题攻略</a>  读者可以在这里参考刷题。</li>
<li>蓝桥云课C++班，作者谢子杨</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/">Lloyd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lloyd-kai.github.io/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/">http://lloyd-kai.github.io/2025/02/20/算法系列(三)蓝桥杯_算法高阶_3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://lloyd-kai.github.io" target="_blank">Lloyd的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2024/10/25/RrwMATOW7uJoh43.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2024/10/25/RrwMATOW7uJoh43.png" alt="微信(WeChat)"/></a><div class="post-qr-code-desc">微信(WeChat)</div></li><li class="reward-item"><a href="https://paypal.me/lloydkai?country.x=C2&amp;locale.x=zh_XC" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2024/10/24/iPaXmYhtQnOsZrx.png" alt="PayPal(点击图片跳转 Click on the image to jump)"/></a><div class="post-qr-code-desc">PayPal(点击图片跳转 Click on the image to jump)</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)"><img class="cover" src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">算法系列(三)蓝桥杯_算法高阶(二)</div></div><div class="info-2"><div class="info-item-1">总结了C/C++赛道蓝桥杯常见的题型以及背后的算法原理,为读者提供一个刷题和总结的参考。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/06/25/%E3%80%8A%E9%AB%98%E8%B4%A8%E9%87%8FC%E3%80%81C++%E3%80%8B%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" title="《高质量C、C++》笔记整理"><img class="cover" src="https://s2.loli.net/2024/06/10/QHqgRXDGwunkt4l.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-25</div><div class="info-item-2">《高质量C、C++》笔记整理</div></div><div class="info-2"><div class="info-item-1">教你如何提升C && C++ 代码的质量</div></div></div></a><a class="pagination-related" href="/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%8A%E5%85%B6%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="算法系列(一)蓝桥杯及其知识体系"><img class="cover" src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-14</div><div class="info-item-2">算法系列(一)蓝桥杯及其知识体系</div></div><div class="info-2"><div class="info-item-1">总结了C/C++赛道蓝桥杯的知识点以及背后的算法原理，旨在为竞赛和后续算法学习打下基础</div></div></div></a><a class="pagination-related" href="/2025/02/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_1/" title="算法系列(三)蓝桥杯_算法高阶(一)"><img class="cover" src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-10</div><div class="info-item-2">算法系列(三)蓝桥杯_算法高阶(一)</div></div><div class="info-2"><div class="info-item-1">总结了C/C++赛道蓝桥杯常见的题型以及背后的算法原理,为读者提供一个刷题和总结的参考。</div></div></div></a><a class="pagination-related" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)"><img class="cover" src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-16</div><div class="info-item-2">算法系列(三)蓝桥杯_算法高阶(二)</div></div><div class="info-2"><div class="info-item-1">总结了C/C++赛道蓝桥杯常见的题型以及背后的算法原理,为读者提供一个刷题和总结的参考。</div></div></div></a><a class="pagination-related" href="/2025/01/12/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%BA%8C)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法系列(二)蓝桥杯_算法基础"><img class="cover" src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">算法系列(二)蓝桥杯_算法基础</div></div><div class="info-2"><div class="info-item-1">总结了C/C++赛道蓝桥杯常见的题型以及背后的算法原理,为读者提供一个刷题和总结的参考。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/10/21/WXqzA7jMSxHo6fO.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lloyd</div><div class="author-info-description">哲学家只是用不同的方式来看待世界,而问题在于改变世界.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai"><i class="fab fa-github"></i><span>访问我的Github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lloyd-kai/" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:kai9827@outlook.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=3472606843" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，此博客基于hexo和butterfly主题开发而成，希望来到此网站的同学们能够一起努力，追逐所愿</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">算法高阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%93%E5%BA%93%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-number">1.1.</span> <span class="toc-text">我的仓库使用指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RMQ%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">RMQ问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">链表、栈、队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS%E5%BA%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">DFS序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCA"><span class="toc-number">1.3.2.</span> <span class="toc-text">LCA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E4%B8%8E%E9%87%8D%E5%BF%83"><span class="toc-number">1.3.3.</span> <span class="toc-text">树的直径与重心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">树链剖分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">树上差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%B8%AD%E6%A0%91"><span class="toc-number">1.3.6.</span> <span class="toc-text">主席树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B8%E5%B1%95%E6%A0%91"><span class="toc-number">1.3.7.</span> <span class="toc-text">伸展树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/" title="算法系列(三)蓝桥杯_算法高阶(三)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(三)"></a><div class="content"><a class="title" href="/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/" title="算法系列(三)蓝桥杯_算法高阶(三)">算法系列(三)蓝桥杯_算法高阶(三)</a><time datetime="2025-02-20T00:07:57.000Z" title="发表于 2025-02-20 08:07:57">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(二)"></a><div class="content"><a class="title" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)">算法系列(三)蓝桥杯_算法高阶(二)</a><time datetime="2025-02-16T07:16:45.000Z" title="发表于 2025-02-16 15:16:45">2025-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_1/" title="算法系列(三)蓝桥杯_算法高阶(一)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(一)"></a><div class="content"><a class="title" href="/2025/02/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_1/" title="算法系列(三)蓝桥杯_算法高阶(一)">算法系列(三)蓝桥杯_算法高阶(一)</a><time datetime="2025-02-10T05:15:23.000Z" title="发表于 2025-02-10 13:15:23">2025-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%BA%8C)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法系列(二)蓝桥杯_算法基础"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(二)蓝桥杯_算法基础"></a><div class="content"><a class="title" href="/2025/01/12/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%BA%8C)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法系列(二)蓝桥杯_算法基础">算法系列(二)蓝桥杯_算法基础</a><time datetime="2025-01-12T05:31:17.000Z" title="发表于 2025-01-12 13:31:17">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%8A%E5%85%B6%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="算法系列(一)蓝桥杯及其知识体系"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(一)蓝桥杯及其知识体系"></a><div class="content"><a class="title" href="/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%8A%E5%85%B6%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="算法系列(一)蓝桥杯及其知识体系">算法系列(一)蓝桥杯及其知识体系</a><time datetime="2024-12-14T14:16:54.000Z" title="发表于 2024-12-14 22:16:54">2024-12-14</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/" title="算法系列(三)蓝桥杯_算法高阶(三)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(三)"/></a><div class="content"><a class="title" href="/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/" title="算法系列(三)蓝桥杯_算法高阶(三)">算法系列(三)蓝桥杯_算法高阶(三)</a><time datetime="2025-02-20T00:07:57.000Z" title="发表于 2025-02-20 08:07:57">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(二)"/></a><div class="content"><a class="title" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)">算法系列(三)蓝桥杯_算法高阶(二)</a><time datetime="2025-02-16T07:16:45.000Z" title="发表于 2025-02-16 15:16:45">2025-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_1/" title="算法系列(三)蓝桥杯_算法高阶(一)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(一)"/></a><div class="content"><a class="title" href="/2025/02/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_1/" title="算法系列(三)蓝桥杯_算法高阶(一)">算法系列(三)蓝桥杯_算法高阶(一)</a><time datetime="2025-02-10T05:15:23.000Z" title="发表于 2025-02-10 13:15:23">2025-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%BA%8C)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法系列(二)蓝桥杯_算法基础"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(二)蓝桥杯_算法基础"/></a><div class="content"><a class="title" href="/2025/01/12/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%BA%8C)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法系列(二)蓝桥杯_算法基础">算法系列(二)蓝桥杯_算法基础</a><time datetime="2025-01-12T05:31:17.000Z" title="发表于 2025-01-12 13:31:17">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%8A%E5%85%B6%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="算法系列(一)蓝桥杯及其知识体系"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(一)蓝桥杯及其知识体系"/></a><div class="content"><a class="title" href="/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%8A%E5%85%B6%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="算法系列(一)蓝桥杯及其知识体系">算法系列(一)蓝桥杯及其知识体系</a><time datetime="2024-12-14T14:16:54.000Z" title="发表于 2024-12-14 22:16:54">2024-12-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Lloyd</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lloyd-kai.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.2"></script><script src="/js/main.js?v=5.3.2"></script><script src="/js/tw_cn.js?v=5.3.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.19/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.19/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => setTimeout(() => {
      document.querySelectorAll(".abc-music-sheet").forEach(ele => {
        if (ele.children.length > 0) return
        ABCJS.renderAbc(ele, ele.innerHTML, {responsive: 'resize'})
      })
    }, 100)
    
    typeof ABCJS === 'object' ? abcjsFn()
      : btf.getScript('https://cdn.jsdelivr.net/npm/abcjs@6.4.4/dist/abcjs-basic-min.min.js').then(abcjsFn)
  }

  window.pjax ? abcjsInit() : window.addEventListener('load', abcjsInit)
  btf.addGlobalFn('encrypt', abcjsInit, 'abcjs')
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'lznevgEpvkZIT3hib1I36B54-gzGzoHsz',
      appKey: 'VvnbhZ2uIp2MRjW4y3ZFquQa',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-three-sand.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-api-three-sand.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.41/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Valine' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Valine' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer" data-id="2453833422" data-server="netease" data-type="playlist"  data-fixed="true" data-theme="#3F51B5"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.3.2"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">Linux</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/06/10/QHqgRXDGwunkt4l.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/blog/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">blog</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/06/10/R21dguZMKpAPhNf.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">MySQL</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/kerNGo78PMwicnV.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">C++</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/22/xcyb68osB27rQfu.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/data-structure/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">data structure</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/Qy4Edm6fxwKnbsL.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/大数据/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">大数据</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/KuYxMTlRckENvI5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/algorithm/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">algorithm</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/HzredPNWp2Qs3oJ.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/English/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">English</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="博客框架为Hexo_v7.3.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="主题版本Butterfly_v5.3.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>