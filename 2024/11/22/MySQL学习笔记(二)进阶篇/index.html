<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL学习笔记(二)进阶篇 | 长沙理工大学机制2206班博客</title><meta name="author" content="Lloyd,kai9827@outlook.com"><meta name="copyright" content="Lloyd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="教你学会MySQL的进阶知识，为测试、运维、后端开发、索引优化等方面做准备">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习笔记(二)进阶篇">
<meta property="og:url" content="http://lloyd-kai.github.io/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/index.html">
<meta property="og:site_name" content="长沙理工大学机制2206班博客">
<meta property="og:description" content="教你学会MySQL的进阶知识，为测试、运维、后端开发、索引优化等方面做准备">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png">
<meta property="article:published_time" content="2024-11-22T02:32:29.000Z">
<meta property="article:modified_time" content="2024-11-27T01:17:13.269Z">
<meta property="article:author" content="Lloyd">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="教程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL学习笔记(二)进阶篇",
  "url": "http://lloyd-kai.github.io/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/",
  "image": "https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png",
  "datePublished": "2024-11-22T02:32:29.000Z",
  "dateModified": "2024-11-27T01:17:13.269Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lloyd",
      "url": "https://github.com/lloyd-kai/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lloyd-kai.github.io/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="vNvK4ziqUShGY5vf9FoDHK_aV9gyXHz7LwfeSygAmVI"/><meta name="msvalidate.01" content="DF281BDECF95EB0C20BC890873302353"/><link rel="stylesheet" href="/css/index.css?v=5.3.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Lloyd","link":"链接: ","source":"来源: 长沙理工大学机制2206班博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL学习笔记(二)进阶篇',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://s2.loli.net/2025/03/19/BhnYefErAuRcvwg.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://s2.loli.net/2024/10/21/WXqzA7jMSxHo6fO.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/computer/"><i class="fa-fw fa fa-television"></i><span> 计算机</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/draw/"><i class="fa-fw fa fa-paint-brush"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/galgame/"><i class="fa-fw fa fa-gamepad"></i><span> 视觉小说</span></a></li><li><a class="site-page child" href="/privacy/"><i class="fa-fw fa fa-exclamation-circle"></i><span> 隐私政策</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">长沙理工大学机制2206班博客</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL学习笔记(二)进阶篇</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/computer/"><i class="fa-fw fa fa-television"></i><span> 计算机</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/draw/"><i class="fa-fw fa fa-paint-brush"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/galgame/"><i class="fa-fw fa fa-gamepad"></i><span> 视觉小说</span></a></li><li><a class="site-page child" href="/privacy/"><i class="fa-fw fa fa-exclamation-circle"></i><span> 隐私政策</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL学习笔记(二)进阶篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-22T02:32:29.000Z" title="发表于 2024-11-22 10:32:29">2024-11-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-27T01:17:13.269Z" title="更新于 2024-11-27 09:17:13">2024-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">18.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:730,&quot;messagePrev&quot;:&quot;自从上次更新以来已经过去了&quot;,&quot;messageNext&quot;:&quot;天,这篇文章(主要是技术性博客)的内容可能已经过期&quot;,&quot;postUpdate&quot;:&quot;2024-11-27 09:17:13&quot;}" hidden></div><blockquote>
<p>注：本篇博客大部分是黑马pdf中的内容，根据我自己学习的实际情况进行修改和补充。</p>
</blockquote>
<h1>准备工作</h1>
<ol>
<li>准备好虚拟机并安装好mysql</li>
</ol>
<h1>存储引擎</h1>
<p>概念：<strong>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式</strong> 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。</p>
<h2 id="MySQL体系结构">MySQL体系结构</h2>
<p>参考博客<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/qq_45938466/article/details/107941557">数据库工作原理</a></p>
<p><img src="https://s2.loli.net/2024/11/26/9XL8m1xhEAgzGFU.png" alt="100_演示图_01.png"></p>
<ol>
<li>连接层<br>
<strong>最上层</strong>是一些客户端和链接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了<strong>线程池</strong>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li>服务层<br>
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</li>
<li>引擎层<br>
存储引擎层， 存储引擎真正的<strong>负责了MySQL中数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</li>
<li>存储层<br>
数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</li>
</ol>
<h2 id="语法">语法</h2>
<ol>
<li>创建表时指定存储引擎</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [ COMMENT 字段<span class="number">1</span>注释 ] ,</span><br><span class="line">	......</span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎 [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL中默认的储存引擎为InnoDB</span></span><br><span class="line"><span class="comment">-- 示例 使用默认的存储引擎创建表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> account;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/8Vtqa1grxSKcBsT.png" alt="001_存储引擎_01.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表my_myisam,并指定MyISAM储存引擎</span></span><br><span class="line"><span class="keyword">create table</span> my_myisam(</span><br><span class="line">                          id <span class="type">int</span>,</span><br><span class="line">                          name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">) engine <span class="operator">=</span> MyISAM;</span><br><span class="line"><span class="comment">-- 以ibd为后缀的都是使用InnoDB引擎的表</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/EZjosleKiPkRVxM.png" alt="001_存储引擎_03.png"></p>
<ol start="2">
<li>查询当前数据库支持的存储引擎</li>
</ol>
<p>语法：<code>show engines;</code></p>
<p><img src="https://s2.loli.net/2024/11/26/1NiTYUDPLfIlKeG.png" alt="001_存储引擎_02.png"></p>
<p>可以看到&quot;engine&quot;这一行中InnoDB的&quot;Support&quot;字段为&quot;<strong>DEFAULT</strong>&quot;,也就是<strong>默认</strong>的意思。</p>
<h2 id="存储引擎的区别和特点">存储引擎的区别和特点</h2>
<p>重点讲解InnoDB，MyISAM和Memory存储引擎的特点</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">InnoDB</button><button type="button" class="tab">MyISAM</button><button type="button" class="tab">Memory</button></div><div class="tab-contents"><div class="tab-item-content active"><ol>
<li>介绍<br>
InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</li>
<li>特点<br>
DML操作遵循ACID模型，支持<strong>事务</strong>；<strong>行级锁</strong>，提高并发访问性能；支持<strong>外键</strong>FOREIGN KEY<strong>约束</strong>，保证数据的完整性和正确性；</li>
<li>文件<br>
xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。参数：innodb_file_per_table</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/hj7oSZl5rtq3KIR.png" alt="001_存储引擎_04.png"></p>
<p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的数据存放目录：C:\ProgramData\MySQL\MySQL Server 8.0\Data(<strong>按照你MySQL的安装路径修改</strong>)， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库.任意打开一个自建的文件夹，就会发现里面有许多后缀为.ibd的文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p>
<p><img src="https://s2.loli.net/2024/11/26/vI6j8VMYKPaJsQ9.png" alt="001_存储引擎_05.png"></p>
<ol start="4">
<li>逻辑存储结构</li>
</ol>
<p><img src="https://s2.loli.net/2024/11/26/G6DotI1dn4kKCv2.png" alt="001_存储引擎_06.png"></p>
<ul>
<li>表空间(Tablespace): InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据</li>
<li>段(Segment): 表空间是由各个段组成的， 分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段<br>
（Rollback segment）  等,InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</li>
<li>区(Extent): 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li>
<li>页(Page): 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
<li>行(Row): InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段.一个是Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。；另一个是Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</li>
</ul></div><div class="tab-item-content"><ol>
<li>介绍<br>
MyISAM是MySQL早期的默认存储引擎。</li>
<li>特点<br>
不支持事务，不支持外键;支持表锁，不支持行锁;访问速度快</li>
<li>文件<br>
xxx.sdi：存储表结构信息；xxx.MYD: 存储数据；xxx.MYI: 存储索引</li>
</ol></div><div class="tab-item-content"><ol>
<li>介绍<br>
Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</li>
<li>特点<br>
内存存放；hash索引（默认）</li>
<li>文件<br>
xxx.sdi：存储表结构信息</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<blockquote>
<p>InnoDB引擎与MyISAM引擎的区别 ?<br>
①. InnoDB引擎, 支持事务, 而MyISAM不支持。<br>
②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。<br>
③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。</p>
<p>具体其他细节可以参考官方文档：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html">MySQL :: MySQL 8.0 Reference Manual :: 17.1 Introduction to InnoDB</a></p>
</blockquote>
<h2 id="存储引擎的选择">存储引擎的选择</h2>
<blockquote>
<p>很多情况下技术的选择都具有局限性和折中性，不存在完美的选择，只有相对好的选择。</p>
</blockquote>
<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ol>
<li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li>
<li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ol>
<h1>索引</h1>
<p>概念：索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。简单来说就是数据结构在数据库中的应用(＾－＾)。</p>
<p>有索引和无索引搜索时间比较</p>
<p><img src="https://s2.loli.net/2024/11/26/UC9EAFGZgMlhL5a.png" alt="002_存储索引_01.png"></p>
<p>在表中数据较少的时候相差不大，但如果是千万级别的数据，差距就尤其明显。这是因为在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为<strong>全表扫描</strong>，其性能很低。 如果我们针对于这张表建立了索引 (比如二叉树) ,查询时就会按照二叉树的索引进行查找，二叉树搜索和穷举法哪个时间复杂度更小，不用我多说了吧（￣︶￣）。</p>
<p>索引的<strong>优点</strong>在于<strong>提高</strong>数据检索的<strong>效率</strong>，降低数据库的IO成本；通过索引列对数据进行排序，降低数据排序的成本，<strong>降低CPU的消耗</strong>，其<strong>缺点</strong>是索引列也是要<strong>占用空间</strong>的；索引大大提高了查询效率，同时却也<strong>降低更新表的速度</strong>， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</p>
<h2 id="索引结构">索引结构</h2>
<p>不同的存储引擎支持的索引结构不同，主要包含以下几种。</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索 引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td>
</tr>
<tr>
<td>Full-text(全文 索引)</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td>
</tr>
</tbody>
</table>
<p>不同存储索引对索引结构的支持情况</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>不加说明默认所说的索引都是B+数结构组织的索引</p>
</blockquote>
<h3 id="二叉树">二叉树</h3>
<blockquote>
<p>以下内容涉及到数据结构，有数据结构基础的读者会更容易理解。</p>
</blockquote>
<p>缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢 。使用红黑树也会存在层级较深的问题。</p>
<h3 id="B-Tree与B-Tree">B-Tree与B+Tree</h3>
<p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针</p>
<p><img src="https://s2.loli.net/2024/11/26/lBwy7UXRN35sjch.png" alt="100_演示图_02.png"></p>
<p>读者可以通过此网站观看B树数据插入的方式和节点的变化。<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization</a> 就会发现</p>
<ul>
<li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li>
<li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li>
<li>在B树中，非叶子节点和叶子节点都会存放数据。</li>
</ul>
<p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图</p>
<p><img src="https://s2.loli.net/2024/11/26/5SQDnqfm8HbcEyr.png" alt="100_演示图_03.png"></p>
<p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。  这样看来B+树和B-树有以下区别</p>
<ul>
<li>所有的数据都会出现在叶子节点。</li>
<li>叶子节点形成一个单向链表。</li>
<li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li>
</ul>
<p>在MySQL中，对经典的B+Tree数据结构进行了优化，在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。如下图。</p>
<p><img src="https://s2.loli.net/2024/11/26/7ZJbL1KVn4f8tBG.png" alt="100_演示图_04.png"></p>
<h3 id="Hash">Hash</h3>
<p>概念：哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p>
<p><img src="https://s2.loli.net/2024/11/26/pXyItfc4lT2AQvR.png" alt="100_演示图_05.png"></p>
<p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>
<p><img src="https://s2.loli.net/2024/11/26/rO6wJW3sibhPHY1.png" alt="100_演示图_06.png"></p>
<p>特点</p>
<ul>
<li>Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</li>
<li>无法利用索引完成排序操作</li>
<li>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</li>
</ul>
<p>存储引擎支持<br>
在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下<strong>自动构建</strong>的。</p>
<h2 id="索引分类">索引分类</h2>
<p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键 索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建, 只能 有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一 索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规 索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文 索引</td>
<td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody>
</table>
<h3 id="聚集索引-二级索引">聚集索引&amp;二级索引</h3>
<p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td>
<td>必须有,而且只 有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody>
</table>
<p>聚集索引选取规则:</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引。</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li>
</ul>
<p>聚集索引和二级索引的具体结构如下：</p>
<p><img src="https://s2.loli.net/2024/11/26/ElsgkG3fOBTnoPV.png" alt="100_演示图_07.png"></p>
<p>聚集索引的叶子节点下挂的是这一行的数据 ,二级索引的叶子节点下挂的是该字段值对应的主键值.</p>
<p>其具体的查找过程如下</p>
<p><img src="https://s2.loli.net/2024/11/26/7X291gyBJqfj53e.png" alt="100_演示图_08.png"></p>
<ol>
<li>由于是根据name字段进行查询，所以先根据name='Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li>
<li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li>
<li>最终拿到这一行的数据，直接返回即可。</li>
</ol>
<p><strong>回表查询</strong>： 这种<strong>先到二级索引中查找数据</strong>，找到主键值，然后<strong>再到聚集索引中根据主键值</strong>，获取数据的方式，就称之为回表查询。 由此我们可以推断，<strong>聚集索引搜索比二级索引搜索效率要高</strong>。</p>
<p>计算题：计算InnoDB主键索引的B+Tree高度。</p>
<p>查看答案</p>
<div class="hide-block"><button type="button" class="hide-button" style>查看答案</button><div class="hide-content"><p>解：设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。<br>
当树的高度为2：n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170，得1171* 16 = 18736<br>
也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p>
</div></div>
<h2 id="索引语法">索引语法</h2>
<ol>
<li>查看索引</li>
</ol>
<p>语法：<code>show index from table_name;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 展示索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="comment">-- 在linux中输出结果表格断行，建议末尾加上\G,其他情况的表格断行也可以使用</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/4aPLT5uwqbXyEzn.png" alt="002_存储索引_02.png"></p>
<ol start="2">
<li>创建索引</li>
</ol>
<p>语法：<code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;  </code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一般索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/tq8DZxeBIvc5FfL.png" alt="002_存储索引_03.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/m74j3DMpszYdy6S.png" alt="002_存储索引_04.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/EGKDjf1e2vgF8hq.png" alt="002_存储索引_05.png"></p>
<ol start="3">
<li>删除索引</li>
</ol>
<p>语法：<code>DROP INDEX index_name ON table_name</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br></pre></td></tr></table></figure>
<h2 id="SQL性能分析">SQL性能分析</h2>
<h3 id="SQL执行频率">SQL执行频率</h3>
<p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql执行频率</span></span><br><span class="line"><span class="comment">-- session 是查看当前会话</span></span><br><span class="line"><span class="comment">-- global 是查询全局数据</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/qerfIgZlNWaAnPD.png" alt="003_SQL性能分析_01.png"></p>
<p>这其中<code>Com_delete</code>是删除次数 <code>Com_insert</code>是插入次数 <code>Com_select</code>是查询次数 <code>Com_update</code>是更新次数</p>
<blockquote>
<p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了</p>
</blockquote>
<h3 id="慢查询日志">慢查询日志</h3>
<p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>
MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variable <span class="keyword">like</span> &quot;slow_query_log&quot;</span><br><span class="line"><span class="comment">-- 结果为</span></span><br><span class="line"><span class="comment">-- +----------------+-------+</span></span><br><span class="line"><span class="comment">-- | Variable_name  | Value |</span></span><br><span class="line"><span class="comment">-- +----------------+-------+</span></span><br><span class="line"><span class="comment">-- | slow_query_log | OFF    |</span></span><br><span class="line"><span class="comment">-- +----------------+-------+</span></span><br></pre></td></tr></table></figure>
<p>在MySQL中慢查询默认关闭，如果要开启慢日志，需要先退出MySQL(<code>quit</code>)在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启MySQL慢日志查询开关</span></span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">-- 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/X7mtJbciK8aWDwR.png" alt="003_SQL性能分析_02.png"></p>
<p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 重启MySQL服务器</span><br><span class="line">systemctl restart mysqld</span><br><span class="line">-- 其慢查询文件放在cd /var/lib/mysql 下，文件名为localhost-slow.log(我这里是hspEdu01-slow.log)</span><br></pre></td></tr></table></figure>
<p>再次查询后就会发现OFF变成了ON</p>
<p>这样当以后查询的时间超过2秒的时候，就会视为慢查询，然后记录在慢查询日志里，如下</p>
<p><img src="https://s2.loli.net/2024/11/26/VN1bIeY58jE2Jl3.png" alt="003_SQL性能分析_04.png"></p>
<h3 id="profile">profile</h3>
<p><code>show profiles</code> 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看是否支持profile</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/w8oApP5kCujXniH.png" alt="003_SQL性能分析_05.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看profile是否开启</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line"><span class="comment">-- +-------------+</span></span><br><span class="line"><span class="comment">-- | @@profiling |</span></span><br><span class="line"><span class="comment">-- +-------------+</span></span><br><span class="line"><span class="comment">-- |           0 |</span></span><br><span class="line"><span class="comment">-- +-------------+</span></span><br></pre></td></tr></table></figure>
<p>可以看到MySQL支持profile操作但是没有开启,可以通过set语句在(session/global级别开启profiling)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启profile</span></span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>测试一下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;白起&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles ;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/k8TcEnhs6tdRpeo.png" alt="003_SQL性能分析_06.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看指定ID的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">55</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/D27WAfRiap5zSy6.png" alt="003_SQL性能分析_07.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看指定ID的占用CPU的情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query <span class="number">92</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/8VhEsyrmHNwXKO1.png" alt="003_SQL性能分析_08.png"></p>
<h3 id="explain">explain</h3>
<p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 ;</span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="comment">-- 在语句前添加explain就行</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ES3yUGID4Jcd8iF.png" alt="003_SQL性能分析_09.png"></p>
<p>解释</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
</tbody>
</table>
<h2 id="索引使用">索引使用</h2>
<p>演示索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 演示</span></span><br><span class="line">explain <span class="keyword">select</span> s.<span class="operator">*</span>,c.<span class="operator">*</span> <span class="keyword">from</span> student s,course c,student_course sc <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/fcy6dRDePrOplZt.png" alt="003_SQL性能分析_10.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 嵌套语句的分析</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student s <span class="keyword">where</span> s.id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> studentid <span class="keyword">from</span> student_course sc <span class="keyword">where</span> sc.courseid <span class="operator">=</span> (</span><br><span class="line">        <span class="keyword">select</span> id <span class="keyword">from</span> course c <span class="keyword">where</span> c.name <span class="operator">=</span> <span class="string">&#x27;MySQL&#x27;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/rTy2sdWij8IHvRn.png" alt="003_SQL性能分析_11.png"></p>
<p>如果是数据量大的数据库，在查询的时候有索引和没有索引是两个效率，所以对于数据量大、经常被查询的表，创建索引是非常有效的方法。</p>
<h3 id="最左前缀法则">最左前缀法则</h3>
<p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会<strong>部分失效</strong>(后面的字段索引失效)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询从索引的最左列开始，并且不跳过索引中的列</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/q4gkK6H5IoUzPZb.png" alt="003_SQL性能分析_12.png"></p>
<p>讲解：假设存在一张tb_user 表，其中有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。对于最左前缀法则指的是，查询时，<strong>最左边的列</strong>，也就是profession<strong>必须存在</strong>，否则索引<strong>全部失效</strong>。而且中间不能跳过某一列，否则该列后面的字段索引将失效。  比如上面的在查询的时候只有<code>age</code>和<code>status</code> 没有<code>profession</code> 所以索引失效(NULL).</p>
<blockquote>
<p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p>
</blockquote>
<h3 id="范围查询">范围查询</h3>
<ol>
<li>联合索引中，出现范围查询，则范围查询右侧的列索引失效</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 范围查询</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">&gt;</span><span class="number">30</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/zkTKXrRZSCtyElf.png" alt="003_SQL性能分析_13.png"></p>
<p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。</p>
<p>在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或  &lt;.</p>
<ol start="2">
<li>不要在索引列上进行运算操作，否则索引失效</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/GfIDjSvUcKJ64qd.png" alt="003_SQL性能分析_14.png"></p>
<ol start="3">
<li>字符串不加引号会失效:原因 <strong>存在隐式类型转换</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990013</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/exET3cPQr4uYXI5.png" alt="003_SQL性能分析_15.png"></p>
<ol start="4">
<li>头部模糊匹配会导致索引失效</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/OgnzGJqHS1KZE78.png" alt="003_SQL性能分析_16.png"></p>
<ol start="5">
<li>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/Khek5VsH41QGIgd.png" alt="003_SQL性能分析_17.png"></p>
<ol start="6">
<li>当mysql评估使用索引比全表搜索慢，就不会使用索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span><span class="string">&#x27;17799990000&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/NUkL5yI4ZqFRb8G.png" alt="003_SQL性能分析_18.png"></p>
<ol start="7">
<li>还有一种情况是使用<code>is null</code> 和<code>is not null</code> 是否走索引并不固定</li>
</ol>
<h3 id="SQL提示">SQL提示</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL提示</span></span><br><span class="line"><span class="comment">-- 准备索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro <span class="keyword">on</span> tb_user(profession);</span><br><span class="line"><span class="comment">-- 一般情况下此SQL语句使用的索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/9dph53gMBIrGNQX.png" alt="003_SQL性能分析_19.png"></p>
<p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示(指定MySQL使用哪些索引)来达到优化操作的目的。</p>
<ol>
<li>建议MySQL使用指定索引： <code>use index;</code> 有可能MySQL不接受</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用单列索引 某些情况下mysql可能不接受</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/SU2WMLKhZTbVzHx.png" alt="003_SQL性能分析_20.png"></p>
<ol start="2">
<li>忽略指定索引：<code>ignore index;</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 忽略某个索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/BMSYIK9u8k1iC4D.png" alt="003_SQL性能分析_21.png"></p>
<ol start="3">
<li>强制使用指定索引：<code>force index;</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 强制使用某个索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="覆盖索引">覆盖索引</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。也尽量减少使用select *</span></span><br><span class="line">explain <span class="keyword">select</span> id,profession,age,status,name <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/Wn23oEkjlsDqdPM.png" alt="003_SQL性能分析_22.png"></p>
<p>其中我们重点关注<code>Extra</code></p>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Using where; Using Index</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td>
</tr>
<tr>
<td>Using index condition</td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody>
</table>
<p>所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引），所以不建议使用select * 进行全字段查询。</p>
<p>演示覆盖索引与回表查询</p>
<p><img src="https://s2.loli.net/2024/11/26/lO4uocK1yfkV3jx.png" alt="100_演示图_09.png"></p>
<p>其中id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p>
<p><img src="https://s2.loli.net/2024/11/26/tAr8YFsZHLbvenU.png" alt="100_演示图_10.png"></p>
<p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p>
<p><img src="https://s2.loli.net/2024/11/26/Gr2doMCASYqgmNz.png" alt="100_演示图_11.png"></p>
<p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索<br>
引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p>
<p><img src="https://s2.loli.net/2024/11/26/Hyk5LjU2K9IzAim.png" alt="100_演示图_12.png"></p>
<p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。</p>
<h3 id="前缀索引">前缀索引</h3>
<p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法:<code>create index idx_xxxx on table_name(column(n)) ;  </code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建前缀索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<p><strong>前缀长度</strong>：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 选择性 当选择性趋于1(也就是唯一索引)的时候效率最高</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">10</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/6ln1rRwVsoSvjyK.png" alt="003_SQL性能分析_23.png"></p>
<p>展示索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 展示索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/rGiv74XynOIWP3T.png" alt="003_SQL性能分析_24.png"></p>
<p>前缀索引的查询流程</p>
<p><img src="https://s2.loli.net/2024/11/26/At9TiYkLUS5fmgc.png" alt="100_演示图_13.png"></p>
<h3 id="单列索引与联合索引">单列索引与联合索引</h3>
<p>单列索引：一个索引只包含单个列；联合索引：一个索引包含多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<h3 id="索引设置原则">索引设置原则</h3>
<ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索<br>
引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，<br>
避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增<br>
删改的效率。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含<br>
NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<hr>
<h1>SQL优化</h1>
<h2 id="插入优化">插入优化</h2>
<p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p>
<ol>
<li>使用批量插入</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化前</span></span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="keyword">Insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用事务(设置为手动提交)</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>主键顺序插入</li>
</ol>
<p>主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89  效率要高于乱序</p>
<ol start="4">
<li>大批量数据插入(万级别)</li>
</ol>
<p>使用MySQL的load指令，也就是读取sql文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 客户端连接服务端时，加上参数 -–local-infile</span><br><span class="line">mysql –-local-infile -u root -p</span><br><span class="line">-- 2. 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line">-- 3. 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.sql(数据的路径)&#x27; into table tb_user(指定的表) fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ; -- 读取数据时以逗号为间隔读取单个数据，当读取到\n自动换行。</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/nKyNkxEVT27wIqR.png" alt="003_SQL性能分析_25.png"></p>
<h2 id="主键优化">主键优化</h2>
<p>InnoDB中数据的组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表</p>
<p>见图<strong>100_演示图_04</strong> 其逻辑结构图见图 <strong>001_存储引擎_06</strong></p>
<p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。</p>
<p><strong>页分裂</strong>：页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p>
<p>此处留空:<strong>做三个manim动画演示顺序、乱序、页合并的步骤</strong></p>
<p><strong>顺序插入</strong>步骤如下</p>
<ol>
<li>从磁盘中申请页， 主键顺序插入</li>
<li>第一个页没有满，继续往第一页插入</li>
<li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li>
<li>当第二页写满了，再往第三页写入</li>
</ol>
<p><strong>乱序插入</strong>步骤如下</p>
<ol start="0">
<li>假如1、2页已满</li>
<li>再插入一个id为1、2页之中的数据，会直接开辟一个页(页3).</li>
<li>然后将1页后一半的数据放在刚开辟的页，再插入数据。</li>
<li>然后设置链表指针，为1-&gt;3-&gt;2</li>
</ol>
<p><strong>页合并</strong>：</p>
<ol>
<li>持续删除某个页的记录，看是否达到MERGE_THRESHOLD（默认为页的50%)</li>
<li>如果达到界限，InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</li>
<li>然后删除数据，并将页合并之后，如果再次插入新的数据，就会在后面的页面添加</li>
</ol>
<blockquote>
<p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定</p>
</blockquote>
<p><strong>索引设置原则</strong></p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
<li>业务操作时，避免对主键的修改</li>
</ul>
<h2 id="order-by优化">order by优化</h2>
<p>MySQL的排序，有两种方式：</p>
<ol>
<li>
<p><strong>Using filesort</strong> : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p>
</li>
<li>
<p><strong>Using index</strong> : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p>
</li>
</ol>
<p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p>
<p>测试</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql优化，由于字段没有索引，所以用filesort</span></span><br><span class="line">explain <span class="keyword">select</span> id, age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/QL4mE81asPrDnwG.png" alt="004_SQL优化_01.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> phone,age;</span><br></pre></td></tr></table></figure>
<p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了。</p>
<p>排序时,也需要满足<strong>最左前缀法则</strong>,否则也会出现 filesort。</p>
<p>order by<strong>优化原则</strong></p>
<ol>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li>
</ol>
<h2 id="group-by优化">group by优化</h2>
<p>没有索引情况下的查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 没有索引情况下的查询</span></span><br><span class="line">explain <span class="keyword">select</span> profession,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/J7disnyOeESvgR5.png" alt="004_SQL优化_02.png"></p>
<p>对于分组操作，在联合索引中，也是符合<strong>最左前缀法则</strong>的。</p>
<p>有索引情况下的查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建联合索引之后再次执行</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br><span class="line">explain <span class="keyword">select</span> profession,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/ZjixyRaB5p8tmEk.png" alt="004_SQL优化_03.png"></p>
<p><strong>group by优化原则</strong></p>
<ol>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在给联合索引命名时注意从左到右命名，方便查看是否符合最左前缀法则，如下</span></span><br><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/XxwmjUiyza68gKQ.png" alt="004_SQL优化_04.png"></p>
<h2 id="limit优化">limit优化</h2>
<p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p>
<p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化前</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 优化后，页数越多优化效果越明显</span></span><br><span class="line">explain <span class="keyword">select</span> s.<span class="operator">*</span> <span class="keyword">from</span> tb_user s,(<span class="keyword">select</span> id <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>,<span class="number">10</span>) a <span class="keyword">where</span> s.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure>
<h2 id="count优化">count优化</h2>
<p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p>
<ul>
<li>
<p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p>
</li>
<li>
<p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
</li>
</ul>
<p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</p>
<p>count的用法</p>
<table>
<thead>
<tr>
<th>count用 法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>count(主 键)</td>
<td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null)</td>
</tr>
<tr>
<td>count(字 段)</td>
<td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返 回给服务层，直接按行进行累加。</td>
</tr>
<tr>
<td>count(数 字)</td>
<td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。</td>
</tr>
<tr>
<td>count(*)</td>
<td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接 按行进行累加。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽量使用 count(*)。</p>
</blockquote>
<h2 id="update优化">update优化</h2>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;javaEE&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放</p>
<p>当我们在执行如下SQL时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;SpringBoot&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;PHP&#x27;</span> ;</span><br></pre></td></tr></table></figure>
<p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</p>
<blockquote>
<p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p>
</blockquote>
<h1>视图</h1>
<h2 id="语法-2">语法</h2>
<p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>
通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<ol>
<li>创建视图</li>
</ol>
<p>语法：<code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]  ;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图 会生成一个视图的文件夹，里面存放视图</span></span><br><span class="line"><span class="comment">-- or replace 是如果有就覆盖</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查询视图</li>
</ol>
<p>语法：<code>查看创建视图语句：SHOW CREATE VIEW 视图名称;  查看视图数据：SELECT * FROM 视图名称 ...... ;  </code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询创建视图语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="comment">-- 查看视图数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/Sbg6XFJ5inM3VNc.png" alt="005_视图_01.png"></p>
<ol start="3">
<li>修改视图</li>
</ol>
<p>语法：<code>方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]; 方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]  ;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改视图</span></span><br><span class="line"><span class="comment">-- 方式1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,<span class="keyword">no</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 方式2</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/kBOWxVqrRSPl4bH.png" alt="005_视图_02.png"></p>
<ol start="4">
<li>删除视图</li>
</ol>
<p>语法：<code>DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...  ;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> stu_v_1;</span><br></pre></td></tr></table></figure>
<h2 id="视图检查">视图检查</h2>
<p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p>
<ol>
<li>
<p>CASCADED(级联)<br>
比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p>
</li>
<li>
<p>LOCAL(本地)</p>
<p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创<br>
建时未指定检查选项。 则在执行检查时，知会检查v2，不会检查v2的关联视图v1。</p>
</li>
</ol>
<h2 id="视图更新">视图更新</h2>
<p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一<br>
项，则该视图不可更新：</p>
<ol>
<li>
<p>聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</p>
</li>
<li>
<p>DISTINCT</p>
</li>
<li>
<p>GROUP BY</p>
</li>
<li>
<p>HAVING</p>
</li>
<li>
<p>UNION 或者 UNION</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 视图的更新和作用</span></span><br><span class="line"><span class="comment">-- 前提：视图中的行与基础表中的行之间必须存在一一对应的关系。</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_v_count <span class="keyword">as</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">insert into</span> stu_v_count <span class="keyword">values</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/IAPDmJVkQYCOn1N.png" alt="005_视图_05.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> learning.stu_v_1;</span><br><span class="line"><span class="keyword">insert into</span> learning.stu_v_1 <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;Tom&#x27;</span>);<span class="comment">-- 视图本身不能插入数据，会将数据插入原来的表中</span></span><br><span class="line"><span class="comment">-- 检查30&gt;20 所以报错</span></span><br><span class="line"><span class="keyword">insert into</span> learning.stu_v_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/X4s9muVaWDlBnRj.png" alt="005_视图_03.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于视图创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> learning.stu_v_1 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 测试插入数据</span></span><br><span class="line"><span class="keyword">insert into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">18</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="comment">-- 也就是说，如果基于视图创建视图但不添加检查选项时，就会依赖于父视图进行检查。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/casGbjU4vwHP3Oi.png" alt="005_视图_04.png"></p>
<p><strong>视图的优点</strong></p>
<ol>
<li><strong>简单</strong>：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li>
<li><strong>安全</strong>：数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</li>
<li><strong>数据独立</strong>：视图可帮助用户屏蔽真实表结构变化带来的影响。</li>
</ol>
<h2 id="视图的应用">视图的应用</h2>
<p>举例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 视图有点像是定制化的备份</span></span><br><span class="line"><span class="comment">-- 案例</span></span><br><span class="line"><span class="comment">-- 屏蔽手机号和邮箱</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_user_view <span class="keyword">as</span> <span class="keyword">select</span> id,name,profession,age,gender,status,createtime <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user_view;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/wgmxi9zOG2rIPAn.png" alt="005_视图_06.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 通过视图实现三表联查</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> <span class="keyword">select</span> s.name student_name,s.no student_no,c.name course_name <span class="keyword">from</span> student s,student_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> sc.courseid <span class="operator">=</span> c.id;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_stu_course_view;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/79g5UMTRO3EHatp.png" alt="005_视图_07.png"></p>
<h1>存储过程</h1>
<p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。<br>
存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用</p>
<p>特点：</p>
<ol>
<li>
<p>封装，复用。可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</p>
</li>
<li>
<p>可以接收参数，也可以返回数据。在存储过程中，可以传递参数，也可以接收返回值。</p>
</li>
<li>
<p>减少网络交互，效率提升。如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</p>
</li>
<li>
<p>创建存储过程</p>
</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/TWOvLQjxdeamCog.png" alt="006_储存过程_01.png"></p>
<ol start="2">
<li>调用存储过程</li>
</ol>
<p>语法：<code>CALL 名称 ([ 参数 ]);  </code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">call</span> p1();</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/PLz8hEqwNHGnSUJ.png" alt="006_储存过程_02.png"></p>
<ol start="3">
<li>查看存储过程</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>; <span class="comment">-- 查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ; <span class="comment">-- 查询某个存储过程的定义</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库的存储过程</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;learning&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/hlkrDbZH1gUTOiQ.png" alt="006_储存过程_03.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看存储过程的创建语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/miUKeBIfbs3CRW9.png" alt="006_储存过程_04.png"></p>
<ol start="4">
<li>删除存储过程</li>
</ol>
<p>语法：<code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除存储过程</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:在命令行中(Linux使用MySQL)，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">    select count(*) from student;</span><br><span class="line"><span class="meta prompt_">end$</span><span class="language-bash">$</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/CeoEHSvudahNsfA.png" alt="006_储存过程_05.png"></p>
<h2 id="变量">变量</h2>
<h3 id="系统变量">系统变量</h3>
<p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p>
<ol>
<li>查看系统变量</li>
</ol>
<p>语法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES ; <span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;......&#x27;</span>; <span class="comment">-- 可以通过LIKE模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] 系统变量名; <span class="comment">-- 查看指定变量的值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看系统变量</span></span><br><span class="line"><span class="keyword">show</span> session variables ;</span><br><span class="line"><span class="comment">-- 模糊匹配</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看某一个变量</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/VoETYOUq63tmgPW.png" alt="007_变量_01.png"></p>
<ol start="2">
<li>设置系统变量</li>
</ol>
<p>语法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] 系统变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>]系统变量名 <span class="operator">=</span> 值 ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置系统变量</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- mysql服务重新启动后所设置的全局参数会失效，如果要永久改变需要在/etc/my.cnf中配置</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>概念：</p>
<ol>
<li>全局变量(GLOBAL): 全局变量针对于所有的会话。</li>
<li>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</li>
<li>未指定session或者global的时候默认是session</li>
</ol>
</blockquote>
<h3 id="用户定义变量">用户定义变量</h3>
<p>用户定义变量：是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。</p>
<ol>
<li>赋值</li>
</ol>
<p>语法1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr [, <span class="variable">@var_name</span> <span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自定义变量 冒号可加可不加,建议表示赋值的时候加</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myname</span> <span class="operator">=</span> <span class="string">&#x27;Lloyd&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myage</span> :<span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<p>语法2</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var_name</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用自定义变量</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@myname</span>,<span class="variable">@myage</span>;</span><br><span class="line"><span class="comment">-- 将查询的结果赋值给某变量</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@mycount</span> <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/gVpwnvRb6MTjm4Y.png" alt="007_变量_02.png"></p>
<blockquote>
<p>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p>
</blockquote>
<h3 id="局部变量">局部变量</h3>
<p>局部变量：是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，<strong>局部变量的范围是在其内声明的BEGIN … END块</strong>。</p>
<ol>
<li>声明</li>
</ol>
<p>语法：<code>DECLARE 变量名 变量类型 [DEFAULT ... ] ;  </code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明 使用关键字declare 一旦超出范围无法使用</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p2()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> stu_count <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> stu_count <span class="keyword">from</span> student;</span><br><span class="line">    <span class="keyword">select</span> stu_count;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p2();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>赋值</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名 ... ;</span><br></pre></td></tr></table></figure>
<h3 id="常使用的“关键字”">常使用的“关键字”</h3>
<h4 id="if">if</h4>
<p>和编程语言一样。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">	.....</span><br><span class="line">ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> <span class="comment">-- 可选</span></span><br><span class="line">	.....</span><br><span class="line"><span class="keyword">ELSE</span> <span class="comment">-- 可选</span></span><br><span class="line">	.....</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">57</span>;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">    if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">    elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p3();</span><br></pre></td></tr></table></figure>
<h4 id="参数">参数</h4>
<p>类型如下</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody>
</table>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ <span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程的参数</span></span><br><span class="line"><span class="comment">-- 输入的参数是score 输出的参数是result</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p4(<span class="keyword">in</span> score <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">    elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明</span></span><br><span class="line"><span class="keyword">call</span> p4(<span class="number">68</span>,<span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;<span class="comment">-- 返回结果为及格</span></span><br></pre></td></tr></table></figure>
<h4 id="case">case</h4>
<p>和C语言的case基本一样</p>
<p>语法1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，</span></span><br><span class="line">执行statement_list2， 否则就执行 statement_list</span><br><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line">	<span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">	[ <span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">	[ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>
<p>语法2</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成</span></span><br><span class="line">立时，执行statement_list2， 否则就执行 statement_list</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">	<span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">	[<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">	[<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- case</span></span><br><span class="line"><span class="comment">-- 案例：按照季度展示数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p6(<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第一季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第二季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第三季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span><span class="number">12</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第四季度&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;非法参数&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为: &#x27;</span>,<span class="keyword">month</span>,<span class="string">&#x27;,所属的季度为: &#x27;</span>,<span class="keyword">result</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p6(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="while">while</h4>
<p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span></span><br><span class="line">WHILE 条件 DO</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- while</span></span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p7(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    while n <span class="operator">&gt;</span> <span class="number">0</span> do</span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n:<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 从1到10累加循环</span></span><br><span class="line"><span class="keyword">call</span> p7(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/IbVMag5PJ794F6l.png" alt="008_循环_01.png"></p>
<h4 id="repeat">repeat</h4>
<p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。和<code>do ...while </code>很像。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span></span><br><span class="line">REPEAT</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line">	UNTIL 条件</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- repeat</span></span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p8(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    until n<span class="operator">&lt;=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> repeat ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">10</span>);<span class="comment">-- 结果同图008_循环_01 为55</span></span><br></pre></td></tr></table></figure>
<h4 id="loop">loop</h4>
<p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	SQL逻辑...</span><br><span class="line">END LOOP [end_label];</span><br><span class="line">-- </span><br><span class="line">-- 以上所有的label都是自定义的标记</span><br><span class="line">LEAVE label; -- 退出指定标记的循环体 相当于break</span><br><span class="line">ITERATE label; -- 直接进入下一次循环 相当于continue</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- loop</span></span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span></span><br><span class="line"><span class="comment">-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xx</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sum:loop</span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span>  <span class="comment">-- 终止条件</span></span><br><span class="line">            leave sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 判断是否为奇数</span></span><br><span class="line">        if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">            iterate sum;<span class="comment">-- iterate 表示进入下一次循环，相当于continue</span></span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span> loop sum;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 累加偶数</span></span><br><span class="line"><span class="keyword">call</span> p9(<span class="number">10</span>); <span class="comment">-- 结果为 30</span></span><br></pre></td></tr></table></figure>
<h3 id="游标">游标</h3>
<p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法为</p>
<ol>
<li>声明游标</li>
</ol>
<p>语法：<code>DECLARE 游标名称 CURSOR FOR 查询语句 ;  </code></p>
<ol start="2">
<li>打开游标</li>
</ol>
<p>语法：<code>OPEN 游标名称;</code></p>
<ol start="3">
<li>获取游标记录</li>
</ol>
<p>语法：<code>FETCH 游标名称 INTO 变量 [, 变量 ] ;  </code></p>
<ol start="4">
<li>关闭游标</li>
</ol>
<p>语法：<code>CLOSE 游标名称;</code></p>
<p>以上语句在不使用条件处理程序的时候虽然能实现需求，但是MySQL会报错，在逻辑上是有漏洞的，需要增加条件处理程序进行修补。</p>
<p><strong>条件处理程序</strong></p>
<p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤(相当于<code>try.. default</code>)</p>
<p>语法为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_action HANDLER <span class="keyword">FOR</span> condition_value [, condition_value] ... statement ;</span><br><span class="line">handler_action 的取值：</span><br><span class="line">	CONTINUE: 继续执行当前程序</span><br><span class="line">	EXIT: 终止执行当前程序</span><br><span class="line">condition_value 的取值：</span><br><span class="line">	<span class="keyword">SQLSTATE</span> sqlstate_value: 状态码，如 <span class="number">02000</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">SQLWARNING</span>: 所有以<span class="number">01</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">	<span class="keyword">NOT</span> FOUND: 所有以<span class="number">02</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">	<span class="keyword">SQLEXCEPTION</span>: 所有没有被<span class="keyword">SQLWARNING</span> 或 <span class="keyword">NOT</span> FOUND捕获的<span class="keyword">SQLSTATE</span>代码的简写</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 储存查询结果集的数据类型</span></span><br><span class="line"><span class="comment">-- 声明游标</span></span><br><span class="line"><span class="comment">-- 添加条件处理程序</span></span><br><span class="line"><span class="comment">-- 逻辑:</span></span><br><span class="line"><span class="comment">-- A. 声明游标, 存储查询结果集</span></span><br><span class="line"><span class="comment">-- B. 准备: 创建表结构</span></span><br><span class="line"><span class="comment">-- C. 开启游标</span></span><br><span class="line"><span class="comment">-- D. 获取游标中的记录</span></span><br><span class="line"><span class="comment">-- E. 插入数据到新表中</span></span><br><span class="line"><span class="comment">-- F. 关闭游标</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p10(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 声明一个游标并记录查询结果的表</span></span><br><span class="line">    <span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">    <span class="comment">-- 当状态码为02000时 将游标关闭</span></span><br><span class="line">    <span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">    <span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span>  tb_user_pro(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">        profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 开启游标</span></span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    <span class="comment">-- 循环获取表中的记录</span></span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">        <span class="comment">-- 获取游标中的记录并复制给相应的变量</span></span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">        <span class="comment">-- 插入到表中</span></span><br><span class="line">        <span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span>(<span class="keyword">null</span>,uname,upro);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="comment">-- 关闭游标</span></span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 查询年龄小于40的用户并将其插入表中</span></span><br><span class="line"><span class="keyword">call</span> p10(<span class="number">40</span>);</span><br></pre></td></tr></table></figure>
<p>错误状态码<a target="_blank" rel="noopener external nofollow noreferrer" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">参考网站</a></p>
<h2 id="存储函数">存储函数</h2>
<p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">RETURNS</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line">	<span class="keyword">RETURN</span> ...;</span><br><span class="line"><span class="keyword">END</span> ;</span><br><span class="line"><span class="comment">-- characteristic说明</span></span><br><span class="line"><span class="comment">-- DETERMINISTIC：相同的输入参数总是产生相同的结果</span></span><br><span class="line"><span class="comment">-- NO SQL ：不包含 SQL 语句</span></span><br><span class="line"><span class="comment">-- READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</span></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fun1(n <span class="type">int</span>) <span class="comment">-- 不写默认为in</span></span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    while n <span class="operator">&gt;</span> <span class="number">0</span> do</span><br><span class="line">        <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n :<span class="operator">=</span> n <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 如果报错就登录Linux的mysql，然后输入set global log_bin_trust_function_creators = 1;即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="keyword">select</span> fun1(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定characteristic特性，否则就会报错</p>
<h1>触发器</h1>
<p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。<br>
使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<p>类型</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
<ol>
<li>创建</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	trigger_stmt ;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时创建触发器</span></span><br><span class="line"><span class="keyword">create table</span> user_logs(</span><br><span class="line">                          id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> auto_increment,</span><br><span class="line">                          operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作类型, insert/update/delete&#x27;</span>,</span><br><span class="line">                          operate_time datetime <span class="keyword">not null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">                          operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作的ID&#x27;</span>,</span><br><span class="line">                          operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line">                          <span class="keyword">primary key</span>(`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"><span class="comment">-- 插入时创建触发器</span></span><br><span class="line"><span class="comment">-- 插入时的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">    after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">        (<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),NEW.id,concat(<span class="string">&#x27;插入的数据内容为:id=&#x27;</span>,NEW.id,<span class="string">&#x27;,name=&#x27;</span>,NEW.name,<span class="string">&#x27;,phone = &#x27;</span>,NEW.phone,<span class="string">&#x27;,email=&#x27;</span>, NEW.email,<span class="string">&#x27;,profession=&#x27;</span>,NEW.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看</li>
</ol>
<p>语法：<code>SHOW TRIGGERS;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">show</span> triggers ;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/xRLljMB1zPG9XHw.png" alt="009_触发器_01.png"></p>
<ol start="3">
<li>删除</li>
</ol>
<p>语法：<code>DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> tb_user_insert_trigger;</span><br></pre></td></tr></table></figure>
<p>示例，测试触发器是否在插入的时候正常出发</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试-插入数据</span></span><br><span class="line"><span class="keyword">insert into</span> tb_user(id, name, phone, email, profession, age, gender, status, createtime)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">25</span>,<span class="string">&#x27;二皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试-更新数据</span></span><br><span class="line"><span class="comment">-- 修改数据的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">    after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">        (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),NEW.id,concat(<span class="string">&#x27;更新前的数据内容为:id=&#x27;</span>,OLD.id,<span class="string">&#x27;,name=&#x27;</span>,OLD.name,<span class="string">&#x27;,phone = &#x27;</span>,OLD.phone,<span class="string">&#x27;,email=&#x27;</span>, OLD.email,<span class="string">&#x27;,profession=&#x27;</span>,OLD.profession,<span class="string">&#x27;</span></span><br><span class="line"><span class="string">           | 更新后的数据内容为:id=&#x27;</span>,NEW.id,<span class="string">&#x27;,name=&#x27;</span>,NEW.name,<span class="string">&#x27;,phone = &#x27;</span>,NEW.phone,<span class="string">&#x27;,email=&#x27;</span>, NEW.email,<span class="string">&#x27;,profession=&#x27;</span>,NEW.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试-删除数据</span></span><br><span class="line"><span class="comment">-- 删除数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">    after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">        (<span class="keyword">null</span>,<span class="string">&#x27;delete&#x27;</span>,now(),OLD.id,concat(<span class="string">&#x27;删除前的数据内容为:id=&#x27;</span>,OLD.id,<span class="string">&#x27;,name=&#x27;</span>,OLD.name,<span class="string">&#x27;,phone = &#x27;</span>,OLD.phone,<span class="string">&#x27;,email=&#x27;</span>, OLD.email,<span class="string">&#x27;,profession=&#x27;</span>,OLD.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure>
<p>插入后</p>
<p><img src="https://s2.loli.net/2024/11/26/XRCnGSgbQp4uZ5q.png" alt="009_触发器_02.png"></p>
<p>更新后</p>
<p><img src="https://s2.loli.net/2024/11/26/YJxd7BpvKR5WuoF.png" alt="009_触发器_03.png"></p>
<p>删除后</p>
<p><img src="https://s2.loli.net/2024/11/26/eafiS1lWk9B5g3h.png" alt="009_触发器_04.png"></p>
<h1>锁</h1>
<p>定义：锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>分类为</p>
<ul>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据</li>
</ul>
<h2 id="全局锁">全局锁</h2>
<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>
其典型的使用场景是做<strong>全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>原理：比如先备份了库存表，在备份订单表之前就被修改了，然后导致备份的订单表和之前备份的库存表对不上。</p>
<p>解决方案：对数据库进行进行逻辑备份之前，先对<strong>整个数据库加上全局锁</strong>，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，<strong>但是可以执行DQL语句，也就是处于只读状态</strong>，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p>
<ol>
<li>加全局锁</li>
</ol>
<p>语法：<code>flush tables with read lock;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock ;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数据备份</li>
</ol>
<p>语法：<code>mysqldump -uroot –p用户密码 指定的表 &gt; 指定名字.sql  ;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 备份(windows系统)</span></span><br><span class="line"><span class="comment">-- mysqldump -h虚拟机的IP -uroot -p你的密码 learning &gt; D:/copy/learning.sql 要保存到的路径</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>释放锁</li>
</ol>
<p>语法：<code>unlock tables;</code></p>
<p>加全局锁会有以下问题</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/pRtqX7hukbaVD3g.png" alt="010_锁_01.png"></p>
<p>当解锁之后才能进行更新</p>
<p><img src="https://s2.loli.net/2024/11/26/vjpDof7VP6QeIkc.png" alt="010_锁_02.png"></p>
<ul>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ul>
<p>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- InnoDB引擎中，不加锁的一次性备份</span></span><br><span class="line"><span class="comment">-- mysqldump --single-transaction -h虚拟机的IP  -uroot -p你的密码 learning &gt;D:/code/remove/learning.sql</span></span><br></pre></td></tr></table></figure>
<h2 id="表级锁">表级锁</h2>
<p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中</p>
<p>分类</p>
<ul>
<li>表锁
<ul>
<li>表共享读锁(read lcok)</li>
<li>表独占写锁(write lock)</li>
</ul>
</li>
<li>元数据锁(meta data lcok,MDL)</li>
<li>意向锁</li>
</ul>
<h3 id="表锁">表锁</h3>
<ol>
<li>添加锁：</li>
</ol>
<p>语法：<code>lock tables 表名... read/write;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加只读锁</span></span><br><span class="line">lock tables course read;</span><br><span class="line"><span class="comment">-- DQL语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Java&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/dVLrF6CSuqDoMGj.png" alt="010_锁_03.png"></p>
<p>在设置共享读锁的时候只能读不能写</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能写</span></span><br><span class="line"><span class="keyword">insert into</span> course <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">&#x27;Linux&#x27;</span>);<span class="comment">-- 如果是其他的进程尝试写会阻塞</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/W6PApbLxGRkj5a7.png" alt="010_锁_04.png"></p>
<ol start="2">
<li>释放锁：<code>unlock tables;</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 释放表锁</span></span><br><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/jI5PUeVvWTOyl4N.png" alt="010_锁_05.png"></p>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加独写锁</span></span><br><span class="line">lock tables course write ;</span><br><span class="line"><span class="comment">-- 可读可写</span></span><br><span class="line"><span class="keyword">insert into</span> course <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">&#x27;Linux&#x27;</span>);<span class="comment">-- 其他的进程尝试读写会阻塞</span></span><br><span class="line"><span class="comment">-- 释放</span></span><br><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p>
</blockquote>
<h3 id="元数据锁">元数据锁</h3>
<p>meta data lock , 元数据锁，简写<strong>MDL</strong>。MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动<strong>事务</strong>的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。<br>
这里的<strong>元数据</strong>，大家可以简单理解为就是一张表的<strong>表结构</strong>。 也就是说，某一张表涉及到<strong>未提交的事务时，是不能够修改这张表的表结构的</strong>。<br>
在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。<br>
常见的SQL操作时，所添加的元数据锁</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock tables xxx read / write</td>
<td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、 delete、select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody>
</table>
<p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ /SHARED_WRITE），之间是兼容的，也就是允许并行开发。</p>
<p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。</p>
<p><img src="https://s2.loli.net/2024/11/26/cJNioFDxT79wL56.png" alt="010_锁_06.png"></p>
<p>事务提交之后</p>
<p><img src="https://s2.loli.net/2024/11/26/rFYl18MI6fjVzX3.png" alt="010_锁_07.png"></p>
<p>查看数据库中的元数据锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看元数据锁</span></span><br><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/xsCi6jkAbqpfREv.png" alt="010_锁_08.png"></p>
<h3 id="意向锁">意向锁</h3>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。  其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p>
<p>分类</p>
<ul>
<li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</li>
<li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li>
</ul>
<blockquote>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
</blockquote>
<p>查看意向锁及行锁的加锁情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span></span><br><span class="line">performance_schema.data_locks;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/PRN87WgcB3inCSY.png" alt="010_锁_09.png"></p>
<p>注意：意向共享锁与表读锁是兼容的、意向排他锁与表读锁、写锁都是互斥的</p>
<h2 id="行锁">行锁</h2>
<p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。<br>
InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的<br>
锁。对于行级锁，主要分为以下三类：</p>
<ul>
<li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/27/ghdv8so6mr7CAVY.png" alt="100_演示图_15.png"></p>
<ul>
<li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/27/B4K8fF5vmpiAxMd.png" alt="100_演示图_16.png"></p>
<ul>
<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/27/FrnjGt8akCq2W5E.png" alt="100_演示图_17.png"></p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他<br>
锁</li>
</ul>
<table>
<thead>
<tr>
<th>当前锁类型\请求锁类型</th>
<th>S(共享锁)</th>
<th>X(排他锁)</th>
</tr>
</thead>
<tbody>
<tr>
<td>S(共享锁)</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X(排他锁)</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody>
</table>
<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td>不加任何 锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在SELECT之后加LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在SELECT之后加FOR UPDATE</td>
</tr>
</tbody>
</table>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li>
</ul>
<p>示例</p>
<p><img src="https://s2.loli.net/2024/11/26/pgS6c4uqOitQlx2.png" alt="010_锁_10.png"></p>
<p>兼容性</p>
<p><img src="https://s2.loli.net/2024/11/26/nw8tjYNKgEZ9bpo.png" alt="010_锁_11.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/a4q61XnvMCwRzge.png" alt="010_锁_12.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/qDL4jZaR53QVK8c.png" alt="010_锁_13.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/BPMGV58fFr3gZdO.png" alt="010_锁_14.png"></p>
<p><img src="https://s2.loli.net/2024/11/26/SQsb3XhgW7HaBOJ.png" alt="010_锁_15.png"></p>
<p>如果没有索引，更新语句行锁会升级为表锁(因为行锁是对索引项加的锁，而某字段没有索引)  ，这样我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。</p>
<p>间隙锁和临键锁</p>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜<br>
索和索引扫描，以防止幻读。</p>
<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li>
<li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li>
</ul>
<blockquote>
<p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/11/26/UZwhtQ5VvrxecpL.png" alt="010_锁_16.png"></p>
<p>图中方框中的GAP就是间隙锁</p>
<p>常见的上锁情况</p>
<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li>
</ul>
<p>分析</p>
<p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p>
<p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。  比如查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部分：[19]、 (19,25]、 (25,+∞] 所以数据库数据在加锁时，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p>
<h1>InnoDB引擎</h1>
<p>逻辑存储结构见<code>001_存储引擎_06.png</code>和逻辑存储结构部分</p>
<p>参考黑马和这篇博客<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/2401_83283514/article/details/140721803">InnoDB引擎：底层结构及底层原理</a> ，讲解得足够详细。</p>
<p>这一部分的重点在于<strong>理解其实现原理</strong>，而不是死记硬背。</p>
<h1>MySQL管理</h1>
<p>系统自带的数据库</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysql</td>
<td>存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用 户、权限等）</td>
</tr>
<tr>
<td>information_schema</td>
<td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类 型及访问权限等</td>
</tr>
<tr>
<td>performance_schema</td>
<td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集 数据库服务器性能参数</td>
</tr>
<tr>
<td>sys</td>
<td>包含了一系列方便 DBA 和开发人员利用 performance_schema 性能数据库进行性能调优和诊断的视图</td>
</tr>
</tbody>
</table>
<h2 id="常用工具">常用工具</h2>
<h3 id="mysql的客户端工具"><strong>mysql的客户端工具</strong></h3>
<p>语法：<code>mysql [options] [database]</code> 在<strong>命令行</strong>中输入</p>
<p>option</p>
<ul>
<li>-u, --user=name #指定用户名</li>
<li>-p, --password[=name] #指定密码</li>
<li>-h, --host=name #指定服务器IP或域名</li>
<li>-P, --port=port #指定连接端口</li>
<li>-e, --execute=name #执行SQL语句并退出</li>
</ul>
<p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便</p>
<p><img src="https://s2.loli.net/2024/11/26/cVr7FzLDwqs1lnk.png" alt="012_mysql管理_02.png"></p>
<h3 id="mysqladmin">mysqladmin</h3>
<p>是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p>
<p>语法：<code>mysqladmin --help</code></p>
<p><img src="https://s2.loli.net/2024/11/26/24y6eSqDIjfm8oi.png" alt="012_mysql管理_03.png"></p>
<p>语法：<code>mysqlamin [options] command </code></p>
<p>options:</p>
<ul>
<li>-u, --user=name #指定用户名</li>
<li>-p, --password[=name] #指定密码</li>
<li>-h, --host=name #指定服务器IP或域名</li>
<li>-P, --port=port #指定连接端口</li>
</ul>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot –p1234 drop &#x27;test01&#x27;;</span><br><span class="line">mysqladmin -uroot –p1234 version;</span><br></pre></td></tr></table></figure>
<h3 id="mysqlbinlog">mysqlbinlog</h3>
<p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p>
<p>语法：<code>mysqlbinlog [options] log-files1 log-files2 ...  </code></p>
<p>options:</p>
<ul>
<li>-d, --database=name 指定数据库名称，只列出指定的数据库相关操作。</li>
<li>-o, --offset=# 忽略掉日志中的前n行命令。</li>
<li>-r,–result-file=name 将输出的文本格式日志输出到指定文件。</li>
<li>-s, --short-form 显示简单格式， 省略掉一些信息。</li>
<li>–start-datatime=date1 --stop-datetime=date2 指定日期间隔内的所有日志。</li>
<li>–start-position=pos1 --stop-position=pos2 指定位置间隔内的所有日志。</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/26/dHcx7UXhZiTa3kV.png" alt="012_mysql管理_04.png"></p>
<h3 id="mysqlshow">mysqlshow</h3>
<p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
<p>语法：<code>mysqlshow [options] [db_name [table_name [col_name]]]  </code></p>
<p>options</p>
<ul>
<li>–count 显示数据库及表的统计信息（数据库，表 均可以不指定）</li>
<li>-i 显示指定数据库或者指定表的状态信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询<span class="built_in">test</span>库中每个表中的字段书，及行数</span></span><br><span class="line">mysqlshow -uroot -p2143 test --count</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询<span class="built_in">test</span>库中book表的详细情况</span></span><br><span class="line">mysqlshow -uroot -p2143 test book --count</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/cIYJA9Lbjktq3g1.png" alt="012_mysql管理_05.png"></p>
<h3 id="mysqldump">mysqldump</h3>
<p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p>
<p>语法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br><span class="line"></span><br><span class="line">连接选项 ：</span><br><span class="line">-u, --user=name 指定用户名</span><br><span class="line">-p, --password[=name] 指定密码</span><br><span class="line">-h, --host=name 指定服务器ip或域名</span><br><span class="line">-P, --port=# 指定连接端口</span><br><span class="line">输出选项：</span><br><span class="line">--add-drop-database 在每个数据库创建语句前加上 drop database 语句</span><br><span class="line">--add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)</span><br><span class="line">-n, --no-create-db 不包含数据库的创建语句</span><br><span class="line">-t, --no-create-info 不包含数据表的创建语句</span><br><span class="line">-d --no-data 不包含数据</span><br><span class="line">-T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/11/26/k1IKbloOEAeWP2t.png" alt="012_mysql管理_06.png"></p>
<h3 id="mysqlimport-source">mysqlimport/source</h3>
<p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件</p>
<p>语法：<code>mysqlimport [options] db_name textfile1 [textfile2...]  </code></p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport -uroot -p2143 test /tmp/city.txt</span><br></pre></td></tr></table></figure>
<p>语法：如果需要导入sql文件,可以使用mysql中的source 指令 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /root/xxxxx.sql  # 这里的/root/xxxxx.sql是文件路径</span><br></pre></td></tr></table></figure>
<h1>参考</h1>
<ol>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/qq_45938466/article/details/107941557">数据库工作原理</a></li>
<li>黑马程序员的视频和pdf资料</li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://dev.mysql.com">MySQL官网</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai/">Lloyd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lloyd-kai.github.io/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/">http://lloyd-kai.github.io/2024/11/22/MySQL学习笔记(二)进阶篇/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://lloyd-kai.github.io" target="_blank">长沙理工大学机制2206班博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2024/10/25/RrwMATOW7uJoh43.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2024/10/25/RrwMATOW7uJoh43.png" alt="微信(WeChat)"/></a><div class="post-qr-code-desc">微信(WeChat)</div></li><li class="reward-item"><a href="https://paypal.me/lloydkai?country.x=C2&amp;locale.x=zh_XC" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2024/10/24/iPaXmYhtQnOsZrx.png" alt="PayPal(点击图片跳转 Click on the image to jump)"/></a><div class="post-qr-code-desc">PayPal(点击图片跳转 Click on the image to jump)</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/14/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%80)%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8F%8A%E5%85%B6%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="算法系列(一)蓝桥杯及其知识体系"><img class="cover" src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">算法系列(一)蓝桥杯及其知识体系</div></div><div class="info-2"><div class="info-item-1">总结了C/C++赛道蓝桥杯的知识点以及背后的算法原理，旨在为竞赛和后续算法学习打下基础</div></div></div></a><a class="pagination-related" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" title="数据结构可视化"><img class="cover" src="https://s2.loli.net/2024/10/22/C7PeB2UnGbc83Yo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据结构可视化</div></div><div class="info-2"><div class="info-item-1">本文章介绍了一些数据结构可视化开发的网站，帮助读者进行数据结构可视化开发。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%AF%87/" title="MySQL学习笔记(一)基础篇"><img class="cover" src="https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-30</div><div class="info-item-2">MySQL学习笔记(一)基础篇</div></div><div class="info-2"><div class="info-item-1">教你学会MySQL的基础知识，为测试、运维、后端开发、索引优化等方面做准备</div></div></div></a><a class="pagination-related" href="/2024/06/10/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%B8%80)%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%9B%B4%E6%96%B0/" title="hexo博客系列(一)测试与更新"><img class="cover" src="https://s2.loli.net/2024/10/22/8KJE1CP3nTIDFWm.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-10</div><div class="info-item-2">hexo博客系列(一)测试与更新</div></div><div class="info-2"><div class="info-item-1">用于博客测试和博客更新</div></div></div></a><a class="pagination-related" href="/2024/10/26/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%B8%89)%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/" title="hexo博客系列(三)博客写作指南"><img class="cover" src="https://s2.loli.net/2024/10/13/XLE3qtOQlyifzHC.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-26</div><div class="info-item-2">hexo博客系列(三)博客写作指南</div></div><div class="info-2"><div class="info-item-1">本文将从实战的角度出发，提供一套完整的 markdown 博客创作指南，帮助读者写出既有深度又美观的博客文章。</div></div></div></a><a class="pagination-related" href="/2024/06/12/hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97(%E4%BA%8C)%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/" title="hexo博客系列(二)博客创建指南"><img class="cover" src="https://s2.loli.net/2024/10/13/tfez8CIgnwY5iJh.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="info-item-2">hexo博客系列(二)博客创建指南</div></div><div class="info-2"><div class="info-item-1">教你如何创建一个简单的hexo博客</div></div></div></a><a class="pagination-related" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" title="数据结构可视化"><img class="cover" src="https://s2.loli.net/2024/10/22/C7PeB2UnGbc83Yo.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-03</div><div class="info-item-2">数据结构可视化</div></div><div class="info-2"><div class="info-item-1">本文章介绍了一些数据结构可视化开发的网站，帮助读者进行数据结构可视化开发。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/10/21/WXqzA7jMSxHo6fO.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lloyd</div><div class="author-info-description">哲学家只是用不同的方式来看待世界,而问题在于改变世界.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/lloyd-kai"><i class="fab fa-github"></i><span>访问我的Github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lloyd-kai/" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:kai9827@outlook.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=3472606843" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，此博客基于hexo和butterfly主题开发而成，希望来到此网站的同学们能够一起努力，追逐所愿。PS：站主要备考考研了,要等考完之后才有充足的时间回头来修改和完善博客,请大家耐心等待</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">MySQL体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">存储引擎的区别和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">2.4.</span> <span class="toc-text">存储引擎的选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.1.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree%E4%B8%8EB-Tree"><span class="toc-number">3.1.2.</span> <span class="toc-text">B-Tree与B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash"><span class="toc-number">3.1.3.</span> <span class="toc-text">Hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">聚集索引&amp;二级索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">索引语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">SQL性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="toc-number">3.4.1.</span> <span class="toc-text">SQL执行频率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">3.4.2.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#profile"><span class="toc-number">3.4.3.</span> <span class="toc-text">profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain"><span class="toc-number">3.4.4.</span> <span class="toc-text">explain</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">索引使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">3.5.1.</span> <span class="toc-text">最左前缀法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">范围查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%8F%90%E7%A4%BA"><span class="toc-number">3.5.3.</span> <span class="toc-text">SQL提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">3.5.4.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">3.5.5.</span> <span class="toc-text">前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">3.5.6.</span> <span class="toc-text">单列索引与联合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">3.5.7.</span> <span class="toc-text">索引设置原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">插入优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">主键优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#order-by%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">order by优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-by%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">group by优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#limit%E4%BC%98%E5%8C%96"><span class="toc-number">4.5.</span> <span class="toc-text">limit优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count%E4%BC%98%E5%8C%96"><span class="toc-number">4.6.</span> <span class="toc-text">count优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update%E4%BC%98%E5%8C%96"><span class="toc-number">4.7.</span> <span class="toc-text">update优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">5.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E6%A3%80%E6%9F%A5"><span class="toc-number">5.2.</span> <span class="toc-text">视图检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0"><span class="toc-number">5.3.</span> <span class="toc-text">视图更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">视图的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">系统变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">用户定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E2%80%9C%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9D"><span class="toc-number">6.1.4.</span> <span class="toc-text">常使用的“关键字”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case"><span class="toc-number">6.1.4.3.</span> <span class="toc-text">case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while"><span class="toc-number">6.1.4.4.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repeat"><span class="toc-number">6.1.4.5.</span> <span class="toc-text">repeat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loop"><span class="toc-number">6.1.4.6.</span> <span class="toc-text">loop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">6.1.5.</span> <span class="toc-text">游标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">存储函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">触发器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">8.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">8.2.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">8.2.1.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">8.2.2.</span> <span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">8.2.3.</span> <span class="toc-text">意向锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-number">8.3.</span> <span class="toc-text">行锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">InnoDB引擎</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">MySQL管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">10.1.</span> <span class="toc-text">常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7"><span class="toc-number">10.1.1.</span> <span class="toc-text">mysql的客户端工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqladmin"><span class="toc-number">10.1.2.</span> <span class="toc-text">mysqladmin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlbinlog"><span class="toc-number">10.1.3.</span> <span class="toc-text">mysqlbinlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlshow"><span class="toc-number">10.1.4.</span> <span class="toc-text">mysqlshow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqldump"><span class="toc-number">10.1.5.</span> <span class="toc-text">mysqldump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlimport-source"><span class="toc-number">10.1.6.</span> <span class="toc-text">mysqlimport&#x2F;source</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/" title="MySQL学习笔记(二)进阶篇"><img src="https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL学习笔记(二)进阶篇"></a><div class="content"><a class="title" href="/2024/11/22/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E8%BF%9B%E9%98%B6%E7%AF%87/" title="MySQL学习笔记(二)进阶篇">MySQL学习笔记(二)进阶篇</a><time datetime="2024-11-22T02:32:29.000Z" title="发表于 2024-11-22 10:32:29">2024-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%AF%87/" title="MySQL学习笔记(一)基础篇"><img src="https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL学习笔记(一)基础篇"></a><div class="content"><a class="title" href="/2024/10/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%AF%87/" title="MySQL学习笔记(一)基础篇">MySQL学习笔记(一)基础篇</a><time datetime="2024-10-30T12:23:09.000Z" title="发表于 2024-10-30 20:23:09">2024-10-30</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/02/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E5%9B%9B)Leetcode_labuladong%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E7%AF%87/" title="算法系列(四)Leetcode_labuladong算法笔记_基础篇"><img src="https://s2.loli.net/2024/10/13/UoQ1dIlXtehfvjx.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(四)Leetcode_labuladong算法笔记_基础篇"/></a><div class="content"><a class="title" href="/2025/03/02/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E5%9B%9B)Leetcode_labuladong%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E7%AF%87/" title="算法系列(四)Leetcode_labuladong算法笔记_基础篇">算法系列(四)Leetcode_labuladong算法笔记_基础篇</a><time datetime="2025-03-02T12:50:14.000Z" title="发表于 2025-03-02 20:50:14">2025-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/" title="算法系列(三)蓝桥杯_算法高阶(三)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(三)"/></a><div class="content"><a class="title" href="/2025/02/20/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_3/" title="算法系列(三)蓝桥杯_算法高阶(三)">算法系列(三)蓝桥杯_算法高阶(三)</a><time datetime="2025-02-20T00:07:57.000Z" title="发表于 2025-02-20 08:07:57">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(二)"/></a><div class="content"><a class="title" href="/2025/02/16/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_2/" title="算法系列(三)蓝桥杯_算法高阶(二)">算法系列(三)蓝桥杯_算法高阶(二)</a><time datetime="2025-02-16T07:16:45.000Z" title="发表于 2025-02-16 15:16:45">2025-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_1/" title="算法系列(三)蓝桥杯_算法高阶(一)"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(三)蓝桥杯_算法高阶(一)"/></a><div class="content"><a class="title" href="/2025/02/10/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%B8%89)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E9%AB%98%E9%98%B6_1/" title="算法系列(三)蓝桥杯_算法高阶(一)">算法系列(三)蓝桥杯_算法高阶(一)</a><time datetime="2025-02-10T05:15:23.000Z" title="发表于 2025-02-10 13:15:23">2025-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%BA%8C)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法系列(二)蓝桥杯_算法基础"><img src="https://s2.loli.net/2024/10/13/rVx9ogHB31wf4mJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法系列(二)蓝桥杯_算法基础"/></a><div class="content"><a class="title" href="/2025/01/12/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97(%E4%BA%8C)%E8%93%9D%E6%A1%A5%E6%9D%AF_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" title="算法系列(二)蓝桥杯_算法基础">算法系列(二)蓝桥杯_算法基础</a><time datetime="2025-01-12T05:31:17.000Z" title="发表于 2025-01-12 13:31:17">2025-01-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Lloyd</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lloyd-kai.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.2"></script><script src="/js/main.js?v=5.3.2"></script><script src="/js/tw_cn.js?v=5.3.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.19/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.19/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(() => {
  const abcjsInit = () => {
    const abcjsFn = () => setTimeout(() => {
      document.querySelectorAll(".abc-music-sheet").forEach(ele => {
        if (ele.children.length > 0) return
        ABCJS.renderAbc(ele, ele.innerHTML, {responsive: 'resize'})
      })
    }, 100)
    
    typeof ABCJS === 'object' ? abcjsFn()
      : btf.getScript('https://cdn.jsdelivr.net/npm/abcjs@6.4.4/dist/abcjs-basic-min.min.js').then(abcjsFn)
  }

  window.pjax ? abcjsInit() : window.addEventListener('load', abcjsInit)
  btf.addGlobalFn('encrypt', abcjsInit, 'abcjs')
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'lznevgEpvkZIT3hib1I36B54-gzGzoHsz',
      appKey: 'VvnbhZ2uIp2MRjW4y3ZFquQa',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-three-sand.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-api-three-sand.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.41/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Valine' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Valine' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer" data-id="2453833422" data-server="netease" data-type="playlist"  data-fixed="true" data-theme="#3F51B5"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.3.2"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/06/10/q24e9CMDLd8cYfa.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">Linux</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/06/10/QHqgRXDGwunkt4l.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">MySQL</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/06/10/R21dguZMKpAPhNf.png);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/blog/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">blog</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/kerNGo78PMwicnV.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">C++</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/22/xcyb68osB27rQfu.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/大数据/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">大数据</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/Qy4Edm6fxwKnbsL.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/algorithm/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">algorithm</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/KuYxMTlRckENvI5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/data-structure/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">data structure</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2024/10/13/HzredPNWp2Qs3oJ.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/English/&quot;);" href="javascript:void(0);" rel="external nofollow noreferrer">English</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="博客框架为Hexo_v7.3.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="主题版本Butterfly_v5.3.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用多线部署，副线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>